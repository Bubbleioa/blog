<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自动草稿</title>
    <link href="/2021/03/03/%E8%87%AA%E5%8A%A8%E8%8D%89%E7%A8%BF/"/>
    <url>/2021/03/03/%E8%87%AA%E5%8A%A8%E8%8D%89%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《瓦尔哈拉聊天室》——年终Project Rush开发报告</title>
    <link href="/2021/01/09/%E3%80%8A%E7%93%A6%E5%B0%94%E5%93%88%E6%8B%89%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%8B%E2%80%94%E2%80%94%E5%B9%B4%E7%BB%88Project%20Rush%E5%BC%80%E5%8F%91%E6%8A%A5%E5%91%8A/"/>
    <url>/2021/01/09/%E3%80%8A%E7%93%A6%E5%B0%94%E5%93%88%E6%8B%89%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%8B%E2%80%94%E2%80%94%E5%B9%B4%E7%BB%88Project%20Rush%E5%BC%80%E5%8F%91%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p>终于完成了，这个Project！<br>首先先简介下这个Project吧，这是一个由Unity驱动的文字冒险游戏小项目，目的是给10位朋友送上不同的新年祝福。<br>截止至目前还有1人没玩过orz</p><p>这里通过我的<code>TODO LIST</code>来介绍下整个Project的开发过程和思路吧。</p><ol><li>打字机效果</li><li>同时支持富文本</li><li>第二次按下提前结束打字机</li><li>打字音效</li><li>BGM</li><li>提供选项</li><li>对话分支</li><li>滚轮上滑打开历史消息</li><li>CTRL加速</li><li>读取和保存</li><li>实现文本云存储</li><li>开始菜单制作</li><li>自定义设置音量</li><li>人物表情动画系统</li><li>上传用户选项</li><li>结尾谢幕</li><li>留言板</li></ol><p>我是完全没有Unity/C#基础，做之前只看过M_Studio的10集小狐狸的课程，但是并没有涉及UI层的知识，但是……我这个Project全程都是在UI层实现的，所以还是没基础（<br>所以大部分操作实现起来很幼稚还望见谅。</p><h1 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h1><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-打字机效果"><a href="#1-打字机效果" class="headerlink" title="1.打字机效果"></a>1.打字机效果</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小丑竟是我自己——2020年度总结</title>
    <link href="/2021/01/09/%E5%B0%8F%E4%B8%91%E7%AB%9F%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E2%80%94%E2%80%942020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/09/%E5%B0%8F%E4%B8%91%E7%AB%9F%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E2%80%94%E2%80%942020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2021年都已经到来9天了，我终于打算写这个年度总结了，主要是南方太冷冻得手受不了。</p><p>正如标题所说，非得用一句话总结我的2020年，那可能就是“小丑竟是我自己”吧。</p><p>当然不是这句话得原意，而是字面意思。小丑总是滑稽可笑的，纵观这一年，除了外部的大环境，我本人的整个经历也是十分滑稽可笑。虽然本意并不是想要哭丧，但是咱也不能因为我现在的心情去掩盖掉当时的状况吧。</p><p>上半年就是一个字“逃”</p><p>首先就是开幕雷击的疫情+网课，这里其实我完成的是真不怎么样。有人说“你们网络直播班平时就是网课，疫情期间会有优势吧”，确实有，网课质量很高，也更适应这种模式。但是缺乏监管……我曾经有想过针对全班的解决方案，比如说钉钉啥的，腾讯会议啥的，强制开摄像头查看学习情况。但是最后还是逃避了这份责任。</p><p>回到学校之后也是很讨厌班上的某几个人，自己也就这样浑浑噩噩过完了高中最后几个月，高考比模拟考排名翻了3倍。其实我高考那两天状态挺好的，可能是吃了数学的亏吧……</p><p>不过我还是没有选择复读，我这个年纪本来就偏大了，再等一年耗不起，自己家里还有妹妹要上学。外公外婆尚且健康，就算是这样，家里除去不动产（也就3线城市两套房）已经是负债状态了。虽不算贫穷，但这个状态也称不上健康，稍微有点意外，可能就要卖房子。可能还有一个原因就是网上贩卖焦虑的太多，自己也被这些焦虑催着走吧。</p><p>高考完了，那所大学只看计算机的话，还是挺不错的归宿。但问题就是，我被分到土木。当时的我还没有意识到这个问题的严重性，大一确实没有什么重要的专业课不假，可后来无论是CPC的组队，还是计算机学习的各种方面的同学朋友（本校），都没有我。当然大学里还经历了种种事情，就不一一说了，总之就是非常小丑。</p><p>坏的东西都说完了，说点其他的吧。</p><p>玩过的游戏，看过的番、小说、书籍都变多了，其中也有许多非常喜欢的作品。</p><p>新年对自己提几点要求：</p><ol><li>健康的生活：很多时候，每到深夜，内心中的黑暗都会占据我的大脑，然后开始疯狂自闭，当然除了睡眠，饮食和锻炼也不能少。</li><li>减少社交依赖：这个意思是多关注我自己，回到我初中那种即使是一个人也能开心的状态，社交虽然有时候令人开心，但是那是建立在健康的自己上的，我现在太深陷社交只会伤害别人，伤害自己。</li><li>不再咕咕：自己定的目标、计划认真完成。能够完成自己定下的目标，就能增长自信，从而走出阴影，也能重回健康的自己吧。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>优秀的“宜居星球”——简评《异化之恶》</title>
    <link href="/2020/11/21/%E4%BC%98%E7%A7%80%E7%9A%84%E2%80%9C%E5%AE%9C%E5%B1%85%E6%98%9F%E7%90%83%E2%80%9D%E2%80%94%E2%80%94%E7%AE%80%E8%AF%84%E3%80%8A%E5%BC%82%E5%8C%96%E4%B9%8B%E6%81%B6%E3%80%8B/"/>
    <url>/2020/11/21/%E4%BC%98%E7%A7%80%E7%9A%84%E2%80%9C%E5%AE%9C%E5%B1%85%E6%98%9F%E7%90%83%E2%80%9D%E2%80%94%E2%80%94%E7%AE%80%E8%AF%84%E3%80%8A%E5%BC%82%E5%8C%96%E4%B9%8B%E6%81%B6%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>人类是从什么时候开始寻找除了地球之外，适合人类居住的行星呢？或许在殖民朝泛滥的时候，就有野心勃勃的人不满足地球上的七大洲，继而窥伺到地球之外。但随着地球环境压力不断增大，或者是满足人类征服地外行星的野心，就连最寻常的普通人，也开始觊觎地球之外的宜居星球。当然，还有一种心理，就是如果发现了这种可能，人们就会振臂高呼，肆意大胆地破坏地球，蹂躏我们的“母亲”。</p><p>开普勒452b就是这样一颗行星，它距离地球1402光年，游戏中的疗养院也使用着这个名字，院长把希望寄予这个疗养院，希望它能成为异化者的“开普勒452b”，我们能在BE同化之恶中理解他的想法。</p><p>且不论他的做法是否合适，但这无疑是十分理想主义的想法，正常者与异化者之间的壁垒无法逾越，正如1402光年的距离对于人类来说过于遥远。于是我们的卡莉娜（本体）想要将所有人转化成异化者，让这个世界成为异化者的国度。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/2020-11-21.png"></p><p>本作品非常难能可贵的一点是，作者通过它展示了作者本人希望所有人都幸福，都能够被温柔以待的想法，可依然选择了将现实展现给玩家，让玩家自行体会其中的矛盾与不可调和的感觉。可以说，每个内心温柔善良的人，在接触了社会的阴暗面之后，都会有这样的感觉，这类人往往会陷入对现状无法改变的苦恼，但依然会从行动与言语上尽量让周围的人温暖。</p><blockquote><p>不同立场的人肯定有不同的看法，不过同样立场的不同的人，也会有不同的看法。</p><p>有些人心怀善意，有人则不一样。</p><p>一定会的，她有爱她的人在身边。</p><p>——莫迪</p></blockquote><p>在通关之后的特典里，作者大大也说出了她的看法：</p><blockquote><p>至少在我们现在的世界里，大家可以完全选择更加包容的做法，尽可能地和谐共处而不仅仅是对立~！</p><p>所以，可以更积极地去理解这个游戏想要传达地含义吧！</p><p>——OvO</p></blockquote><p>以上就是关于我对剧情方面的理解啦，整个流程也很快，我有些地方卡关了也才花2个小时，接下来从游戏的其他角度粗略评价下吧！</p><p>首先从美术和音乐来说，真的非常不错。</p><p>美术包含了卡通风格的动画、人物立绘和UI，还有像素风格的游戏场景和cg。这样子的组合能够保证精美的同时节省工作量（像素部分），有一个可以提升的点就是游戏场景可以多做些像素动画（就是不知道引擎支不支持还有工作量估计会增加）。</p><p>音乐部分真的给我惊艳到了，从一楼的温馨到二楼的活力，三楼的不安到4楼的诡异。而且对于这个流程而言配乐数目很多，让我每次剧情推进都是新的体验。可以说这作给我带来的沉浸感，很大一部分来源于配乐的优秀。</p><p>游戏设计可能是整个游戏中<strong>相比其他部分而言</strong>最差的部分了。解密设置很幼稚加上地图的迷惑性导致了有很多时间无意义地浪费了（也许有一部分原因确实是因为引擎要实现起来不好做），这一部分作者在特典里也特意道歉了www，不过不是什么大问题，我就原谅你吧（你自己得意什么啊喂）。</p><p>最后说点吐槽的部分：</p><ol><li><p>8数码（也就是拼图）那里卡我好久，我也是老丈育了233</p></li><li><p>特典真的好棒！好喜欢这里的大家。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/2020-11-21-16.png"></p></li><li><p>玩到这里的时候，心里想：拜托啦，另一个我！</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/2020-11-21-6.png"></p></li><li><p>这张同人好像小鸟游六花啊（</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/2020-11-21-9.png"></p></li><li><p>TE的结尾之后那是卡莉娜在打破第四面墙吗？有点没看懂</p></li></ol><p>总而言之是一部优秀的作品，也期待作者的新作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在同一个世界站起来了，也会站在同一个未来</title>
    <link href="/2020/11/19/%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C%E7%AB%99%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%8C%E4%B9%9F%E4%BC%9A%E7%AB%99%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%9C%AA%E6%9D%A5/"/>
    <url>/2020/11/19/%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C%E7%AB%99%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%8C%E4%B9%9F%E4%BC%9A%E7%AB%99%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%9C%AA%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p>近闻我们学校终于有专属的信息学竞赛场地了，这可是百年之未有大变局啊！（</p><p>学弟学妹们好，我是你们2020届信息学竞赛学长，冒泡ioa(blog:<a href="http://bubbleioa.top/">bubbleioa.top</a>)</p><p>我的大学其实没什么好讲的，唯一可说的就是前几届CCPC决赛拿了前40名吧，如今我被调剂到土木专业（不过和计算机院的院长谈过了，大一还是修完计算机的课，CPC也可以正常参加，大二就可转过去）</p><p>作为本届最弱省一，我也只有经验丰富可以说了orz，接下来介绍的内容可能对于新生有些云里雾里，学弟学妹们可以先在<a href="https://oi-wiki.org/">OI Wiki</a>上阅读完信息学竞赛介绍部分。</p><p>首先要说的是，信息学竞赛只是计算机科学里面的冰山一角，就我接触的OIer来说，大学里有以下几个方向：</p><ol><li><p>CTF：这方面是往网络安全方向发展，含金量比较高，市场需求也大（详见：<a href="https://ctf-wiki.github.io/ctf-wiki/">CTF wiki</a>）</p></li><li><p>CPC(即ICPC和CCPC)：这是最接近OI的发展方向，虽然赛制不同，但是也是比拼算法设计的。</p></li><li><p>全栈：字面意思，全方位发展，总是是个很头秃的方向（我有一个学长现在就开始研究Linux源码了）</p></li><li><p>人工智能：略</p></li><li><p>计算机图形学：这个方向国内不多，在APIO2019上有一位首都师范大学附中的高二同学展示了他用OpenGL写的一个渲染器，这方向面向影视和游戏方向比较多。</p><p>还有4、5项融合起来的方向，你们看到的什么ai换脸，超分辨率（英伟达的DLSS），光线追踪，都是基于这些方向的研究。</p></li></ol><p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/IMG_20190519_084700.jpg"></p><p>事实上，高中的生活非常精彩（虽然我在高中的时候并没有那么认为），生活充实，好友成群，我在退役的时候写了一篇博客，即使是拿到现在来看，我依然是这么想的：</p><blockquote><p>在这段学习OI的日子里，由最初的认识到OI可以保送的光鲜外表，再到后来慢慢了解到她的真实、她的的残酷，喜欢的心情从未减少。<br>如果再给我一次选择的机会，我还是会选择接触OI，多亏了OI，让我的黑白的高中生活多了些斑斓的色彩。</p></blockquote><p>同样这样想的还有你们的林政学长：</p><blockquote><p>我知道我还是喜欢信息学的，就算它虐我千百遍，我依旧喜欢。</p><p>oi梦就像一颗休眠的种子，埋在我的心里。</p></blockquote><p>所有OIer都做着同一个梦。如成都七中的徐西岭所著<a href="https://zhuanlan.zhihu.com/p/117660874">《整形溢出：信息学竞赛的发展，繁荣与衰退》</a>，用着真诚关切的态度审视了信息学竞赛近年来的发展。还有同样是成都七中的<a href="https://mcfx.us/category/remmmmm/">mcfx</a>，完成了B站AV号与BV号互相转化的<a href="https://www.zhihu.com/question/381784377/answer/1099438784">全网首杀</a>。</p><p>这个梦甚至不局限于OIer，它属于全体竞赛生。南昌一中的天文社（放课后的昴宿星团），在2016年复出后，他们自发地参加CNAO，并且由于学习资料有限，19届社长还为他们社团编写了自己的教材《星空的秩序》（出于）</p><p>至于大学生活，其实刚上几个月课的我还没办法好好总结，不过可以肯定的是，你们将面临非常多的选择，会有很多困惑。苦恼会像洪水般涌来，孤独与无法被理解的心情会爬上心头。但是这不是个例，而且不算是坏事，届时你们将直面自己的内心，正如鲁迅先生在仙台一样，周围人的恶意，自己的孤立，若非怀有一颗赤诚之心，大多数人在大学的成长其实是不如高中的。（比如你们某个学长现在恋爱的苦恼中，哈哈哈）</p><p>而值得庆幸的是，高中参加过竞赛的同学们普遍都有着这种赤诚之心，这是一种对追逐星星的同伴们的惺惺相惜，这是一种能让你alone但是并不lonely的精神，而这种精神在大学的学习中将起到至关重要的作用。我尽管不是奥赛班的学生，但是毕业之后我联系最紧密的伙伴确实一块儿竞赛的伙伴们，希望学弟学妹们也要抱着成为终生益友的心态来交往，这是学OI获得的一生的财富。</p><blockquote><p>The home’s behind, the world’s ahead.</p><p>家乡已在身后，世界就在眼前。</p><p>——《霍比特人》</p><p>“在同一个世界 站起来了”</p><p>“也会站在同一个未来”</p><p>——《Euphoria》第30届IOI国际信息学奥林匹克主题曲</p></blockquote><p>最后选一张图片作为结尾吧，我就选我OI的终点——也是我新的起点，APIO2019的比赛场地的照片。希望学弟学妹们又能够在这场比赛拿奖的呀</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/IMG_20190516_142910.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不可解的我的一切</title>
    <link href="/2020/11/15/%E4%B8%8D%E5%8F%AF%E8%A7%A3%E7%9A%84%E6%88%91%E7%9A%84%E4%B8%80%E5%88%87/"/>
    <url>/2020/11/15/%E4%B8%8D%E5%8F%AF%E8%A7%A3%E7%9A%84%E6%88%91%E7%9A%84%E4%B8%80%E5%88%87/</url>
    
    <content type="html"><![CDATA[<p>这标题不是那本伪娘漫画啦！</p><p>而是：</p><p>我失恋了。（单恋）</p><p>很抱歉一上来就开幕雷击，这个抱歉是对多年后看到这篇文章的自己说的，万一你到时候还是单身会不会被气到呢233</p><p>不过，情感方面的东西一向不是我擅长的，所以就让我做一个标题党吧，把你们骗进来然后自说自话。</p><p>为了方便称呼就叫她惠酱吧（虽然好像这个化名和她完全不着边际）</p><blockquote><p>“少女漫画或情歌中的歌词，是那么璀璨耀眼。就算不查字典，也能看懂意思。可却无法属于我。”</p><p>——《终将成为你》</p></blockquote><p>在开始这段单恋之前，我也是这么想的（恰好也是惠酱拒绝我所提到的）</p><p>不，也许并不是，我只是单纯地认为单身是一件“高贵”的事情，总之就是嫌麻烦……</p><p>和她是在高中的一个魔法结社里认识的，我们都是那里的社员，每天研究着某些神秘的魔法回路。</p><blockquote><p> 抱歉我只能这么比喻了，要不然会被stk（其实只是想这样皮一下</p></blockquote><p>我那段时光可是开心得不得了啊！每天都可以研究魔法回路！欸，你问惠酱呢？她当时在我眼里只是一个普通的学习魔法的伙伴，虽然之后了解到我们的魔法相性挺好的，不过也就这样，没有过太多深入交流。要说为啥的话，魔法真的塔诺西！</p><p>后来结束了魔法学习，高考，毕业，各奔东西，完全没有在意惠酱。有人会问：那这么<strong>短时间</strong>你就在网上喜欢上她了？我今天在写这个博客之前也仔细想过，先埋个<strong>刀子</strong>（当然是刀我自己的）</p><p>上了大学之后当然就是按照我的规划来，站稳脚跟，去实现我的理想，弥补我中学因学业未能完成的List的缺憾。首先的肯定就是转专业，但是转专业这件事上导员说的很含糊，是学分还是成绩还是综评前15%？我不知道，虽然说“努力就可转专业了”，但这个过于飘渺，直接导致我大学一开始就是不安的。其次呢，找到一个组织，院团委和学生会二选一，我选了团委，但是意外地没啥事，也没有存在感；社团，动漫社就是打桌游，吉他社也没觉得要培养新人的样子，游戏社居然是一个新社而且社长是个大二的非计算机专业的学长，而且用的还是垃圾抄袭换皮工具<code>&quot;Reworld&quot;</code>，告辞！当时还和社长对线，并不能改变他的想法。所以呢，事实上我没有加入<strong>任何</strong>社团。原先学OI的朋友或者为了ACM，或者为了ctf都在努力地卷，连没有学OI的同学也开始学习语言学习算法，这种想法在我上化学和画法几何的时候尤为强烈。</p><ul><li>“我在这里到底在干什么啊！”</li><li>“不行，认真学习”</li><li>“万一转不了专业怎么办”</li><li>“啊……这里没听懂，万一就差这个分转专业怎么办？”</li></ul><p>无限地陷入这种思想的深渊，压抑到无法呼吸。要我说，这就是我的破防状态。</p><blockquote><p>谁来……救救我……</p></blockquote><p>当时心里真的有这种想法，虽然我知道这不可能，但是心中还是无限次地祈祷，奇迹能够发生，我能有一个光明且清楚的出路。</p><p>在9月初的时候惠酱因为一些事情渐渐和我有了联系，内容从服务器到python到动漫到游戏到日常……</p><p>这个时候怎么说呢，就对她产生了一种<strong>依赖感</strong>吧，每天最开心的就是和她聊天的时候，于是就告白了。当然这不是说喜欢的这份感情是假的，但是这种夹杂着依赖的感情的喜欢是<strong>不纯粹</strong>的（或者换句话说，是自私的）</p><p>我只想着自己这边怎么怎么样，从情书的内容都看得出来，全程装成很理性的样子，说什么结果无所谓，自己做好了准备。确实，我的确做好了失败的准备，但是是争对自己的，我没有考虑惠酱的想法，就这么直球了过去，真的是……自私……</p><p>（中间还省略了变得疏远的过程，就不展开说了）于是乎关系就变得疏远起来，这一周，我都不知道怎么就过去了orz，总之在关系到冰点的时候，我申请了学习的心理咨询。</p><p>结果没想到在咨询前的一个上午我自己解决了问题（至少是一部分），当然不是说剧情突然翻转，然后就GE了。要是我是主角的话，ATRI的那部分ATRI黑化后估计就是BE。那个上午解决的问题是转专业的问题，之前导员说的转专业策略只是学校的，而具体每个专业都有每个专业的文件（我不知道，他也没说），我在学校的教务系统翻到了去年CS的文件，好像我只要<strong>不留级就能转</strong>？！之后的心理辅导就是去和辅导老师唠嗑……</p><p>要是没有这个转机我现在估计已经坏掉了吧233，但是内心依然不轻松。</p><blockquote><p>如果没告白的话，该多好</p></blockquote><p>不止一次这样想，现在这在这样想……而且这种想法似乎追溯到高中，甚至开始想要是我高中怎么怎么样，就好了……</p><p>其实想法真的很多，可能是写出来的10到20倍之多吧，就是无法化为语言。</p><blockquote><p>“喜欢”是具有暴力性的字眼。——《终将成为你》</p></blockquote><p>我确实感受到了。</p><p>如果我是个诗人，我现在可以作诗抒怀；如果我是个歌手，我现在可以放声高歌；如果我是个酒鬼，我现在可以借酒消愁；如果我是个花花公子，我现在可以移情别恋 。但是我现在只能一遍遍将伤口加深刻在心中……不过这也是一种<strong>自我陶醉</strong>吧，通过<strong>惩罚</strong>自己来获得<strong>救赎</strong>。</p><p>今天去烫了个发，这个消费对于我这个双十一只买了一本书的老宅男来说简直冲动，据说2个多月头发就会长成不得不剃的长度。</p><p>最近也比较忙……下周周日数学期中考试，12.12英语4级，英语4级完了就是英语演讲轮到我，放假提早到1.5，期末也提早，所以后两周的课又要放到前面来上……转专业定了下来其实我的学业就稳了，即使心情低落应该我也能调整过来。</p><p>说实话这个寒假我真的想和她和好，但是她会接受吗？就算接受了，我对她又会是怎么看？她对我又怎么看？我会不会还是喜欢着她但是她对我还是没想法结果又重蹈覆辙？？啊啊啊好烦好烦！学习上的问题我可以问厉害的学长，老师；计算机上的问题可以goodle，大部分时候也很好解决，唯独这方面我是真的不知道怎么办QAQ，真的是“<em>不可解的我的一切</em>”啊</p><p>11月17日更新<br>从她朋友的口中得知她可能已经有<strong>喜欢的人</strong>了，是<strong>XX大学</strong>的，只不过还没开始追……<br>这个人好像之前在聊天中有点印象？其实知道了这一点的我释怀了很多，心情有点像暴风雨之前的宁静吧。<br><img src="http://bubbleioa.top/wp-content/uploads/2020/11/IMG_20201116_001256.jpg"><br>然后那天晚上我哭了，哭得很凶，大概是有生以来除了肢体受伤而哭得最厉害的一次…<br>第二天早上向她道了歉，希望和好，她同意了。去找了计算机学院的院长，开始打CPC了。不得不说程序设计竞赛真的塔诺西，找回了高中的感觉，我又恋爱了（<br>但是，晚上才发现，有经验的大佬们已经抱团组队了，只剩下我一个独狼。这种情况铁定拿不了校内第一名……心情又低落下来，真就正弦函数呗。<br>然后今天（凌晨也算今天吧233），她开通了匿名提问箱，本来我也没在意，没想到这个提问箱居然进化到匿名社交的程度了，我在她的关注里找到了一位“猫猫”，在看过他的简介和提问箱之后我确定了，他就是<strong>XX大学</strong>的，她朋友口中她喜欢的人。</p><p>然后我也不知道为啥我就跟他开聊了，感觉告白之后，又是找咱们院院长，又是计算机院院长，又是找CPC大佬，又找这位陌生人……已经没有什么好怕的了呢.jpg</p><p>打完招呼之后他的回答让我吓一跳，原来这个账号也是惠酱注册的吗？还好我还没暴露身份233（虽然确实不是她注册的。</p><p>虽然没有深入交流，但从目前可公开的情报来看，确实是一位十分优秀的人，平心而论，无论从哪方面讲，都比我更适合她。原先看《中二病》的时候就十分同情七宫，没想到时隔多年自己变成了七宫233</p><p>这样，这一切就已经结束了吧……变量少了一个，关于我的不可解的方程，应该也会更好解一些了吧</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么我没有女朋友？</title>
    <link href="/2020/11/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E6%B2%A1%E6%9C%89%E5%A5%B3%E6%9C%8B%E5%8F%8B%EF%BC%9F/"/>
    <url>/2020/11/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E6%B2%A1%E6%9C%89%E5%A5%B3%E6%9C%8B%E5%8F%8B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="http://bubbleioa.top/wp-content/uploads/2020/11/QQ%E6%88%AA%E5%9B%BE20201114113613.png"><br>每周一酸(1/1)</p><p>NASA结尾的操作十分精彩，学不来……但是有段话令我在意：</p><blockquote></blockquote><p>运气好，不是指我得救了……而是说我遇到了她，这可是0.00000034%。<br>有一个叫做德雷克公式的，如同妄想一样的公式。这虽然是用于集算宇宙有多少外星生命的方程式，但是有人把它运用了计算与命中注定的人相遇的几率上，那个几率是0.0000034%。<br>虽然实际上那个方程式没什么说服力，所以算出来的也不一定就是正确的数字，但我觉得，没准，还挺准确的。<br>只是感觉我找到了，出生之前就在寻找的东西”</p><p>（纠正下这个公式不是计算多少外星生命，而是计算多少有多少可交流的外星文明）</p><p>在银河系中随便选一个恒星系 能找到的概率是<code>0.00000003%</code>（没错 上面的概率也才是这个的100倍左右233）</p><p>但是这个概率是怎么来的呢？？</p><p>这个概率最早是在一篇名为”Why I don’t have girlfriend”的paper里面提到的，作者通过计算得出，在伦敦的夜晚出去逛，如果</p><ol><li><p>1/20的女性觉得我有吸引力</p></li><li><p>一般的女性单身</p></li><li><p>我能和1/10的女性相处融洽</p></li><li><p>合适的年龄范围</p></li></ol><p>在以上这些限制下，找到那个特殊的人的概率是<code>0.00000034%</code></p><p>当然 这只适合伦敦，剧中NASA肯定不是这个概率啦，而且这个概率就是图一乐，作者在文章里写的都是他的择偶标准，这里把他怎么计算到的说下（事实上可能更低</p><p>$ G=R×F_w×F_L×F_A×F_U×F_B×L $ </p><p>$ G$ =潜在的女友数</p><p>$R$ =本国人口增长(60,975,000)</p><p>$F_w$ =女性比例(0.51)</p><p>$F_L$ =生活在你城市的女性(0.13)</p><p>$F_A$ =年龄范围合适(0.2)</p><p>$F_U$ =年龄范围合适中有大学文凭的(0.26)</p><p>$F_B$ =年龄范围合适中有大学文凭的好看的(0.05)</p><p>$L$ =花多少年 (31，31岁单身，惨 作者 惨)</p><p>作者得到的<code>G=10,510</code>（不乘L的结果）然后后面就是一通乱算算出来的<code>0.00000034%</code>，看完之后又想笑，又想哭，不如就笑哭吧</p><p>paper链接：<a href="https://www.speedmagazine.ph/wp-content/uploads/2018/02/why_i_dont_have_a_girlfriend.pdf">https://www.speedmagazine.ph/wp-content/uploads/2018/02/why_i_dont_have_a_girlfriend.pdf</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>你好！我们又见面了呢~</title>
    <link href="/2020/10/18/%E4%BD%A0%E5%A5%BD%EF%BC%81%E6%88%91%E4%BB%AC%E5%8F%88%E8%A7%81%E9%9D%A2%E4%BA%86%E5%91%A2~/"/>
    <url>/2020/10/18/%E4%BD%A0%E5%A5%BD%EF%BC%81%E6%88%91%E4%BB%AC%E5%8F%88%E8%A7%81%E9%9D%A2%E4%BA%86%E5%91%A2~/</url>
    
    <content type="html"><![CDATA[<p>很久很久很久没更新博客了，不知道诸位有没有想我呢ww，还是面对这突然的更新心理想：“这谁啊！”</p><p>这次的文章想写成类似于一本书的后记的形式呢，我的人生的前半部分已然结束，在看这篇文章的诸位在之前或多或少介入过我的生活，所以作为我人生前半部分的读者，看到这样一篇后记，也才算是真正读完这本书。（其实就是想过把瘾）</p><p>但是直接刻板地去对书的内容做一个总结感想实在不是后记的形式，事实上，大部分书的后记都是说些有的没的和书无关的内容然后感谢一波和读者没啥关系的人呢。我正在读的一部轻小说的作者每次后记都要说自己的猫怎么怎么样，还说自己的猫会说：“饭（日语）”呢，怎么想都不可能吧，真的是一位病入膏肓的猫痴啊XD</p><p>不过说到书的后记，其实还有一部分内容是汇报自己新作的开展情况吧，正好大学生活已经开始一周了，是时候谈谈高中毕业后到大学这段时间的事情了。</p><p>金钱的重要性，在毕业之后愈发凸显。在师傅的介绍下，我在本地的一个教育培训机构开始了助教兼职。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20200815_095227-%E5%89%AF%E6%9C%AC.jpg" alt="" /></p><blockquote><p>刚刚忘记保存，丢了一半多的进度orz</p></blockquote><p>工作了16天，拿了1300+，算成时薪的话大概有18元，工作强度不大，还算是不错的工作……如果没有小学生的话。</p><p>我带了两个班，一个是初中生的，一个是小学生的。初中生的班级还行，小学生班上一个比一个皮，有几个男孩子上课吵个不停，还满口黄段子，简直让我心力憔悴……</p><p>不过呢，这也让我想起了我的小学，不也是这么过来的吗？我的邻居当时还被我们封上“变态淫魔”的“无上称号”，现在不也到了五道口某所大学上学去了。还有就是记得4年级以前，有一位喜欢摸别人生殖器的宋姓同学，简直是一生噩梦。</p><p>在这个暑假期间呢，我还向初中喜欢的女生“告白”了。之所以打上引号，是因为大多数的人告白都是为了发展成恋人关系，结婚生子，白头偕老吧（虽然有人只是想玩玩）虽然我们在同一所高中，但是这三年来也没怎么见过，而且我也知道我们之后并不会走到一块去。不过我仍然打算把这份“喜欢”的心情传达出去，处在一个缺少爱的环境中，尤为知道被爱的幸福。</p><p>兼职完之后，各个同学的升学宴就接踵而至。期间也没发生什么有意思的事情，我在我的升学宴上放了miku的舞蹈，十分满足o(<em>￣︶￣</em>)o</p><p>让我们直接快进到出发吧，中间我在为<a href="https://yuyuko.cc/">@kino</a>做一份礼物，但是还没做完就要出发了，为了保持神秘感就不发图片了XD</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201005_141400-副本.jpg" alt="" /></p><p>家人提前6小时把我通过高速送到昌北，然后快登机的时候肚子饿了 还被机场狠狠宰了一波。第一次坐飞机的体验还是挺好的（指在飞机上，上飞机前和下飞机后够呛）没有身体不适。<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201005_175757-副本.jpg" alt="" /></p><p>晚上的飞机总是让人没有实感，从窗外看到的是云海，但是这云仿佛就是一张2D贴图，没有立体可言。其余的时间就是让人无法呼吸的黑暗，我方才意识到人类居住的地方原来是这么小，我们的未来会是驱散这无边黑暗的璀璨光芒吗？</p><p>失去信号的手机，要想知道位置就只能靠着自身的陀螺仪，结合缺德地图，识别的位置还是非常准的，但是高度就离谱，最高处甚至有6000m<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201005_204141_1-副本.jpg" alt="" /></p><p>哦对了，虽然是去哈尔滨，但是我选择在上海转机，到上海的时候已经接近10点，但这时候<a href="https://yuyuko.cc/">@kino</a>还是从学校来了上海浦东机场，于是开始了两人愉快的夜晚(✿◡‿◡)（指在星巴克打电动）<img src="http://bubbleioa.top/wp-content/uploads/2020/10/4e999a2b5af9d98d-副本.jpg" alt="" /><img src="http://bubbleioa.top/wp-content/uploads/2020/10/20201018210407.png" alt="" /></p><p>在kino回去之后，繁忙的浦东机场瞬时寂寥无声，24小时营业的星巴克成为了无数旅人歇脚的地方。在星巴克等待的时间里，我碰到了一队母子，通过交谈知道，他们是明天早上的飞机，但是地铁没有那么早，于是来这里通宵候机。他们在玩短视频，但是相机方向怎么都不对，我帮他们重启了手机，解决了。凌晨，我在便利店随便吃了点夜宵，发现这里的消费甚至比昌北低。整个机场里到处都是疲惫的旅人，无论是坐着的，躺着的，还是像我一样乱逛的……</p><p><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201005_213213-副本.jpg" alt="" /></p><center>我待的星巴克，拍摄于kino来之前</center><p>那对母子也在躺着的人群中，不过他们躺在了机组职员通道。“这么晚应该不会有航班了吧，应该没事”我是这么想的。但是事实不是如此，大概在凌晨2点，一队洋人走了过来，我忽略了还有国际航班可能会在晚上有，领头的是一位穿着防护服的机场工作人员，他们果不其然遇到了这对母子，不过防护服并没有将他们叫醒，而是把通道的围栏（可移动）向外移动，领队绕过。在机场里休息的人们数不胜数，他们不是要饭的，也不是没钱，但是对机场的治安充满信心。我在这样的氛围里也有几次坦然地离开座位上厕所，行李仍然放在原位。\终于到第二趟飞机登机的时候了，不得不说上海还真的大，本来我以为主楼已经够大了，结果没想到登机的时候还要我去卫星楼，而且是机场专供地铁，在卫星楼里也是走得我脚疼。<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_045810-副本.jpg" alt="" /><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_060620-副本.jpg" alt="" /><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_061224-副本.jpg" alt="" /></p><p>然后就是飞行！这次是白天，而且是大海，于是我激动地！睡着了……没办法，睡叫一晚上没睡了<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_071057-副本.jpg" alt="" /><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_082701-副本.jpg" alt="" />中间醒了一次，吃飞机餐，还可以，不止照片里的，还有水和面包。<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_082854-副本.jpg" alt="" />第一次看到这么大的平原，这种一望无际的感觉很棒<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201006_101127-副本.jpg" alt="" /></p><p>在开学前还在哈尔滨玩了会，不得不说这里饮食消费占比高，恩格尔系数肯定不低吧，而且也不和我口味。（学校稍微便宜点，但是更难吃了，大概是高中没改食堂和改了食堂取个平均值）</p><p>还和在哈尔滨的学姐玩了一下午，从中央大街到老道外再到江北，真的是逛了个遍233<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201007_195636-副本.jpg" alt="" /></p><p>之后就是报道了，然后就上了一周的课，马上又到第二周了啊！可恶<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201009_103503-副本.jpg" alt="" /><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201009_150045-副本.jpg" alt="" /><img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201011_143723-副本.jpg" alt="" /></p><p>熟悉我的人都知道，我聊这么多现实的话题而且还配上实景图片简直不像我，我也这么觉得233，可能几次出去培训的时候有过这样的博文吧。所以现在就聊些网上的还有我个人的东西。</p><p>先是作品</p><p><strong>《信条》</strong>看完了诺兰的新作《信条》，打算写点什么来批判一番按照惯例欲扬先抑一波首先这个画面和音效没得说，十分顶尖，尤其是逆向和正向同时存在的场景，可以看得出来在开拍前做了大量的准备工作，无论是前期还是后期都是统筹一体一气呵成。但是这部电影给人的感觉很奇怪，我真的觉得是不是诺兰哪天突发奇想：“正放和倒放如果同时出现在一个画面里会不会很有趣？”然后他就立项拍这部电影了。怎么这么说呢？首先这是一部典型的“超级英雄”救人类的故事：超级英雄，反派，美人，队友牺牲，倒计时，天降援助………主角就差一个超能力就能进漫威宇宙了。这本来没什么错，但是放到这影片中就很奇怪。拉跨的正是本片的核心元素：科幻。就像之前诺兰的《盗梦空间》一样，本片给人的感觉就是，这是一部“硬科幻”，而不是传统超级英雄电影里面的“软科幻”。尤其是第一次看到逆向子弹的时候，我心中就已经确定它是一个“硬科幻”电影了。它“硬科幻”的第一个问题，就是解释不通。当然，就算是非常优秀的“硬科幻”作品，也会有别扭的地方，但是本片特别突出。比如说逆向转化只需要进一个离心机样的装置？未来人在哪？逆向转化转化时间就算了，咋出来的时候空间也变了？（指到了另一个房间）正向的火烧逆向的人会让人冻僵？那按道理来说正向的火温度不就要升高？然后温度升高导致逆向的人温度降低更快，岂不是套娃？类似的问题还有很多，但这还不是这部电影最主要问题 。它最主要的问题就是作为一部“硬科幻”，主题内涵太浅。随便举几个例子，《流浪地球》从头到尾都在努力淡化大义，而去强调人性。没有谁是真正意义上的英雄。这部影片里的每个人物，他们的每一步选择都不是为了大义，而是为了所爱之人。《火星救援》强调了科学主义、理性主义、乐观精神的重要性，还展现了人类的团结协作精神。而《信条》呢？可以说什么也没有，或者说和一般的超级英雄电影差不多，而且没有它们看得爽。就这点而言，已经足够让我对诺兰失望的了。</p><p><strong>《ATRI》</strong>今天把ATRI打通了，这才是真正的属于理科生的科幻浪漫啊！原先看种种作品留下的遗憾，都在这部作品中得到了补偿。看《信条》时，虽然很科幻，拯救全人类也很宏大，但是缺少人文关怀；看《天气之子》时，总想着拯救大家以及拯救自己喜欢的人全都要；看《刀剑神域》时，觉得将自己的意识同步在网上很酷，但是绝对不是用来NTR、恶心观众的幸福是什么？这个在无数作品里被讨论的问题，放在《ATRI》中，小小的机器人女孩回答是“幸福是未来”。然而这并不是一个很宏大的故事，至少在剧情的进展过程中，是以《知晓天空之蓝的人啊》中平淡的视角来展开。《知晓天空之蓝的人啊》中有一句话我特别喜欢：“井底之蛙，不知大海之宽广，却知晓天空之蓝”但是在《ATRI》的主角中，我却看到了遨游世界的青蛙，硬要说的话就是“知晓大海之宽广，却更爱天空之蓝”这种兼顾人文与科幻的视角，在西方作品中真的非常少见（也有可能是我阅历太浅），在这一个晚上的游戏流程中，我不断地反思自己的人格，去体会游戏中人物的心情，并且重新塑造我为人处世的方式。我随着人物，开始思考自己的理想，自己喜欢什么样的生活，想要成为一个怎样的人。正因有了人文关怀，《ATRI》才能做到这些。（还有就是因为我是“高性能”的嘛~）而它所给出的答案，就是属于咱专属的浪漫——在自己所爱的人，爱自己的人们的帮助下，去完成自己伟大理想的同时，好好守护住这一份小小的幸福（也许最后这两个分句可以稍微调换位置，不确定的原因是我现在还没有达成前两个分句的条件orz）这样的就很对我的电波。还有一点想说的就是关于剧情中的“离别”，有点《朝花夕誓》的味道了呢。所有的离别都是为了新的邂逅……还有再会那么 晚安Zzz…<img src="http://bubbleioa.top/wp-content/uploads/2020/10/atri.png" alt="" /></p><p><strong>《原神》</strong>好玩</p><p><strong>《革命曲途》</strong>演出棒，剧情拉跨</p><p><strong>《仰望半夜的月空》</strong>（正在看）<img src="http://bubbleioa.top/wp-content/uploads/2020/10/IMG_20201015_114701-副本.jpg" alt="" /></p><p>怎么说呢，上面的文字可以说道出了我现在的心声。没有进入计算机专业，其实这重要吗？我觉得不太重要，自己想学的东西还是能学。我现在迷茫的，是如何去抓住这个“未来”。想学Python/C/C++/Unity/Blender……但是呢，自己会的Ae、Pr也并不能做出些什么东西来，原先信誓旦旦地说想做PV/MAD结果打开Ae，啥灵感都没有，眼睁睁看着做MAD地一个个都结了婚😂真就做MAD喜路一条。</p><p>不过最近看了Warma的电台，熟悉了一周的校园，大概也知道自己之后该怎么办了吧，或者说，不该怎样。</p><p>从某种程度上来说，有这么多苦恼说不定是好事？咱这可能是青春的苦恼呢，爷青回！</p><p>再聊下本季度新番吧。</p><p><strong>No.1 《成神之日》</strong>麻枝准+P.A. Works YYDS最喜欢的笑点，最喜欢的OP/ED,舒适的画面，还有必将反转的剧情快进到打棒球</p><p><strong>No.2 《总之就是非常可爱》</strong>原作优秀，改编贫穷。《旋风管家》算是入宅作之一，作者玩梗能力贼强。我也不是不能理解先结婚再恋爱所带来的安全感+青涩感双重up的超级加成，简直是当代恋爱的最佳选择，当然这是理论上。且不论婚姻所带来的法律责任和社会压力（父母）是普通情侣难以接受的，再者还不一定能遇到对的人呢，有几个初恋走到白头的啊（希望我是其中之一😭）</p><p><strong>No.2 《魔女之旅》</strong>改编很棒，突出了女主的可爱。不过第三话这两个故事在原作中就很拉跨，一是没有对世界观进行详细阐释，二是没有对主角形象塑造有多大帮助，三是这两个故事寓意给人感觉知乎抖机灵样的，非常幼稚。</p><p>不过根据原作来看这样的篇幅不多，还是能期待后续的。</p><p><strong>No. 4《你与我最后的战场，亦或是世界起始的圣战》</strong>很尬就是了，我记得原作还不错的哇，算了就当吃个瓜吧。</p><p>点兔、樱与抱月还没看</p><p>另外在主页上还更新了python和日语的学习笔记，尽量每周4更，希望大家监督orz</p><p>那就到这吧，之后也会频繁更新的，总之我又回来了www</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>个人博客终于复活了！！！</title>
    <link href="/2020/07/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%88%E4%BA%8E%E5%A4%8D%E6%B4%BB%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <url>/2020/07/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%88%E4%BA%8E%E5%A4%8D%E6%B4%BB%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>高中生涯终于落幕，爷的青春终于也结束了，感谢大家一路以来的陪伴，新的阶段，新的启航。<br>接下来这个博客可能就不是OI博客了，不过原先写的拙劣题解也会保留，暑假期间估计就是记录一下自己每天做的事然后偶尔发点作品评价之类的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动画观察调色板#1 是什么使得《恋爱小行星》特别</title>
    <link href="/2020/03/28/%E5%8A%A8%E7%94%BB%E8%A7%82%E5%AF%9F%E8%B0%83%E8%89%B2%E6%9D%BF#1%20%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E5%BE%97%E3%80%8A%E6%81%8B%E7%88%B1%E5%B0%8F%E8%A1%8C%E6%98%9F%E3%80%8B%E7%89%B9%E5%88%AB/"/>
    <url>/2020/03/28/%E5%8A%A8%E7%94%BB%E8%A7%82%E5%AF%9F%E8%B0%83%E8%89%B2%E6%9D%BF#1%20%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E5%BE%97%E3%80%8A%E6%81%8B%E7%88%B1%E5%B0%8F%E8%A1%8C%E6%98%9F%E3%80%8B%E7%89%B9%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>系列介绍：<a href="https://bgm.tv/blog/295773">https://bgm.tv/blog/295773</a></p><p>B站专栏版：<a href="https://www.bilibili.com/read/cv5334057">https://www.bilibili.com/read/cv5334057</a></p><p>（发布时还在审核）</p><center><img src="https://s1.ax1x.com/2020/03/28/GABa4J.png"  alt="" /></center><p>轻松的氛围，只有可爱美少女的萌萌日常，我们一般会把这一类番剧归类为“轻百合”或者叫做“萌豚番”，而喜欢这一类作品的观众们肯定对“芳文社”这个公司不陌生，因为有大量的“萌豚番”的原作就是在芳文社出版的（具体来说是旗下的Manga Time Kirara月刊），本季度的《恋爱小行星》就是这样一部番剧。再加上动画制作是由制作过《天使降临到我身边》（一迅社）的动画工房来负责，可以说承载着观众们很高的期待。</p><p>可是随着《恋爱小行星》的完结，很多观众会有这样一种感觉——这不“芳文”，或者说《恋爱小行星》有一种特殊的感觉使得它与其他的轻百合番剧略有不同。</p><p>欢迎观看本期“动画观察调色板”，这期我们来探讨下，是什么使得《恋爱小行星》特别？</p><center><img src="https://s1.ax1x.com/2020/03/28/GAB03R.png"  alt="" /></center><p>要理解这个问题，首先要观察芳文社的其他几部有名的作品，例如《请问您今天要来点兔子吗》《黄金拼图》</p><blockquote><p>《请问您今天要来点兔子吗》：为了便于上高中，高中入学新生心爱准备搬来这由石板路、木制房组成的街道。她在寻找寄宿的地点时迷路了，迷茫之中来到了一家名为“rabbit house”的咖啡店门前。看到这间名字都充满小兔风格的可爱咖啡店，心爱忍不住踏进了店门。在店里，她遇见了娇小的少女智乃，以及一只软乎乎的可爱小兔子提比。</p></blockquote><p>心爱一边喝着咖啡一边询问路线时，才惊讶的得知这家咖啡店就是自己将要寄宿的地方。因为心爱将要入学的高中有着“学生要在寄宿的家里帮忙做事”的规定，心爱便开始当起了“rabbit house”的店员，并“自称”是智乃的姐姐，一边过起了咖啡店员的生活。</p><blockquote><p>《黄金拼图》：曾在英国寄住的忍，归国后开始了高中1年生的生活，然而某一天忍在英国的朋友爱丽丝竟然不远万里跑来日本了，说着“这次轮到我来日本了”的爱丽丝，将忍和同学绫与阳子，以及另一位英国少女九条卡莲卷入了日本和英国美少女之间的休闲百合日常。</p></blockquote><p>可以看得出来，无论是《点兔》还是《黄金拼图》它们都是围绕着角色展开的，而《恋爱小行星》则是将这份关系寄托在了梦想上，而且是共同的梦想，虽然本质上还是在描述角色之间的关系，但是从根本上给予了剧情的驱动力，而不是单纯的日常。</p><p>此外，“不安感”也是《恋爱小行星》区别于其他大多数轻百合的一点（当然只是比起轻百合番剧而言），苍的搬家离去（打算），梦露学姐和苍的落选，上一届的离去与新人的加入（看完京吹我都要得新人PTSD了），以及最终还是未能找到小行星的遗憾，剧情不是朝着最好的方向，未来不可预期，都是“不安感”的体现。</p><p>有明确目标的“方向感”和对未来无法预测的“不安感”是体现角色成长的最有力的工具，但是有些作品里面使用的就不是那么好。比如《辐射4》里面玩家玩了一会根本就想不起来自己是要去找儿子的，这是目标迷失。《Urara迷路帖》到现在还差8层才能找到妈妈，这是原地踏步。《New Game！》里面樱宁宁短时间内地边上大学边学会了C++做游戏，但因为缺少不安感难让人代入（即使这是可能的）。</p><center><img src="https://s1.ax1x.com/2020/03/28/GABBg1.png"  alt="" /><p>樱宁宁</p></center><p>（顺便一提，个人更喜欢《New Game！！》第二季，很多人诟病气氛压抑，但我觉得恰好适当地体现出了不安感）</p><p>还有使用过头的《宝石之国》，在南极石被带走，磷叶石获得了合金手臂变强之后，仿佛变了一个人格。这样确实能让观众深刻体会到“主角终于变强了”，我在此之前认为“主角自己不努力发挥作用提升自己，只会靠外界让自己变强”的念头也随之烟消云散。但是同时强烈的不安感反而让观众扎心，想寄刀片。</p><p>《恋爱小行星》在这一方便不说做得完美，但是也可以说比较合适。</p><center><img src="https://s1.ax1x.com/2020/03/28/GABwC9.png"  alt="" /></center><p>虽然说这种萌系作品很少有类似作品，但是《摇曳露营》的氛围渲染绝对是一种不错的方法。《摇曳露营》做到了一点就是将观众带入到露营当中去，虽然大家都是高中生，但是很多时候观众们不会太在意甚至是忘了，而专注与露营这一件事上，看到主人公们在学校的时候巴不得让她们赶紧出去露营。</p><p>即使题材不一样，《恋爱小行星》在这一点上也同样去刻画了，比如去JAXA参观，去进行观星活动，还有地学竞赛和闪亮星挑战，甚至在日本地学竞赛官网都有联动，参加初赛的选手还可以领取免费的文件袋周边，甚至还有导航语音联动。</p><center><img src="http://bubbleioa.top/wp-content/uploads/2020/08/4c5198cdb6b66e744160aa6074a3209c3429d1a0.png"  alt="" /><p>日本地学官网</p></center><center><img src="http://bubbleioa.top/wp-content/uploads/2020/08/6f7dcd522b7be1c901f4628ec217c4a07d760069.png"  alt="" /><p>初赛领取文件袋</p><img src="http://bubbleioa.top/wp-content/uploads/2020/08/3136c09df791a3808a83a23842d07768585ea68d.png"  alt="" /><p>导航语音联动，高德GKD</p></center><p>在打造沉浸感的同时，去描绘周围人的梦想也是很重要的，如果过于着墨在主角身上会破坏平衡感。在该作品中，米拉和苍追寻小行星，小猪痴迷于地图，梦露前辈想成为宇航员，樱前辈:对于我来说，还没找到具体的目标，所以梦露前辈给了她鼓励。</p><p>苍从离开家人与米拉同居，甚至后面自己独自前往石垣岛，这看似十分莽撞的举动，恰恰是角色成长的证明。</p><p>而本作的OP于ED方面也没有采用之前轻百合番剧常用的活泼欢快的风格，而是由东山奈央演唱OP和铃木实里演唱ED，声音中透露着一份温柔，十分具有抒情感。</p><p>用一张图就能很好概括米拉和苍现在所在做的事：</p><center><img src="https://s1.ax1x.com/2020/03/22/85OjEt.jpg"  alt="" /><p>PID：78733767</p></center><p>《恋爱小行星》有很多内容属于专业知识，动画组没有选择将其插入进本篇当中，而是选择做成SP的形式放在每一集最后，对于很难接触到丰富多彩高中生活的中国高中生来说做些介绍还是很有必要的，但是B站番剧并没有把它加在每集的末尾，这对观感还是有不小的影响的。</p><p><a href="https://www.bilibili.com/video/BV1r7411Q7vS">https://www.bilibili.com/video/BV1r7411Q7vS</a></p><p>现在这种轻百合番剧开始慢慢地走向了类似的方向，以清晰的目标为引导加上对未来的不明确带来的不安感来展现剧情和主人公的成长，这很可能是轻百合作品内容同质化所带来的战略性转移。但是像是《摇曳露营》《恋爱小行星》《街角魔族》等新型的轻百合番剧确实给我们带来耳目一新的感觉（街角魔族创新的方向稍有不同），而喜欢传统轻百合的观众还有《点兔》第三季，《黄金拼图》剧场版，《天使降临到我身边》等都可以满足需求，这两者都喜欢的观众可能成为最大赢家。</p><p>感谢收看这期的动画观察调色板，虽然由于时间和经验关系先挑了一个简单的选题来讲，但还是感觉自己有很多不足之处，如有不足之处欢迎在下方评论留言。同时如果你在看《恋爱小行星》或者其他轻百合作品有什么心得的话也欢迎在下方分享。</p><p>下一期估计至少要等到90天以后了，现在我有几个选题：</p><p>扳机社风格的形成不止归功于作画</p><p>什么是优秀的人设</p><p>《天使降临到我身边》中的日向为什么熊但是不招人讨厌？</p><p>另外，从第二期开始我打算把这个系列做成视频（其实本来就是想做成视频的但是由于现在手头工具不够），欢迎大家观看。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【动画观察调色板#0】系列介绍</title>
    <link href="/2020/03/27/%E3%80%90%E5%8A%A8%E7%94%BB%E8%A7%82%E5%AF%9F%E8%B0%83%E8%89%B2%E6%9D%BF#0%E3%80%91%E7%B3%BB%E5%88%97%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/03/27/%E3%80%90%E5%8A%A8%E7%94%BB%E8%A7%82%E5%AF%9F%E8%B0%83%E8%89%B2%E6%9D%BF#0%E3%80%91%E7%B3%BB%E5%88%97%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<center><img src="https://i.loli.net/2020/03/27/cSFuD6QxJoadYAj.png"  alt="" /></center><p>在我的硬盘里现在还躺着我一开始写的关于动画、漫画甚至是小说的评价。作为一个“理科生”，一上来当然是想以理性客观的角度分析作品的，但是显然我早期的评价达不到“客观理性”这一标准。</p><p>于是我开始发现，对我来说最重要的是看完一部作品后的感受，我开始搁置“客观理性”的要求，转而真诚地阐释自己的第一感受。久而久之，不可避免地出现了一个问题——为什么我会有这样的感受？</p><p>一种能够融合“感受”与“理性”的新的评价方式在我的脑海里初具框架，但是如同星云一般不知如何聚拢。</p><p>彼时的我发现了一个系列的节目，叫做《游戏制作工具箱》，其视频特点就是分析这个游戏为什么要这样做，比如有一期是讲“《蔚蓝》的手感为何如此迷人”。同时，作者还把自己制作该节目的心得分享到了<a href="https://www.bilibili.com/read/cv516452">这篇文章</a>中，看完之后对我大有裨益。</p><p>概括地来说，我们每个人看完一个优秀的作品的时候都会有种特殊的感觉，甚至可以把“优秀”这个限定去掉，每个作品都有自己的独到之处。而通过追问“为什么”可以引出对该作品或者某一类作品/元素的理性思考，将这一结果表达给读者就是本系列的核心目的。</p><p>我未必能从一开始就做得好，但是我会尽量努力使得内容更加完善。由于该系列出发点是寻找积极的元素，所以批评的内容占比很少，而且在说道这部作品怎么样的时候会提到另一部作品又是怎么样，但绝非抹黑这两部作品，只是做一个客观的对比而已。</p><p>（第一期咕咕中，logo中隐藏着预告）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>然后，下一曲开始了！</title>
    <link href="/2020/03/16/%E7%84%B6%E5%90%8E%EF%BC%8C%E4%B8%8B%E4%B8%80%E6%9B%B2%E5%BC%80%E5%A7%8B%E4%BA%86%EF%BC%81/"/>
    <url>/2020/03/16/%E7%84%B6%E5%90%8E%EF%BC%8C%E4%B8%8B%E4%B8%80%E6%9B%B2%E5%BC%80%E5%A7%8B%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<center><font size=4><b>然后，下一曲开始了！</b></font><p>《 吹响！悠风号》观后感（仅动画）</p><p><font color="red">⚠剧透警告⚠</font></p></center><h2 id="Part-1-观看背景"><a href="#Part-1-观看背景" class="headerlink" title="Part.1 观看背景"></a>Part.1 观看背景</h2><p>还依稀记得第一季连载的时候，感叹着“这个世界上还有制作如此精良的动画”的我的样貌。但后来不知道什么原因，阴差阳错地没有继续看下去。</p><p>后来在完全懵逼的情况下在高铁上看完了《莉兹与青鸟》，真的除了感叹制作精良之外就没有什么想法了。</p><p>然而当我时隔多年重新观看的时候，我突然意识到，下一曲开始了！</p><h2 id="Part-2-剧情梗概"><a href="#Part-2-剧情梗概" class="headerlink" title="Part.2 剧情梗概"></a>Part.2 剧情梗概</h2><p>如同该作名称一样，故事主要讲述了北宇治高中吹奏部参加全国大赛的故事，而我们的主角黄前久美子在社团中担当的就是上低音号演奏者。</p><blockquote><p>北宇治高中吹奏部直到5年前还是关西大会的常客，并且过去还是全国大会出场过的强校代表，然而自从顾问换了之后，该吹奏部就再也没有挺进过关西大会。之后以新顾问的赴任为契机，怀揣着高远目标的部员们挥洒着奋斗的青春，过着波澜万丈的每一天。终于，比赛的日子也即将到来……</p></blockquote><p>如同很多为高中生举办的比赛一样，日本的中学生吹奏大赛也是一年举行一次，要参加全国赛，必须在地区赛中取得名额（剧中是关西大赛），要想参加地区赛，必须在府赛中取得名额（剧中为京都府），在此之前，还有本地举办的Sunrise Festival的活动。</p><center><img src="https://s1.ax1x.com/2020/03/16/8YNqdP.png"  alt="" /></center><p>但是作为一个55人参加的团体比赛，团队内部的和谐和凝聚力也是十分重要的，团队内部的矛盾不可能没有，而我们的主角久美子，随着时间的推移，也从一个旁观者变成了勇于冲进漩涡中心的调解员。而每一次解开部员之间的矛盾，都使得这个团队更加团结……</p><h2 id="Part-3-主题与人物"><a href="#Part-3-主题与人物" class="headerlink" title="Part.3 主题与人物"></a>Part.3 主题与人物</h2><blockquote><p>京吹1期很有青春的感觉，因为它唤醒了6、7年前的一些乐团的记忆。下面把京吹的一些情节和我当年的经历对比一下，简直神还原。京阿尼的片很多表面上是日常，实际上带有很浓郁青春的味道，比如轻音、比如冰菓，比如京吹。如果说京吹1给普通观众的“青春感”是10分，那么对于混过乐团的人来说就是20分。因为它总是有意无意地还原一些细节。<br>——引用自<a href="https://bgm.tv/blog/289327">锐ちゃん的日志</a></p></blockquote><p>说到青春，其实这是一个很大的范围，我甚至觉得它囊括了该作所有主题：奋斗、团结、友情、爱情、成长……</p><p>有一部我很喜欢的漫画，主题也是青春的《星野，闭上眼》，其中汉化组组长的一段话让我印象深刻</p><blockquote><p>不知从哪里听说过，青春总是残酷的。<br>…………<br>但是青春不就是这个样子的吗？<br>路还长，我们还年轻。<br>青春永远在途中，无需完美的句号。<br>——暗夜黑猫</p></blockquote><p>（我省略了很多，原文很长但是真的非常有文采！佩服！）</p><center><img src="https://s1.ax1x.com/2020/03/16/8YwmQg.png"  alt="" /></center><p>但是“京吹”的青春很不同，或者说，表现方式很不同。上面所提到的《星野，闭上眼》以及很多其他“青春”题材的作品，都很戏剧性，人物的行为动机都很随机，是一种常用的“商业手段”。而“京吹”如同锐ちゃん所说，是一种“日常的青春”，戏剧性拉到最低以至于有人会做出“主线过于平淡”的评价。</p><p>我们总是站在上帝视角，来评判一个人的行动，来赞颂某部作品里所谓的“青春”。但是真正的青春难道更多的不是心灵上的感受吗？而京都动画将这些细腻的情感跃然于画面之上，“细腻的情感流露”也是该作能变现出“真实感”的原因之一。</p><center>我一直认为，青春总是充满挫折的久美子避开初中同学，选择北宇治高中丽奈暗恋泷升老师，但却无法得到回应明日香面对家长压力，被迫放弃社团活动香织拥有强劲实力，因制度无缘独奏夏纪经历退部风波，练习逐渐浑水摸鱼麻美子放弃自我所好，等到大学后悔无比美玲不善表达情感，入部之后自我孤立<p>很多人看番喜欢带入角色<br>我们都以为自己是久美子，其实我们只是我们自己<br>没有久美子的真挚宽容<br>没有丽奈的争强好胜<br>没有明日香的圆滑大方<br>没有香织的人缘宽广<br>没有夏纪的不耻下问<br>没有麻美子的自我醒悟<br>没有美玲的过硬技术<br>我们经常憧憬着优秀的人，但只和自己相当的人交流<br>在网络上数落他人甚至是虚构人物的言行，但自己完全做不到<br>想要变得优秀，但又怕努力了没有成果<br>默默搞着自己的兴趣，却不被别人认可<br>身边的朋友总是像在往前走，自己总感觉在原地踏步<br>每天活在焦虑之中，通过沙雕视频慰藉心灵<br>哈哈一笑之后，又陷入自我责备的循环<br>被消费主义冲昏了头脑，买来一时的快感</p><p>即便是青春中最甜蜜的爱情<br>大多数也无法修成正果</p><p>不知从哪里听说<br>青春是场垃圾游戏<br>是给那些已经赢在起跑线上的人的狂欢<br>而我们如同大多数人一样<br>在名为青春的漩涡里抱头鼠窜，找不到方向</p><p>难道我们所讴歌的青春<br>真的是场垃圾游戏？真的是给胜利者的狂欢？</p><p>新月之舞缓缓落幕，春的脚步处处生息<br>人们之所以将年少冠以青春之名，<br>正是因为青春是成长的时期</p><p>久美子帮助社团解决矛盾<br>丽奈向老师射出爱之箭矢<br>明日香取得成绩参加大赛<br>香织面对机会主动让位<br>夏纪受到感染努力练习<br>麻美子不顾反对坚持理想<br>美玲走出封闭敞开心扉</p><p>尽管第一次只拿到了铜奖<br>就算第二次连全国大赛也没能参加<br>但这些重要吗？</p><p>不是每个努力都必须要有结果，<br>过程和感悟或许更加珍贵<br>不是每个问题都必须要有答案，<br>苦恼和思索有时更加重要</p><p>我们每个人都把青春想的太功利化<br>得到什么，失去什么的心情挥之不去<br>可青春正是最不用考虑得失的时候<br>无所顾虑地向前无视前方的艰难险阻</p><p>“京吹”也是如此<br>吹奏比赛没能拿到理想的成绩<br>丽奈也没法得到老师的回应<br>秀一与久美子还没能在一起</p><p>但是这就是青春，<br>无需完美的结局，<br>去将当下所有美好的事物谱写，<br>形成绝妙的乐章，<br>这，正是青春的特权</p></center><h2 id="Part-4-吐槽"><a href="#Part-4-吐槽" class="headerlink" title="Part.4 吐槽"></a>Part.4 吐槽</h2><p>先说一句：我忍你们这些在“京吹”底下用政治口气讲话的人很久了！！</p><p>啊，写起来真的是没完没了，真的好想把自己的感情原封不动地搬到文章里啊！<br>高中虽然没有参加过团体竞赛，但好歹也参加过团体和竞赛XD</p><p>团体是指团委，竞赛是指奥赛，关于奥赛还有一篇黑历史在我的第一篇日志里，当时真的有点气愤吧，有点像希美当时退部的时候的感情？但看来我还是坚持了下来呢。</p><p>我在团委里也算是一个夏纪一样的人物吧，就是提不起劲的那种，有什么任务安排到我头上了我才会做的那种（真的很抱歉QAQ）<br>不过和剧中有所不同，我们这一届团委应该是由于做的很好我才能这么悠闲？<br>但是到了下一届招新的时候真的是惨不忍睹233，下一届他们自己内部的问题很大，还有几个“久石奏”和“美玲”在里面，真的非~常难处理<br>但是由于团委只同时有两届工作，加起来大概25人左右，所以冲突也不是那么明显（当然想解决也因为时间有限也很难）</p><p>要说到团体里的冲突的话感觉问题最大的就是我现在所在的班级吧，虽然快毕业了但是回想起来我还是有很大一部分责任的。当时当班长却有一段时间为了奥赛停课而导致的班上氛围变化。作为一个团队的Leader我其实很憧憬久美子，十分欣赏她的性格。</p><p>我认为只有京都动画能够做到这么忠实于日常的同时做到如此丰实的内容，虽然连着看不免陷入一种单元剧推动主线的感觉，但是比起其他作品来说这种感觉要好很多。</p><p>另一条线就是久美子和秀一的爱情线，据说原作小说得了一个什么恋爱小说奖？这是真的吗我怎么一点也看不出来？虽然还是很甜就是了，尤其是久美子把礼物还回去的时候，有些人可能觉得“惨 秀一 惨”，但我反而觉得是那种“老夫老妻”的安心感，像是已经约定好了的夫妻。能为了自己的理想而暂时放下爱情的两人，不可谓不成熟。原来之前青涩的感觉都是假的， 都已经发展到这一步了吗www</p><p>还有配音要好好夸夸，这种感觉，我记得上次还是在古力特里面感受到过，这种不加修饰的纯正的声音，为这部番增色不少。</p><p>虽然感觉说这么点有点不够的样子，心中还有很多想要诉说的东西。<br>但是写了这么多，我发现我也要好好努力了呢，在这所剩不多的青春里。<br>期待第三季！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我们所经历的每个平凡的日常，也许就是连续发生的奇迹。</title>
    <link href="/2020/03/07/%E6%88%91%E4%BB%AC%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%B9%B3%E5%87%A1%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%8C%E4%B9%9F%E8%AE%B8%E5%B0%B1%E6%98%AF%E8%BF%9E%E7%BB%AD%E5%8F%91%E7%94%9F%E7%9A%84%E5%A5%87%E8%BF%B9%E3%80%82/"/>
    <url>/2020/03/07/%E6%88%91%E4%BB%AC%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%B9%B3%E5%87%A1%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%8C%E4%B9%9F%E8%AE%B8%E5%B0%B1%E6%98%AF%E8%BF%9E%E7%BB%AD%E5%8F%91%E7%94%9F%E7%9A%84%E5%A5%87%E8%BF%B9%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>一个2011年的搞笑动画，我2020年看有必要吗？有必要吗？<br>…………<br>真香！</p><p>《日常》这部作品影响力之大，直到今天都经常能看到它的身影，我QQ好友里还有人用它里面人物的头像，每次看伊朗物理作死专家B站更新，都能看到那美绪奔跑的动图。</p><p>还有之后的男高女高，都一定程度上致敬了《日常》，和女高的主角团座位一致，人设类似。</p><center><img src="https://s2.ax1x.com/2020/03/07/3XhKTe.png"  alt="" />《女高中生的虚度日常》<img src="https://s2.ax1x.com/2020/03/07/3XhuwD.png"  alt="" />《日常》</center>但其实看前几集的时候，没有对上电波，心中唯一的想法就是：“这哪是《日常》？这明明是《今日一点也不正常》吧！”有这个想法再正常不过了，维基上给《日常》的一个tag是“后现代搞笑”> 后现代主义（英语：Postmodernism），是一个从理论上难以精准下定论的一种概念，因为后现代主要理论家，均反对以各种约定俗成的形式，来界定或者规范其主义。<p>而前几集就是打破我心中约定俗成的规则，等到我接受了新的规则，我就已经和剧中的人物一样放飞自我了！</p><p>从《日常》到《龙女仆》，京都动画描绘这种日常氛围的功底可见一斑。<br>在相对“粗犷”的画风下做到了精细，对每一个细节的一丝不苟，这些工作虽然不是画面主题，但是能够提供给观众一个非常舒适的观感，在缺乏跌宕起伏的剧情和燃破天际的打斗下，良好的观感才能够维持观众的兴趣，而这一点，《日常》做到了，不是以2011年的眼光来看，而是从2020年的眼光。</p><p>原作的优秀是这部作品搞笑的核心，纸牌游戏部分可谓一绝，评论区里面也有大神分析了大家可以去看。此外，激烈的矛盾冲突和解决冲突的过程中产生的摩擦也是搞笑的来源。而这些矛盾往往来源于日常，解决过程十分荒诞，最后又归于日常。日常-&gt;日常是经历（我们所经历的每个平凡的日常），而解决过程的荒诞其实是奇迹（也许就是连续发生的奇迹）个人解读<br>例如美绪看到美里与幸治郎在一起后（25话）：</p><center><img src="https://s2.ax1x.com/2020/03/07/3XHfrn.png"  alt="" />发现美里与幸治郎在一起，美绪狂奔，这里祐子必须跟着她，来突出荒诞的主体<img src="https://s2.ax1x.com/2020/03/07/3XHs58.png"  alt="" />美绪破窗而逃<img src="https://s2.ax1x.com/2020/03/07/3XHrUf.png"  alt="" />美绪在操场上狂奔<img src="https://s2.ax1x.com/2020/03/07/3XHDVP.png"  alt="" />美绪单杠，这里之前有铺垫<img src="https://s2.ax1x.com/2020/03/07/3XHwDI.png"  alt="" />美绪打拳<img src="https://s2.ax1x.com/2020/03/07/3XbaJU.png"  alt="" />中之条父亲头发<img src="https://s2.ax1x.com/2020/03/07/3XH0bt.png"  alt="" />背老奶奶<p><img src="https://s2.ax1x.com/2020/03/07/3XHdKA.png"  alt="" /><br>铁轨上奔跑</p><p><img src="https://s2.ax1x.com/2020/03/07/3XHYCD.png"  alt="" /><br>夹缝中生存<br>此处省略多个场景（都是荒诞的）<br><img src="https://s2.ax1x.com/2020/03/07/3XbdWF.png"  alt="" /><br>美绪救人，矛盾缓和</p></center>> 我们所经历的每个平凡的日常，也许就是连续发生的奇迹。<p>人类是健忘的，但互联网有记忆，最近翻了翻之前的邮件、说说、博客之类的保留记忆的内容，现在看来当时也是十分搞笑（都是黑历史），大家也可以翻翻自己的黑历史，说不定会对这句话有更深的理解？？当然认真观察生活也是必要的！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Wuppo——可爱而又不失可玩性的冒险游戏</title>
    <link href="/2020/03/07/Wuppo%E2%80%94%E2%80%94%E5%8F%AF%E7%88%B1%E8%80%8C%E5%8F%88%E4%B8%8D%E5%A4%B1%E5%8F%AF%E7%8E%A9%E6%80%A7%E7%9A%84%E5%86%92%E9%99%A9%E6%B8%B8%E6%88%8F/"/>
    <url>/2020/03/07/Wuppo%E2%80%94%E2%80%94%E5%8F%AF%E7%88%B1%E8%80%8C%E5%8F%88%E4%B8%8D%E5%A4%B1%E5%8F%AF%E7%8E%A9%E6%80%A7%E7%9A%84%E5%86%92%E9%99%A9%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>一周目通关，游戏时长6小时。有剧透，谨慎观看。</p><p>最开始我是被Wuppo的宣传片的BGM和5元的价格吸引的，结果到游戏最后都没有出现那个BGM，但是其优秀的音乐和美术风格绝对与宣传片相匹。音乐风格建议参考宣传片，美术风格可以通过下面的图片了解。</p><center><img src="https://s2.ax1x.com/2020/03/07/3X33xf.png"  alt="波波城中心雕像" /></center>故事讲述了在一个奇幻的世界，本来主要有4大种族在此居住生活，其中最弱小的乌姆，却靠着最聪明的大脑“征服“了这个世界。（长相如上图，一个团子加四条腿www）<center><img src="https://s2.ax1x.com/2020/03/07/3XY07F.jpg"  alt="团子大家族" /><img src="https://s2.ax1x.com/2020/03/07/3XDxEt.jpg"  alt="四大种族" /></center>而我们的主角，本来是一只因为吞了电视机而非常大的平平无奇的乌姆（后来吐掉了），在名为乌姆之家的地方安逸地生活着，直到他吃冰淇淋把乌姆之家搞得脏兮兮之后，被管理员强制逐出。<center><img src="https://s2.ax1x.com/2020/03/07/3XYw0U.jpg"  alt="宅宅乌姆" /></center>于是我们的小乌姆就开始了属于他的冒险，到过生机勃勃的花园，去过大城市给黑心老板当杂工，在有限的时间内发报纸，参与城市议会的讨论，帮助囚犯从牢中逃脱……甚至去过里世界，还拯救了世界。<center><img src="https://s2.ax1x.com/2020/03/07/3X0ORe.jpg"  alt="乌姆之家地图" /></center>游戏以探索为主，有深度和难度的探索内容，让这个游戏的道具收集变得极富挑战性。而在探索的过程中，你会遇见许多性格各异的乌姆，并且在与他们的聊天中获得来自他们的认可；也会来到其他乌姆去不到的地方收集四处散落的幻灯片，在播放它们的时候听幻灯片的讲解者们述说关于世界和种族的故事。内容很多很丰富，我6个小时的体验几乎上连游戏的70%的探索内容都没达到，随着游戏的进行，你会发现管理员对你离开的不舍，在解决完乌姆之家厨房的麻烦之后，你会听到厨师们说，它们这样做是想给一个乌姆巨大冰淇淋，这样它就不会经常下来拿搞得到处都是了。<p>值得一提的是Wuppo中角色对话十分多，选项也多，你通过对话来了解这个世界。同时，提升血量这个为数不多的能增强主角的途径也需要通过对话达成，使别人感到幸福，才能获得幸福度，从而提升血量。</p><p>而游戏的重要环节则是BOSS战。BOSS战也是该游戏创新、好玩之处。</p><p>游戏中的BOSS共有19个，除一部分BOSS是剧情需要一定会战斗的外，其余的BOSS则都可以通过不同的方式避免战斗。</p><p>如果不在海底制造声音，第一个BOSS绿色的鱼就不会出来攻击你；</p><p>如果不杀狮子王的子民，狮子王就不会作为BOSS出现；</p><p>如果不在信号灯下不停切换道具，信号灯就不会选择与你战斗……</p><p>在我看来，这种设定带来的，是这些BOSS在凶狠的外表下，一颗人性化的心。你会与很多BOSS有互动，比如狮子王会帮你打下一个BOSS（也许是我们在帮他？），打完深海BOSS我们还要把它带到主人那完成阔别已久的重逢。<br>每个BOSS都十分有特色，比如信号灯：</p><center><img src="https://s2.ax1x.com/2020/03/07/3X1IbQ.png"  alt="" /></center>要是在红灯的情况下你动了，它会狠狠揍你，在此情况下，你甚至近身都做不到，子弹也会被格挡，只有到绿灯时，你走到它附近，它会换边，途中会平地摔一会，这时候就是你出手的时候啦！<p>Wuppo还有一点做的非常棒的就是陪伴感，在游戏过程中你总共会碰到4个伙伴，很多个可对话的NPC，还有无数的平凡的NPC，这些NPC会到处跑，会购物，会使用东西，会通勤，会住旅馆……而且这个世界的两个交通工具也是严格按照时刻表来运行的，你要搭乘？必须等！</p><center><img src="https://s2.ax1x.com/2020/03/07/3XdRoT.jpg"  alt="交通工具之一——有轨电车" /></center>此外，该游戏的解密做的也相当可以。解密的关键点在于与场景的交互，最普通的交互方式就是移动，我们的主角能二段跳，然后就是胶胶枪攻击刺球来破坏场景，之后还能获得水桶，波波帽（夹子），音乐盒……<p>其中最神的就是波波帽，它不是过程中给你的，而是之前那个可选任务，帮助囚犯逃脱的时候需要购买的道具，同时也交给你使用方法，然后在之后的解密中大展身手。</p><center><img src="https://s2.ax1x.com/2020/03/07/3X0vMd.png"  alt="贩卖波波帽的波波城（中心）地图" /></center>此外，在该游戏的最新版本中，加入了本地双人模式，一个人控制主角，一个人控制伙伴，但是该版本的汉化不完全，英语苦手者建议先玩老版本。<center><img src="https://s2.ax1x.com/2020/03/07/3XspZR.jpg"  alt="合作模式" /></center>难度方面很友好，给了4个难度，我选的普通，感觉打起来没什么技巧可言。最困难的基本上挨3次BOSS攻击就会死。<p>但是，只有12%的用户通过了一周目说明了一个很严重的问题——缺乏核心游戏性。该作几乎所有战斗都发生在BOSS战，作为一款steam上的“角色扮演”游戏，bgm上写的ARPG游戏，它并没有RPG该有的角色属性或是战斗能力成长。血上限的增加十分稀缺，我一周目开始100血，结束110血。能升级的装备只有武器，而且升级代价低，效益高，并且是没有梯度的（要么升了，要么没升），我一把基础武器花点钱升级后，DPS翻了3~4倍。其他能保证打架的，就只有屯恢复药品。所以说，比起把它归类到RPG，我更倾向把它和PIKUNIKU类比（一款AVG游戏），那些RPG玩家，期待主角成长的玩家可能要失望了。</p><p>总结：Wuppo是一个拥有完整世界观的可爱风格的冒险类游戏，其独特的美术风格和出彩的音乐（甚至有OST的DLC）使得它在同类型游戏中脱颖而出。它同时描绘了一个生机勃勃而且充满温暖的世界，一个个细节会使你感到无比“暖心”。但缺乏主线的剧情和几乎不成长的主角使得它作为一个角色扮演游戏缺乏核心游戏性。新加入的多人合作模式能在与伙伴一起游玩的同时，体验完整的游戏世界。（有些游戏的多人合作是新的独立关卡，比如上面那款）非常适合与喜欢这类游戏的女朋友一起游玩。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>追逐着梦想，将未来交汇</title>
    <link href="/2020/03/02/%E8%BF%BD%E9%80%90%E7%9D%80%E6%A2%A6%E6%83%B3%EF%BC%8C%E5%B0%86%E6%9C%AA%E6%9D%A5%E4%BA%A4%E6%B1%87/"/>
    <url>/2020/03/02/%E8%BF%BD%E9%80%90%E7%9D%80%E6%A2%A6%E6%83%B3%EF%BC%8C%E5%B0%86%E6%9C%AA%E6%9D%A5%E4%BA%A4%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<center>追逐着梦想，将未来交汇<p><b>An Uplifting Story</b></p><p><font color="red">剧透警告⚠</font></p></center><p>先来说说自己的感想，然后再来吐槽和批评。<br>团结、励志、爱情……这些使这部漫画的主题。我在看这部漫画之前对于akb48一点了解都没有（虽然看后也没有了解），但其实并不妨碍作品本身的发挥，这里你可以清楚地感觉到主角们经历的成长和蜕变。<br>浦川实乃梨（浦山实）从一开始的只是想让宽子成为center到后来自己发现做偶像十分有趣，与宽子正面交锋。</p><p>吉永宽子从一开始内向胆小，到进入AKB后的站在小实的背后，再到后来想要靠自己的力量成为center。从一开始因为家庭压力想要退出到后来坚定自己的梦想。<br>冈部爱有着过人实力，但被复仇阴霾笼罩，最终也解开了对母亲的心结。<br>有栖莉空年小失聪，但重燃偶像梦想，焕发活力。<br>我们很多人喜欢把自己带入男主的视角思考，但实际上我们只是奥平老师。<br>但是，正是有了奥平老师一样的“旁观者”才促成了主角的成长。<br>奥平老师用自己的薪水，免费派发门票<br>樱小姐从AKB初期一直工作，保障舞台万无一失</p><p>瑶佳小姐在”GEKOKU嬢”出道初期提供活动支持，之后担任了NUMBER8的制作人<br>这一点在最后一话作者用方格框告诉了我们：</p><blockquote><p>﻿这之后AKB会变成什么样……谁都不知道，可能会变成超级巨星，亦或是数年后就解散了也说不定——但是一定没问题！只要有着比谁都热爱“偶像”这个职业的少女和最喜欢那位偶像的饭存在的话。</p></blockquote><p>副标题我一开始写的是“An Uplifting Story about Idol”，但其实这并不仅仅是偶像的逐梦故事，也是这一个偶像圈里面所有人的奋斗故事。<br>我很喜欢这部作品里面塑造的许多角色，他们都有自己的梦想去追寻，都有自己为了他人的执念。<br>这部作品角色们很多时候是被利他的行为驱动的，这一点的结果就是将自己的未来与他人的未来交汇，让自己与他人一同前行。<br>这其实是很令人羡慕的，有人说，”(男主)就像做了一场4年的黄粱梦，收获了什么只有男主自己知道。”<br>在结尾主角确实失去了浦川实乃梨的身份，但是宽子已经成为center，而且他所构建的，与AKB48其他成员交汇的未来并没有因为男生身份暴露这件事情而被破坏。<br>他所得到的，就是连同众人一起成长的未来。</p><p>浦山实对宽子到底喜欢到何种程度以至于能够付出4年时间，默默支持她的梦想？我认为这份感情是在这4年间不断加深的，在一起训练、成为偶像的路上愈发地喜欢上宽子的。<br>而宽子没想到的是，作为同学喜欢的浦山实，作为闺蜜喜欢的浦川实乃梨，以及作为恋人喜欢的“黑神”，居然是同一个人。<br>这是什么神仙爱情，直接去民政局把结婚证领了吧，结尾作者也是老狡猾了，不直接发糖而是藏起来了：</p><blockquote><p>﻿主持人：AKB48 Happy Mart电视台！！主题是“最近发生的开心的事”……怎么样 宽子？<br>宽子：说起来，我家里有个洗衣机……那个洗衣机在耳边，发出很吵的声音，有时候会吵得睡不着——但是最近洗衣机非常地安静，它的颜色很可爱所以很开心，感觉看起来是红色和茶色的混合色啊……</p></blockquote><p>然后这是这一话的封面：</p><center><img src="https://s2.ax1x.com/2020/03/02/3RhBhn.png"  alt="" /></center><p>虽然我觉得要是表现地更露骨一点会比较好呢www</p><p>260多话的作品我三言两语也说不完，所以大家还是自己去看看吧，下面我就开始瞎吐槽和批评了。</p><blockquote><p>看完前感想：<br>在DMZJ上一直处在显眼的地位，但是一直没有点进去看，昨天看了宮島礼吏一天工作生活的跟拍，加上对《租借女友》画工的印象很深，就看了。不得不感叹这几年宮島礼吏的画工进步真的很大，看第一话的时候完全不相信是《租借女友》的作者画的，200+话的时候就很精美了。</p></blockquote><p>确实，这部作品在画工上的成长是肉眼可见的，也为《租借女友》的爆火埋下了伏笔，而且作为一部热血漫，演出效果也是一级棒，比如总选举的地方：</p><center><img src="https://s2.ax1x.com/2020/03/02/3R0ORH.png"  alt="" /></center><center><img src="https://s2.ax1x.com/2020/03/02/3R0LJe.png"  alt="" /></center>但是在看完同类型题材《偶像之王》后就没有那么震撼了，那部作品的表现力是真的强。主角虽然是伪娘但作者没有特意地画的比真女生可爱（这已经成为趋势了233）但是怎么都不暴露的设定还有对于某些人一下就暴露的设定都很戏剧性。<center><img src="https://s2.ax1x.com/2020/03/02/3R0Eb6.png"  alt="" /></center>说实话，我看完了还认不全<center><img src="https://s2.ax1x.com/2020/03/02/3R0kK1.png"  alt="" /></center>当偶像不如高考（<center><img src="https://s2.ax1x.com/2020/03/02/3R0ADx.png"  alt="" /></center>你才是男的！<center><img src="https://s2.ax1x.com/2020/03/02/3R0ZVK.png"  alt="" /></center>说实话，突然虐莉空真的受不了，这样子导致莉空如果最后没有和主角在一起的话真的很背德，虽然没有人道德绑架我但是真的就感觉自己把自己绑架了，非常难受。这种胃疼感不是来自于谁又绿了谁，而是来自于恋爱情感之上的重压，这一点在作者新作《租借女友》中体现更为强烈。<p>而且说实话，我觉得这部作品很多地方都是在凑连载话数，有很多重复部分，剧情模板化套路化。<br>具体来说主线就是：一万元公演，GEKOKU娘，全兼任（SKE，NMB），HKT，总选举，后期就放飞自我了<br>每一个剧情都是：<br>好像是机会，很棒！<br>反派来了，设坎！<br>主角团有危机，谋策！<br>单元剧形式，逐个解决！<br>这么做在连载的时候倒无所谓，但是一口气看完的话就会觉得有点枯燥，后一百话我是一口气看完的，有些地方就不愿意看仔细了。<br>总的来说还是一部略有遗憾的作品，在剧情方面有很大提升空间，尤其是爱情线，最有执念的爱情却表现得最含蓄，青涩，这又不是什么100天恋爱，付出了4年，本因该开出绚烂的花朵，结出丰硕的果实的，结果给我们看了一个茁壮成长的小树苗，虽然也是“希望”，也可以看到美好的未来，但是已经4年了啊，读者也看了这么久，给颗糖不行吗？就算现在是偶像，你写个什么“三年后”然后发个糖不行吗。</p><p>补充一点，有miku登场好评</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《女高》真的有升华吗？它有的只不过是日常罢了！</title>
    <link href="/2020/02/15/%E3%80%8A%E5%A5%B3%E9%AB%98%E3%80%8B%E7%9C%9F%E7%9A%84%E6%9C%89%E5%8D%87%E5%8D%8E%E5%90%97%EF%BC%9F%E5%AE%83%E6%9C%89%E7%9A%84%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E6%97%A5%E5%B8%B8%E7%BD%A2%E4%BA%86%EF%BC%81/"/>
    <url>/2020/02/15/%E3%80%8A%E5%A5%B3%E9%AB%98%E3%80%8B%E7%9C%9F%E7%9A%84%E6%9C%89%E5%8D%87%E5%8D%8E%E5%90%97%EF%BC%9F%E5%AE%83%E6%9C%89%E7%9A%84%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E6%97%A5%E5%B8%B8%E7%BD%A2%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>剧透！</p><p>从外在角度来说制作精良，更何况作为日常番，已经没有什么可以挑剔的部分了。<br>从内容来讲，这部作品真的是超出我的预期。本以为就是日常搞笑类型的作品，没有想到还有这样的升华。<br>但是仔细想想……它、真的有升华吗？<br>我们觉得《女高》很日常，是因为它描述的是普通人的日常的生活，没有架空的背景，没有一波三折的剧情，有的只是各种“怪人”的搞怪。<br>死宅是一个典型的阿宅形象，成绩平平，喜欢BL，喜欢V家，想当漫画家（这点可以抽象为“想为喜欢的事物创作”，bgm上大家的感想也算哦），但是很咸鱼，经常颓。弹幕里经常飘过“真实”“是我”，可以看得出来死宅真的就是一个普普通通的女子高中生。<br>而说“升华”，是指死宅为自己喜欢的P主唱了首翻唱，然后在展会上发现是自己的班主任。这段剧情在这部作品里算是一个情感的高潮，大概可以提取出来的要素就是：“作者与粉丝的关系”。<br>作者给出的答案是粉丝喜欢作者-&gt;支持作者（这里是翻唱）-&gt;作者回应粉丝情感<br>这也很日常，大家都有喜欢的作者，也都有想要表达喜欢感谢的心情，然后得到作者的回应。这其实是非常良性的互动。我不知道B站上那些投翻唱，二创的粉丝们有没有得到作者的回应，但是我其实是有几次体会的，比如在推特上用三脚猫英语表示喜爱，并问wisp X来不来中国平台投稿，他很热情地回答了我，过了几个月就在网易云上投稿了（貌似他本来就有这个计划）<br>还有初中的时候很喜欢MAD、PV，就写了消息给现Alice映画的掌门<a href="https://space.bilibili.com/294227/" title="千枼草_阑小逝">千枼草_阑小逝</a>，表达了喜欢她们的作品并问以后有没有机会合作。她也很耐心地回了我（记得比我发的还多？），并期待着能有那一天。（虽然我现在还远远没那个实力罢了qaq）<br>现在每看完一部连载漫画也都会向汉化组写一份感谢信，这个回的就比较少了QAQ<br>其实呢，这就是《女高》，也是我们每个人都在经历的日常。</p><p>再说一些无关的。</p><p>可能有些人会觉得这部作品里面的人在现实中部分很不讨喜，但是在作品里却被温柔以待，这点我无法否认。但这是否没意义？是否需要排斥这种“虚构的美好”？</p><p>The reality is broken.</p><p>“逃避现实”,“虚构世界中的美好”<br>这些东西看似是在说这些虚构世界是一个陷阱，裹着糖果外皮的陷阱，让人无法面对现实的残酷。<br>从某种意义上来说这是正确的，虚构世界中的美好仿佛就像是理想主义者开出的玩笑……在如今这个现实主义风靡的社会，这种美好被很多人轻视。就算有人欣赏，也会认为“这是虚构的”、“仅仅是理想罢了”<br>但是现实主义者仍然是可以去追寻这种“虚构的美好”，因为它是客观存在的。<br>这里我个人认为罗翔老师在论证“正义是否客观存在”的这段视频是很好的例子（<a href="https://www.bilibili.com/video/av85716082" title="视频链接">视频链接</a>）<br>他最后给出的答案是：正义是客观存在的，我们无法达到绝对的正义，但是既然正义是客观存在的，我们就可以去追求，去朝这个方向努力。</p><p>相信在看这篇日志的各位都认同，比起外在，一个人的内心更加重要。而我认为，这种向往美好的情感是最纯粹的，积极的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>魔女之泉2——一款优秀的子供向作品</title>
    <link href="/2020/02/07/%E9%AD%94%E5%A5%B3%E4%B9%8B%E6%B3%892%E2%80%94%E2%80%94%E4%B8%80%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%AD%90%E4%BE%9B%E5%90%91%E4%BD%9C%E5%93%81/"/>
    <url>/2020/02/07/%E9%AD%94%E5%A5%B3%E4%B9%8B%E6%B3%892%E2%80%94%E2%80%94%E4%B8%80%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%AD%90%E4%BE%9B%E5%90%91%E4%BD%9C%E5%93%81/</url>
    
    <content type="html"><![CDATA[<center><img src="http://bubbleioa.top/wp-content/uploads/2020/08/WS2.jpg"  alt="" /></center><p>其实魔女之泉系列很早之前就想玩，阴差阳错的到现在才开始玩，2是我玩的第一部，选它主要是它在bgm上评分最高。<br>后来发现，从各方面来讲还是不咋地，可能是因为年龄的原因。<br>如果从10~14岁的儿童来讲，这会是一部优秀的作品。下面就说下优缺点。</p><ol><li>小体积，低配置（不到300MB的安装包，2014年的手机依然能流畅运行），但这也导致了游戏的画面表现欠佳（以16年的角度来看）</li><li>BGM好听，但是每一首时长太短，总有点意犹未尽的感觉。</li><li>UI设计有问题，很多时候常用的操作使用起来很麻烦（比如换宠物）。</li><li>游戏性一般，不断地叠数据（好在不是太肝），后期非常轻松（除去后日谈）</li><li>立绘不错，CG不行（立绘和CG简直是两个画风啊喂！）</li></ol><p>其实上面说的这些优缺点都无足轻重，因为剧情和人物实在是硬伤。（以下内容存在剧透）<br>我主线的结局是rank A，没和罗宾在一起的结局。<br>说到罗宾我就火大！</p><center><img src="https://s2.ax1x.com/2020/02/07/1gFblR.png"  alt="" /></center><center><img src="https://s2.ax1x.com/2020/02/07/1gFq61.png"  alt="" /></center><p>把咱女儿弄成这样你丫还想和咱女儿好上？！留你条小命就不错了！<br>就像之前有位先生/女士@幻影Locus说的，这部作品“人物比较浅显，哪些忠装反哪些反跳忠基本一眼能猜出来”，从一开始就猜到要给青梅竹马洗白，知道“黄金铠甲勇士”要跳反。<br>还有就是明明Luna都黑化了，剧情交代了魔女受迫害，Luna被背叛，还要引导玩家做好事，真的是为孩子树立正确价值观呢（具体方法就是坏事低回报，好事高回报）<br>煽情的地方也是非常唐突，母子重逢，青梅竹马重逢。剧情铺展不到位，个人感觉结局的剧情长度都有结局之前所有剧情长度的和了……<br>封面上有三个人在主线里面基本上没有什么交集。<br>空洞的人物加上支离的剧情导致这个自由度不怎么高的游戏玩起来像沙盒游戏一样。其实就算这个故事和角色形象很套路，但只要认真讲好故事，丰富形象也不失为上策。但是魔女之泉2的角色形象的饱满度和剧情的充实度实在是硬伤，导致玩起来十分膈应。<br>（以上评论仅针对主线剧情，后日谈部分也是游戏的一个亮点，但不在评论范围内）</p><p>最后祝Luna和Pieberry百年好合！</p><center><img src="https://s2.ax1x.com/2020/02/07/1gkzD0.jpg"  alt="" /></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我想要知道“爱”的含义（无剧透）</title>
    <link href="/2020/01/11/%E6%88%91%E6%83%B3%E8%A6%81%E7%9F%A5%E9%81%93%E2%80%9C%E7%88%B1%E2%80%9D%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88%E6%97%A0%E5%89%A7%E9%80%8F%EF%BC%89/"/>
    <url>/2020/01/11/%E6%88%91%E6%83%B3%E8%A6%81%E7%9F%A5%E9%81%93%E2%80%9C%E7%88%B1%E2%80%9D%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88%E6%97%A0%E5%89%A7%E9%80%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我想要知道“爱”的含义。   ——薇尔莉特·伊芙加登</p></blockquote><p>北京时间1月11日12点10分，今天老师意外的没有拖堂。</p><p>“下课，同学们再见。”听到这段话的时候我早已在教室外面，要问为什么我这么急的话，距离我订的电影开始还有40分钟，而我距离影院4.5公里。</p><p>室外温度大约6~7℃的样子，摩托车载着我在金属的河流中穿梭奔驰。尽管如此，我的手还在口袋外，操作着手机，希望能够在到达后节省一部分时间。</p><p>“没有任何一个乘客是没有必要送达的。”这是我看完电影后的想法。</p><p>扫码、打票、取票、验票、上厕所、坐好。一套动作刚刚做完，电影正好开始，没有看广告，整个影院里只有我和我的朋友，这是我人生中第一次“包场”看电影。</p><p>我之所以能这么快速地完成这些步骤，其中离不开信息的交流，可能在今天，其载体更多的是手机等电子设备。但这些东西，都是客观的，死板的数据，不值得被纪念，甚至是不值得被记录的（从个体角度）。</p><p>而《紫罗兰永恒花园外传 - 永恒与自动手记人偶》（以下简称《紫罗兰外传》）中则以“信”为载体，传达“爱”的信息。</p><p>要以商业电影的角度来看的话，《紫罗兰外传》无疑是不成功的。它缺少商业电影惯用的手段（比如说“英雄之旅”），感人的核心要点过于复杂，情感表达过于细腻收敛（前半段）。倘若将《CLANNAD》做出一部剧场版来，也很难像TV版那般煽人泪下。（个人觉得《紫罗兰（TV版）》能做成24集就好了）</p><blockquote><p>“伟大的动画，就是抹去了时间的刻度，跨越了空间的距离，始终完成了陪伴这两个字。”  ——CCTV6对本作品的评价</p></blockquote><p>是的，正是因为它不的这些特质，从而使它能被反复品味，陪伴于我们身边。在现实中能有几个人，几次机会像帆高那样率真热情地挥洒青春呢？但是我们身边却无时不刻都有他人，他人有着他人的情感，我们自己有着我们自己的情感，受限于种种原因，我们经常不能将自己的真情实感传达给别人，也就是“届不到”，所以去仔细地品味《紫罗兰外传》所想要传达给我们的关于人与人之间情感的传达方式，是很重要的。</p><p>前段时间我们语文老师说他们那个时代的人们都很浮躁，我们这个时代又何尝不是呢？功利化的价值观从一定程度上推进了社会的发展，但处于这个时代更难能稀缺的恰恰是“爱”。这种“爱”不单止爱情，它可以是“兼爱非攻”中的爱，也可以是“老吾老，以及人之老；幼吾幼，以及人之幼。”中的爱。</p><p>在本片中，我觉得艾米对于泰勒的爱就偏向于后一种。明明没有血缘关系的姐妹，却在战争中联系到了一起，最终形成了血浓于水的亲情。这一点我在以前很多观后感中都提到过，是类似于《小王子》中所说的“驯养”的关系。</p><p>刚刚也说这部作品的情感很复杂，而且很多需要自己体会的地方，请务必亲自体会！（其实是我太菜了表达不出来）</p><blockquote><p>没有一封信是不需要被送达的。 ——贝内迪克特·布卢</p></blockquote><p>在信息技术如此发达的今天，我也写过信，虽然最终因成本太高放弃了（10元/封，虽然可以寄1kg），但我相信我在信中所传达到的情感对方肯定收到了。</p><p>薇尔莉特在本作中其实不算是特别核心的人物（所以叫做外传），故事的主线也不是她，但当我看到结尾被问到 “你的幸福道路是什么？” 而回答不上来的薇尔莉特，我想到了TV版中一开始她对社长的话 “我想知道‘爱’的含义。”她是否寻找到了，其实没有那么重要，关键是她承认了自己不知道，并且在寻找。我们又是否真的了解爱呢？还是不懂装懂呢？其实这比不知道更加不妙吧（笑）</p><p><strong>总结</strong></p><p>今天考试的时候读到了铁凝的《在人民的创造中实现文学的创造》，颇有启发。</p><p>《紫罗兰外传》这部作品本身绝不是那些给人“爽”的电影，也不是为了赚眼泪的“泪腺战士”。观看时其实包含了理性于情感的复杂的认识过程。看小说、电影就是“了解各种人，熟悉各种人，了解各种事情，熟悉各种事情”的过程。而“了解”和“熟悉”不仅仅是听到新鲜的故事、掌握表象的细节，而是与人们发生思想感情的深入交流。。对文学来说，其所想表达的主题、想要传达给读者观众们的情感不止是存在于概念和观念之中，这样只是停留在了作品本身，而读者观众们自身却没有收获，其真正存在于人们之间的关系中，在我们面对“各种人们的脸”敞开心扉的时刻被蓦然照亮。</p><p>因此我还是希望大家真的仔细品味每一部温柔的作品，在这个时代，它们的存在就是一盏明灯</p><p><strong>小吐槽</strong></p><ol><li>好像我每次观后感的风格都不一样？</li><li>档期这么靠近春节好评，CCTV6吹爆好评。</li><li>薇尔莉特双马尾suki</li><li>“新时代”来了，薇尔莉特她们的生意虽然会受到打击，但我相信不会消失。（毕竟快递还是要人送的ww）、</li><li>BGM好多是TV版OST里面的老东西，由于之前经常在听所以觉得用在这里不是特别恰当。</li><li>这次写得比较急，欢迎大家来讨论~</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生命的联系——《我想吃掉你的胰脏》观后感</title>
    <link href="/2019/08/22/%E7%94%9F%E5%91%BD%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%94%E2%80%94%E3%80%8A%E6%88%91%E6%83%B3%E5%90%83%E6%8E%89%E4%BD%A0%E7%9A%84%E8%83%B0%E8%84%8F%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <url>/2019/08/22/%E7%94%9F%E5%91%BD%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%94%E2%80%94%E3%80%8A%E6%88%91%E6%83%B3%E5%90%83%E6%8E%89%E4%BD%A0%E7%9A%84%E8%83%B0%E8%84%8F%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内涵剧透</p></blockquote><h1 id="评论部分"><a href="#评论部分" class="headerlink" title="评论部分"></a>评论部分</h1><p>以下内容是我看到mal上面的一个评论，我觉得和我想法很像就翻译了一下（渣翻<br>翻译自：<a href="https://myanimelist.net/reviews.php?id=299818">https://myanimelist.net/reviews.php?id=299818</a></p><p>《胰脏》有两个主题。第一个主题由该片女主角樱良的日记(原文是dairy，我怀疑他拼错了)阐释，“向死尤生(Living with Dying)”。樱良身患胰脏病并且会最终导致寿命变短。正如所有人都会预料到的一样，她非常害怕。她努力地与她的情况妥协并且像她以前一样做个无忧无虑的女孩来度过余生。生命总有尽头，不幸的是，樱良的寿命会比大多数人的短。尽管没有人知道她何时会死——就连她自己也是。在病魔夺走樱良的生命之前，17岁的她在街上遇刺身亡。该片无疑是将樱良设定成突然死亡，这个事件甚至让我有点儿防不胜防。该片的第一个场景就是樱良的葬礼，因此，如同樱良一样，观众们本应在进入故事的时候接受她的死，但是，如同樱良一样，我们在努力抗争死亡。无论如何，死亡总是突然的，令人恐惧的，悲伤的。该片处理樱良死亡的方式对观众来说，应该是显而易见且容易理解的，但当你看到它的到来，它任然会以某种形式然你防不胜防，如同樱良一样。《胰脏》这部影片将樱良的情感编排进观感中并且使观众与她的情况产生共鸣。如果电影做到了这一点，观众们在结尾会和春树一样抽泣。</p><p>没有春树，《胰脏》这部影片会变成一次空洞的体验。樱良的故事情感也许很强烈，但是正是春树的故事才真正感人。在遇到樱良之前，春树一直活在壳里。他没有个性，没有情感，他将自己与外面的世界隔离。樱良是第一个向他胜出橄榄枝的人，在春树于樱良相处的过程中，尽管有些不情愿，他慢慢地开始向她打开心扉。这是他人生中第一次，与其他人产生联系。春树知道樱良不会长久地在他身边，但是就像其他人一样，他无法应对樱良地离去。在她死之后，春树又开始封闭自己，但是他不再是遇到樱良之前地那个他了。春树开始意识到独自一人是多么困难并开始追寻其他人际关系。尽管樱良走了，她在周围人身上留下的影响会一直留存，尤其是对春树来说。春树就像一个代替观众的角色，因为他在电影开始时十分朴素，无特点，观众也容易带入到他的角色中。在该片的高潮部分，春树在观众旁痛哭流涕，加强了他于观众的共同情感，使得“人与人之间的联系的重要性”这一主题深入人心。</p><p>以下内容为原创</p><p>“每一天的价值都一样，不管做了什么，今天的价值都不会变，这种日常的点滴对我来说就特别开心”——樱良<br>正如前面所说，樱良并没有克服对死亡的恐惧，但她找到了缓解的方法——过好每一天，享受日常的点滴。这种简单的想法就是主导她与病魔作斗争的原因，在很多情况下，我们会忽略甚至是舍去这点。<br>《小王子》中曾提到“如果你对大人说，我看到一栋用玫瑰色的砖盖成的漂亮的房子，它的窗户上有天竺葵，屋顶上还有鸽子，他们怎么也想象不出这种房子有多好。必须对他们说，我看见了一栋价值十万法郎的房子，那么他们就惊叫道：‘啊！多么漂亮的房子啊！’”<br>所谓真的生命，就是像樱良这样，或者像《小王子》中提到的这样去享受日常的点滴。人们总是在年轻的时候认为时间很多，大肆挥霍，而到了老年又认为自己时间很少，做不成什么。<br>樱良的这种生活方式，正是她人格魅力的所在。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2019/08/xwz.png"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/08/xwz2.png"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/08/DPlayer-4.png"><img src="http://bubbleioa.top/wp-content/uploads/2019/08/DPlayer-3.png"><img src="http://bubbleioa.top/wp-content/uploads/2019/08/DPlayer-2.png"><br>在读樱良遗书的这段演出中，内容无疑是致敬了《小王子》，因此当樱良说到“但是我们的关系并不是恋爱和友情这种如此简单的东西”的时候，我自然想到了小王子与狐狸，他们之间关系就是“驯养”，所谓“驯养”，就是创造关系。</p><p>“对我来说，你无非就是个男孩，和其他千千万万个男孩没有什么区别，对你来说，我也只不过是只狐狸，和其他千千万万只狐狸一个样，但如果你驯养了我，我们就会彼此需要，你对我来说，将是独一无二的，我对你来说，也是独一无二的。”——狐狸</p><p>对于樱良和春树来说，他们的关系也是如此。樱良教会了春树如何与他人创造关系，而春树陪樱良平凡地度过了余生，他们彼此是独一无二的。</p><h1 id="吐槽部分"><a href="#吐槽部分" class="headerlink" title="吐槽部分"></a>吐槽部分</h1><p>mal评分：8.43<br>bgm评分：7.0<br>看来国内并不怎么习惯这个故事的样子，也许是文化背景的不同吧。但是看差评大多数是被剧透了的（包括我在百度上搜该片，在联想搜索上就剧透除了一个伏笔orz）</p><p>《胰脏》的音乐表现算是及格水平，并没有《前前前世》或者《打上花火》那样的传唱曲，但是在剧情方面很能扣人心弦，伏笔埋得很多（有长有短），像是主角的名字啦，还有樱良包里的药。</p><p>角色成长也很明显，尤其是春树，从一开始的封闭到最后的主动与他人交流，在这个悲伤的故事中也微微闪耀着光芒。</p><p>下面说说问题</p><ol><li>其实该做的角色出奇的少，基本上就是男女主之间的互动，但并不枯燥。</li><li>观感上时而露骨时而含蓄。樱良前男友突然出现，樱良突然被刺死。并不是这样做不好，但是并不是所有观众都能接受。</li><li>死亡原因不是很能接受，也许突然死亡能够凸显出作品主题，但是哪怕是被车撞死也好啊，因为刺死这种有主观恶意的东西突然发生在这么美好的女主身上我真的很不忍心。</li><li>不知道50多分中的那段让人dokidoki的场面电影院有没有，有的话就是我亏了QAQ（话说这是问题吗www</li><li>我对突兀的死亡原因的理解是：因为遇刺是每个人都可能发生的，所以每天都可能是最后一天，像樱良这样的乐观去活出每一天才是对生命的享受，每个人都要像樱良这样，而不是因为她时日不多（与kino交流的时候想到的）</li></ol><p>有机会的话准备二刷，多谢款待！</p><p>主观综合评分：8.0/10（强烈推荐）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的人生时方向不明的迷途——《十字路口》书评</title>
    <link href="/2019/06/15/%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E6%97%B6%E6%96%B9%E5%90%91%E4%B8%8D%E6%98%8E%E7%9A%84%E8%BF%B7%E9%80%94%E2%80%94%E2%80%94%E3%80%8A%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E3%80%8B%E4%B9%A6%E8%AF%84/"/>
    <url>/2019/06/15/%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E6%97%B6%E6%96%B9%E5%90%91%E4%B8%8D%E6%98%8E%E7%9A%84%E8%BF%B7%E9%80%94%E2%80%94%E2%80%94%E3%80%8A%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E3%80%8B%E4%B9%A6%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<h1 id="原作CM"><a href="#原作CM" class="headerlink" title="原作CM"></a>原作CM</h1><center><iframe src="//player.bilibili.com/player.html?aid=4425433&cid=7169218&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></center><h1 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h1><p>[audio flac=”<a href="http://bubbleioa.top/wp-content/uploads/2019/06/03.-%E3%82%AF%E3%83%AD%E3%82%B9%E3%83%AD%E3%83%BC%E3%83%89.flac&quot;/]">http://bubbleioa.top/wp-content/uploads/2019/06/03.-クロスロード.flac&quot;\]</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>《十字路口》是由人气动画导演新海诚与日本教育机构Z会合作，制作的一部应援日本国立大学前期考试的考生们的广告动画。<br>而同名小说《十字路口》则是由桐山成人根据此改编的。</p><p>官方网站:<a href="https://www.zkai.co.jp/home/crossroad/">https://www.zkai.co.jp/home/crossroad/</a></p><h2 id="网络评价"><a href="#网络评价" class="headerlink" title="网络评价"></a>网络评价</h2><p><a href="https://movie.douban.com/subject/25834500/">豆瓣（原作）</a>：8.0/10.0<br><a href="https://bangumi.tv/subject/97477">Bangumi（原作）</a>：7.2/10.0<br><a href="https://bangumi.tv/subject/114209">Bangumi（小说）</a>：7.5/10.0<br><a href="https://www.imdb.com/title/tt7386590/">IMDb（原作）</a>：7.5/10.0</p><h2 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h2><blockquote><p>我既不期望获得幸福，也不需要什么信誓旦旦的约定。<br>我自由其他期许，希望有朝一日能够远行。<br>奔赴更加飘渺的远方。</p></blockquote><h2 id="剧情简介"><a href="#剧情简介" class="headerlink" title="剧情简介"></a>剧情简介</h2><p>“也不是为了活的幸福，也并非想要明确的约定。比起那个来说，遥远地方的某处，是我们向往前去的地方。”无论身处关东还是关西，无论是喧嚣的繁华都市还是僻静的海港小镇，都有着普普通通的少女，为了各自心中的理想而努力。女孩海帆和男孩翔太从未忘却心头的理想，也知晓前路的曲折与艰辛。他们通过Z-KAI的通信教育在知识的海洋中破浪前行，享受着每一次好成绩取得时所带来的喜悦，惴惴地等待着最终考验的到来，又沉着专注地和万千学子们投入命运的战斗中去。十字路口，他们没有彷徨和失落，因为前方的灯塔早已照亮人生的方向…… </p><hr><blockquote><p><strong>！以下内容含有轻度剧透！</strong><br>为了叙述方便，下将“日本国立大学前期考试”和“日本国立大学考试”统称为“日本高考”</p></blockquote><h1 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h1><blockquote><p>由于没有比较完备的中文百科，人物名字可能会省略或者用关系代替（其实还是懒不想从原文找）</p></blockquote><table><thead><tr><th>人物</th><th>图片</th><th>评论</th></tr></thead><tbody><tr><td>翔太</td><td><img src="http://bubbleioa.top/wp-content/uploads/2019/06/%E7%BF%94%E5%A4%AA.png"></td><td>一名生活在东京的普通男高中生，生活在单亲家庭中。因不想让母亲太累而坚持周末兼职，为人和善深受学弟学妹的喜爱。</td></tr><tr><td>海帆</td><td><img src="http://bubbleioa.top/wp-content/uploads/2019/06/%E6%B5%B7%E5%B8%86.png"></td><td>一名生活在姬座五岛（虚构）的普通女高中生，在高三下学期开始前偶然确定了自己的方向——东京大学，为人认真，常被叫做“认真四眼”。</td></tr><tr><td>海帆父亲</td><td>暂无</td><td>一名普通的父亲，在本作中主要体现“笨拙的父爱”。</td></tr><tr><td>翔太母亲</td><td>暂无</td><td>单亲家庭的母亲，因为压力大经常酗酒，但自从让儿子辞去兼职后变得更加成熟。</td></tr></tbody></table><h1 id="核心价值-amp-个人影响"><a href="#核心价值-amp-个人影响" class="headerlink" title="核心价值&amp;个人影响"></a>核心价值&amp;个人影响</h1><p>本书分两条线主要讲述了两名日本高中生在高三下学期的努力备考的故事，虽然是写日本高考的内容，但作者却把笔墨跟多地放在了学习生活过程中所面临的种种问题。</p><p>由于书中描绘地是主人公高三下学期地学习生活，其实对于我这个“准高三”的学生来说还是很有感触的。它不是那种励志小说。比描写如何努力学习考上好大学，它所讨论的更多的是人生道路的选择以及这个选择对于人与人之间关系的影响。它的结局甚至是开放的，并没有讲明考试结果。这种核心反而使得本书比那些励志鸡汤高了一个层次，对于正在迷途的十字路口的“准高三们”，有更大的指导意义。</p><p>我曾经以为“日本高中生”都很闲,有各种各样的高中生活。<br>但我可能见识太少了。在读此书的时候，由于翻译得十分地道，我有时甚至会忘记自己在看一个讲述“日本高考”的小说。<br>看到诸如“文言文很难。”、“英语阅读靠语感，要多做题。”之类的话，总能会心一笑，心想——原来即使国家不同，所奋斗过的青春是一样的啊。</p><blockquote><pre><code>目光突然停留在某个答题栏上。我重新检查起答题纸。阅读理解的最后一问，英译日。需要翻译的句子被下划线标注了出来，只是文章的后半段的某句话，应该体现了文中的中心思想。My life is at a crossroads.我的译文是“我的人生是方向不明的迷途”。阅卷老师给我打了个叉。之不是重点，重点是他还用红笔在旁边批注道：**“翻译得很美，不过意思错了。这种情况下crossroads的翻译应该参考上下文的语境……”**我又用目光扫过原文，一个字一个字地咀嚼划线地英文，然后再看向写有批注地答题栏。……翻译得很美。我又重复了一遍刚才的举动，从原文看到答题栏。……翻译得很美。我又看了第三遍，第四遍，直到千帆来叫我吃晚饭。他还是没敲门就进来了，可奇怪的是我这次没有发脾气。……他说我翻译得，很美呢。</code></pre></blockquote><p>这个片段可以说是我对这本销售印象最深刻地部分，当时看的时候曾几次放下书，激动地用脚踢被子。读完后躺在床上，竟久久不能入睡。我当时在想，一个陌生人（上文中的卷子是寄给教育季候批改的）的无意的话语，居然能如此深刻地影响到别人。海帆之后的备考道路上，有很大一部分的动力是靠这短小的话语支撑的。主人公开始相信自己有学英语的天赋并为之努力，即使失意一时也能迅速恢复过来。</p><p>但仔细想想，其实我的身边也有很多类似的话语。记得我上初中的时候，我们英语老师要我在全班面前朗读课文，当时我早有准备，就这样读了下来，老师当着全班同学的面说：“hzy同学发音很好听，以后能去当播音员。”</p><p>她说我发音很好听呢qwq，在之后的学习英语的道路上，我也很自信地去读课文，并且给了我能学好英语很大的自信。</p><p>还有一点很打动我的是，日本高考也是牵动全家的，这一点无疑是和我们国家十分相似的。<br>在海帆决定要考东京大学的时候，家人表面上都很支持，但谁的心中都明白，如果考上了，就意味着家人要彼此分离。但这份感情，只有海帆的妹妹——在读二年级的千帆表达了出来。<br>而翔太这边，由于是单亲家庭，为了为母亲缓解经济上的压力，即使到了高三还坚持去兼职。母亲为了自己孩子的前程也不断地透支着自己的健康努力工作。直到翔太打工的店长说：“我觉得你关心母亲的方式有点不太对。”这背后的意思其实很简单，作为高三的学生，马上就要上大学走向社会，能陪在家人旁边的时间已经不多了，对于母亲来说，此刻最想要的其实是儿子的陪伴和专心地学习吧。</p><p>其实我对这部作品感触这么深还有一点原因就是有各种既视感吧，上面提到的的英语是一部分。<br>还有一些比如说翔太高中棒球生涯的退役典礼，我也想和其他OIer一起这样搞一个退役典礼啊！各种什么“I AK IOI”之类的233<br>还有就是海帆独自前往东京考试的时候，那心里活动简直和我去参加APIO的时候一模一样啊qwq，唯一的区别是我借助智能手机避免了很多不必要的麻烦，比如没有迷路，吃外卖，移动支付等等。心疼海帆QAQ</p><p>由于时间不够就写到这里，其实还有很多想写的。而且文章组织地有点乱，见谅啦~<br>向着我的高三，出发！</p><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><ol><li>Z-Kai有没有中国高考的服务啊qwq，我想报名xd</li><li>为什么这种小说都有人把它当成爱情小说来看啊！</li><li>感觉自己好不懂事啊。</li></ol><h1 id="主观评分"><a href="#主观评分" class="headerlink" title="主观评分"></a>主观评分</h1><ul><li>真挚的感情和内涵 </li><li>后期配角的成长没有体现略显遗憾</li><li>篇幅较短很多转变无法详细叙述</li></ul><p>个人主管评分：8.2/10.0（强烈推荐）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么我 退 役 了 还 要 被 迫 害 啊！！</title>
    <link href="/2019/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%20%E9%80%80%20%E5%BD%B9%20%E4%BA%86%20%E8%BF%98%20%E8%A6%81%20%E8%A2%AB%20%E8%BF%AB%20%E5%AE%B3%20%E5%95%8A%EF%BC%81%EF%BC%81/"/>
    <url>/2019/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%20%E9%80%80%20%E5%BD%B9%20%E4%BA%86%20%E8%BF%98%20%E8%A6%81%20%E8%A2%AB%20%E8%BF%AB%20%E5%AE%B3%20%E5%95%8A%EF%BC%81%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>本来别人都有两天假，我上午下午都在教室自习。<br>晚上终于有时间来解决VPS被ban的问题，然后还要被家长说：“都不学奥赛了还玩什么电脑。”（咱语气轻了点，实际上……自己脑补）<br>咱肥宅其实也不追求什么，只是希望能和有共同兴趣的人在一起，为之做点什么或者一起做点什么，聊下天，就已经心满意足了。<br>其实要是咱和大家@GoldenPotato@HigHwind@q234rty @void *swk = Kino.NvZhuang(); @Rye_Catcher @Traceback  在同一个班，咱再有个女朋友，还要什么智能设备？</p><p>但咱也知道这是不现实的，所以用QQ（或其他方式）来联系到一起，用猛男番和galgame来补充moe能量。<br>若是这点小小的愿望都无法满足的话，咱真的要怀疑这个世界了。别人放假比你多，学习比你强，精神生活上比你丰富，以后走到社会上比你优秀……（没错，就是指CDQZ的dalao）</p><p>咱其实不赞同“为了以后的美好而牺牲中学时代的一切”。<br>这和搞科技和实体经济是一个道理，你能说我们国家为了未来的经济更加繁荣，所以现在大力搞科研，而对实体经济不闻不问吗？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019届网络直播班毕业交流</title>
    <link href="/2019/05/28/2019%E5%B1%8A%E7%BD%91%E7%BB%9C%E7%9B%B4%E6%92%AD%E7%8F%AD%E6%AF%95%E4%B8%9A%E4%BA%A4%E6%B5%81/"/>
    <url>/2019/05/28/2019%E5%B1%8A%E7%BD%91%E7%BB%9C%E7%9B%B4%E6%92%AD%E7%8F%AD%E6%AF%95%E4%B8%9A%E4%BA%A4%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于二维码不是直接跳转至此页面，请保存此链接</p></blockquote><p><strong>交流贴使用指北</strong><br><a href="http://bubbleioa.top/wp-content/uploads/2019/05/%E4%BA%A4%E6%B5%81%E8%B4%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97.doc">点击查看</a></p><p><strong>如何更改头像？</strong><br>访问<a href="http://cn.gravatar.com/">Gravatar官网</a><br>使用邮箱注册账号并上传你的头像，之后在发表评论时填入相应邮箱地址即可。</p><p><strong>如何发表图片？</strong><br>访问<a href="https://sm.ms/">sm.ms</a><br>上传你的图片后你会得到一个链接，该链接即为你要发布的图片。<br>发布评论时只需如此调用<code>![](图片链接)</code></p><p><strong>更多操作</strong><br>评论支持<a href="https://www.runoob.com/markdown/md-tutorial.html">MarkDown语法</a>，这里有一份稍微<a href="https://www.jianshu.com/p/191d1e21f7ed">简化的教程</a>。如果你不确定评论发出来会是怎么样的，这里有款<a href="https://www.mdeditor.com/">在线的MarkDown编辑器</a>可以预览你的效果。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>来自多彩世界的OI</title>
    <link href="/2019/05/22/%E6%9D%A5%E8%87%AA%E5%A4%9A%E5%BD%A9%E4%B8%96%E7%95%8C%E7%9A%84OI/"/>
    <url>/2019/05/22/%E6%9D%A5%E8%87%AA%E5%A4%9A%E5%BD%A9%E4%B8%96%E7%95%8C%E7%9A%84OI/</url>
    
    <content type="html"><![CDATA[<h1 id="涟漪"><a href="#涟漪" class="headerlink" title="涟漪"></a>涟漪</h1><p>2015年5月21日（现在不可以查了，还好我记得这个日子），我注册了一个B站账号，是被拜年祭吸引过来的，这也注定了我是对睿站的（当时应该还是逸站）MAD是最感兴趣的，后面慢慢了解到有个公司叫做Adobe，有个软件叫AE，当时硬是靠速龙Ⅱ来学的，现在想来都可怕XD。<br>在AE里我接触到了代码：也就是表达式。当时真的觉得很神奇，一行短短的代码就能让MAD栩栩如生，当时还觉得那东西很难233</p><p>没过多久，睿站的第二届弹幕（也是最新一届）开始征稿，毫无经验的我也凑热闹参加。当时弹幕多到我速龙Ⅱ的电脑都渲染不出来（可以看2P的录屏，明显延迟），链接在这：<a href="https://www.bilibili.com/video/av2594281">https://www.bilibili.com/video/av2594281</a></p><p>当然，冠军是真的触，直接整出一个MAD来：<a href="https://www.bilibili.com/video/av2739681/">https://www.bilibili.com/video/av2739681/</a><br>真的是太强啦！%%%</p><p>在文化课的学习过程中，这些小小的代码，在灰色的视界上点缀了些许彩色。</p><h1 id="斑斓"><a href="#斑斓" class="headerlink" title="斑斓"></a>斑斓</h1><p>2017年11月24日，我在PTA上提交了第一份代码，开始了我的OI之旅。初识OI并没有想象中的那么浪漫，就是抱着渣男的态度觉得随便试试就好。这个态度在接下来的半年里慢慢改观，然而这太慢了，以至于原本不多的时间又被截去了一部分。</p><p>停课总是很快乐的，无论是在别人放假的时候还是在别人上课的时候。寒假里停了15天，当时还是萌新（虽然现在升级为蒟蒻了），感觉学得还很轻松，晚上整个学校就我们几个学奥赛的住寝室，很恐怖QAQ，但是，yy在下铺打开电脑，播放《寻梦环游记》，一整个寝室的人都凑过来看，我在上铺，很冷不想下去，于是就看起《序列之争》来了233.现在想起来，那段时光是特别单纯而又幸福的，没有被大佬锤的压力，没有升学的烦躁。</p><p>平常的奥赛学习可以认为是没有作用的（具体可以看<a href="http://bubbleioa.top/archives/891">这篇文章</a>），只是在地上松土，为了能在停课的时候更好的播种。</p><p>就这样度过了半年的空白区，到了暑假，期间也没有什么特别值得记录的事情发生，只是有一个学长省选遗憾地没选上（学OI的时候疯狂炉石），那是JXOI最后一次由可怜出题，同时也是竞争最后一次那么弱的。</p><p>夏日的回忆，没有小姐姐的泳装（其实有，在《ISLAND》里233），只有OI。这段时间去了常州培训，具体可以看<a href="http://bubbleioa.top/archives/113">这篇文章</a>，我只记得我们被锤爆，然后回来发奋图强，但是有一个人因为玩游戏被教练T了，可能是他玩的游戏并不够OI吧。</p><p>然后就是突然理解到了clj所说的学了OI不需要女朋友，因为OIer都把全部的爱投入到了OI上，我真的从未感受过哪门学科的学生对该门学科如此热爱的，出题目，讲课，开发OJ，开发评测软件，写书……大家都努力地想要让OI变好，泪目。</p><p>然后又滚回来上了一个月文化课，在常州意识到差距之后，我们那个时候真的很着急。我当时正好在追《轻羽飞扬》，看了之后结合自己的感受黑化了一会（无能泄愤），然后在Bangumi上留下了<a href="http://bangumi.tv/blog/281939">黑历史</a>（还是首评）QAQ，也特别感谢Bangumi上的各位的批判，后来也一个个认了错（或者是解释了一下），以后应该就不会有这种事了（吧）。</p><p>NOIP2018前又停了1个月的课（我们强行要求的），之后来看，这个选择正确的，因为2018年JX竞争突然猛烈了许多，如果不是这次停课，我们很可能全军覆没。但是这次停课有人也很聪明（就是再说Linz），把刷题的中心从我们校内OJ转移到了Luogu，可以更好地于外校对比，刷题量也比我们多，最后的NOIP也是考得最好的。</p><p>大概是重阳节的时候我们在洛谷上举办了一个公开赛，现在看来，洛谷的审核是真的松，把好多大佬都坑了QWQ，<a href="https://www.luogu.org/contestnew/show/11523">具体请看这里</a>。<br>这里有个小插曲，就是当时我们全校停电，出的题目很坑，所以很多人来问，然后我就要了班主任手机开热点答疑，但是没人问我出的题目，很崩溃orz</p><p>NOIP炸了，本来其实可以上400的，最后只有300多一点，没看清数据范围是一方面，平时题解看多了也是锅。具体可以看<a href="http://bubbleioa.top/archives/581">我的游记</a>，当时如果能多考一点，结局会不会不一样呢？我不敢断言。</p><p>之后的寒假我们就兵分两路，Linz和教练去了WC，我还有其他4人去了<a href="http://bubbleioa.top/archives/629">郑州NOI导刊</a>。</p><p>回来后我犯了一个错误，就是和其他学生一样，平平淡淡地过完了一个寒假，没有碰OI。期间只和Linz等人开黑打CF div2 然后被Hack到死。<br>开学后，Linz带着其他几个人，一起退役了。其实这也并不奇怪，毕竟大家都被锤爆了，他们很理智地分析了自己和别人地差距，然后选择了放弃，我按理来说不应该责怪他们，但是……Linz你个烂人杰啊！请看Linz<del>令人羞耻的</del><a href="http://bubbleioa.top/archives/908">退役记录</a>。这只OIer是真的一点也不可爱，写退役记录也写得跟流水账似的，你不会写你可以“嘤嘤嘤”啊。</p><p><del>嘤嘤嘤……</del></p><p>然后就是我和机房的独处时光了~，省选前一个月，我确保每天都有3个小时的OI时间，但是我又犯了一个错误，就是看题解太多，想得太少，这也导致了我省选T3没写出来，虽然确实我们省没人写出来，但是我觉得我当时思路的方向是对的，可能就是少那么最后几步。</p><p>接着到来的省选在这里都有<a href="http://bubbleioa.top/archives/927">记录</a>，其实除了80pt挂成40pt很可惜外，没有什么无法释怀的，hwc都没进队，而且进队的那些队爷没有一个是比我花的时间少的，我又有什么好抱怨的呢？这只是单纯的奇迹没有发生罢了。</p><p>在这段学习OI的日子里，由最初的认识到OI可以保送的光鲜外表，再到后来慢慢了解到她的真实、她的的残酷，喜欢的心情从未减少。<br>如果再给我一次选择的机会，我还是会选择接触OI，多亏了OI，让我的黑白的高中生活多了些斑斓的色彩。</p><h1 id="多彩世界"><a href="#多彩世界" class="headerlink" title="多彩世界"></a>多彩世界</h1><p>退役后就感觉无比轻松，APIO就当作是OI生涯的退役之旅吧，但是没想到这次旅途，给我带来了一个多彩的世界。<br>具体请看<a href="http://bubbleioa.top/archives/936">这篇文章</a>。</p><hr><p>等等，还没有结束呢！</p><h1 id="O-I-人（梗来自请APIO2019主持稿，画面自行脑部）"><a href="#O-I-人（梗来自请APIO2019主持稿，画面自行脑部）" class="headerlink" title="O I 人（梗来自请APIO2019主持稿，画面自行脑部）"></a>O I 人（梗来自请APIO2019主持稿，画面自行脑部）</h1><p><a href="http://m-sea-blog.com/">M_sea</a>：祝CF上蓝！<br><a href="http://www.yihan.ac.cn/">Yijan</a>：祝考上CDQZ！<br><a href="https://www.goldenpotato.cn/">GoldenPotato</a>：OIer是不会被打倒的！话说你们学校机房真的是豪华<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/psb.jpg"><br><a href="http://www.cnblogs.com/Rye-Catcher">RyeCatcher</a>：恭喜SM2过了！话说新加坡那边的大学也有ICPC吧xd<br><a href="https://www.hh12.cn/">HigHwind</a>：队爷%%祝THUSC&amp;NOI2019 RP++，什么时候有机会再来颓War3吧~<br><a href="https://oi.yuyuko.cc/">kririae</a>：虽然现在您不认识我，但是AE+OI+GalGame，咱们匹配度很高啊！<br><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/">Shadowice1984</a>：神仙加油！退役了文化课上也不要输啊！<br><a href="http://www.cnblogs.com/">星星之火</a>：您是不是团委的呀（我在我们学校也是个团委委员）<br><a href="https://www.cnblogs.com/AlenaNuna/">AlenaNuna</a>：明年加油！明年再当一次主持人然后在Au那一栏里念出自己的名字。<br><a href="https://www.luogu.org/space/show?uid=91499">Linz</a>：这次不会输给你了。<br><a href="https://www.luogu.org/space/show?uid=96570">Steve_braveman</a>：潮学是啥？（狗头）<br><a href="https://www.cnblogs.com/butterflydew/">ButterflyDew</a>：您是让我醒悟，认识到自己是多么蒟蒻的OIer<br><strong>以下OIer由于某些原因找不到合适的链接（有的甚至连昵称都不知道，所以用首字母缩写）</strong><br>cyc：羡慕不用学导数，当然抛开分数不说，知识本身还是挺有趣的。<br>hjm：努力也要适度哦，主持的中场就不要写作业了吧ww<br>zzh：APIO2019主持人团队中唯一拿牌了的%%%<br>hxf：话说您学校的OJ为什么老是挂，怕不是您推荐给太多的人用了233</p><h1 id="妙妙屋"><a href="#妙妙屋" class="headerlink" title="妙妙屋"></a>妙妙屋</h1><ol><li>之前想过立下毒誓“没进省队就女装”，脑补了一下发现有一个变态在镜子里。</li><li>《碧浪航线》有一个绊爱联动的活动是要点一个格子，周围反转，要总和非负（当然越大越好），然后就写了一个dfs，后面想到，这种东西是固定的，直接上网搜不就好了么xd</li><li>主持的时候把莒看成了营，我谢罪。</li><li>之前把电脑装成Ubuntu的然后又装回Windows，真香！</li><li>颓游戏的时间很少，颓网页的时间很多。Chrome=娱乐工具说成立。</li></ol><h1 id="给学弟学妹们的建议（如果有学妹的话）"><a href="#给学弟学妹们的建议（如果有学妹的话）" class="headerlink" title="给学弟学妹们的建议（如果有学妹的话）"></a>给学弟学妹们的建议（如果有学妹的话）</h1><ol><li>不要颓废！不要颓废！不要颓废！（说了和白说一样）</li><li>如果要冲省队的话，我们学校停课时间不够，至少要4个月（除去假期）</li><li>从开始学的那一刻起，你们的时间就不多了。</li><li>多于外界交流！多去参加活动，这次的APIO没有参加真的有点可惜（话说APIO的要求是啥）。</li><li>不要出毒瘤题，不要学lxl出题！</li><li>少看题解，但是如果一道题看了1个小时还做不出来，赶紧看题解切了，然后加入到你的收藏夹里，定期抽出来再做一遍。</li><li>多打比赛，CF，洛谷（其实有时候洛谷会有坑）都是很不错的。</li><li>写博客，博客是你记录自己学习的地方，同时也是你和其他OIer交流的窗口。</li><li>出去培训其实有利有弊，选好去哪很重要。</li><li>欢迎补充……</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>退役啦！！！我终于可以<del>打GalGame，学AE</del>狂补文化课了。以后大学也有了大致方向，按照专业排序的话大概就是：CS&gt;软件工程=人工智能吧，ICPC还要看选不选的上校队。</p><p>愿每个OIer都被温柔以待。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《一男两制》——友情、爱情以及LGBT</title>
    <link href="/2019/05/22/%E3%80%8A%E4%B8%80%E7%94%B7%E4%B8%A4%E5%88%B6%E3%80%8B%E2%80%94%E2%80%94%E5%8F%8B%E6%83%85%E3%80%81%E7%88%B1%E6%83%85%E4%BB%A5%E5%8F%8ALGBT/"/>
    <url>/2019/05/22/%E3%80%8A%E4%B8%80%E7%94%B7%E4%B8%A4%E5%88%B6%E3%80%8B%E2%80%94%E2%80%94%E5%8F%8B%E6%83%85%E3%80%81%E7%88%B1%E6%83%85%E4%BB%A5%E5%8F%8ALGBT/</url>
    
    <content type="html"><![CDATA[<blockquote><p>包含大量剧透，若不介意的话可以继续阅读主题部分，但还是建议去看看原作，篇幅不长，大概一个多小时就能看完。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先推荐一个MAD：<a href="https://www.bilibili.com/video/av17687636/">av17687636</a></p><p>其实我早就知道了这部漫画，一直没看，究其原因还是以为这是一部女装Yooo卖腐向的作品，但经过一个up主的吐槽后才知道原来并没有那么简单。（至少看完我是没弯的，反而给我带来了更多思考）</p><p>原作连载于2010-2014年，不算是新作，但放在今天这种把伪娘当成商业元素的业界来看，它还是一股清流的。</p><p>这篇文章的观点注定很独特，至少是网上其他地方没有的（有的话我也不会想再写一篇了），可能部分读者不能接受该文章的某些观点，跳过即可。</p><h1 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h1><p>本来这点要放到最后的，但是由于种种因素，还是决定放前面来。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>较为丰富的人物形象</li><li>清新的画风</li><li>细腻的情感表达</li><li>值得思考的主题</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>没有配音！！（可能漫画说这个有点奇怪，但是你看了就知道我为什么这么说了233）</li><li>篇幅过短导致了很多问题（下面会说）</li><li>全员女装的设定导致很多人被劝退（比如说我）</li><li>国内汉化杂七杂八，同一个地方看的却是不同的汉化组，看的很难受（至少我是这样的）</li></ul><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p><strong>7.3/10</strong> 值得一看</p><h1 id="主题部分"><a href="#主题部分" class="headerlink" title="主题部分"></a>主题部分</h1><p>正如标题所说，我个人把这部作品提取出了3个主题。看得出来漫画作者其实有其他想表达的东西，比如说社会的阶级，权力以及各阶级其实都有自己所面临的挑战等等，但由于漫画篇幅过短，这些东西其实根本没有去细讲，所以就略过了。</p><h2 id="友情"><a href="#友情" class="headerlink" title="友情"></a>友情</h2><p>无论是在气氛逐渐变奇怪之前还是之后，友情都是本作一直在讨论的主题。<br>在动漫之家上，你可以看到吐槽上有这么一些tag<br>“这就毕业了么（哭”“有些感动，泪目”“意义深刻，感动人心””果然朋友很重要啊”“有朋友真好呢！”<br>B站评论“看了之后花了一下午补漫画，好感动，刚刚毕业，朋友间确实要多联系”</p><p>在第15话的结尾有这样一句话“朋友。这是在装饰着名为‘女装’的虚假世界中得到的、一生的宝物”（这里可以看出讲的其实是友情，而且女装这件事其实又具有了一层象征含义）</p><p>而本作的友情还是更特殊的——校园时代的友情。<br>无论是愁和葵一起学习，还是大家一起去救冬麻。尽管出发点不同，但是最后都会变成一种没有功利的，非世俗的行为。而这种行为的内驱力就是友情。包括前半部分愁对椿的憧憬，其实在现实生活中也屡见不鲜。其实这种憧憬说白了就是想要和优秀的人在一起，想和他交朋友的这种感情，这也是后面椿不再负责愁后，愁决定成为辅导员的原因。</p><p>这里有一段我认为非常不错的关于产生憧憬的描述（原文没标点很难受），事实上，很多友情是从憧憬开始，到后面的慢慢接触，接受对方的缺点，最后成为挚友。</p><blockquote><p>蓝色是愁说的话，棕色是葵，愁的姐姐是红色<br><font color="1E90FF">我觉得作为八重崎同学的追求者很好啊</font><br><font color="1E90FF">开始我从欣赏女孩的角度觉得他很可爱，现在也是这样认为的，</font><br><font color="1E90FF">但又不仅仅是那样子了，因为他是个男孩子</font><br><font color="1E90FF">他做到了我无法做到的事，教会了我很多事，又能看穿事物</font><br><font color="1E90FF">他甚至直面难以忘记的痛苦经过</font><br><font color="1E90FF">我越发地认为他是一个神奇的人，我很高兴有这样的一个人在我身边注视着我，即使仅仅是出于工作原因</font><br><font color="1E90FF">改变自我，是一件既有趣又好玩的事</font><br><font color="1E90FF">而我又很高兴，这样的一个人借此带我走出困境</font><br><font color="1E90FF">你知道，我的姐姐们经常出现在电视上，而她们和名流们共事后，她们会这样说</font><br><font color="DC143C">能和那些杰出的人谈话真的是有趣又令人激动</font><br><font color="1E90FF">那时候作为一个普通的学生的我完全无法理解，不过现在我明白了</font><br><font color="1E90FF">即使是因为一些特殊原因能够在一起，能和那些凭借自身能力做成很多事的人在一起聊一聊就是一件趣事</font><br><font color="1E90FF">我想，可能是这样吧</font><br><font color="8B4513">你很崇拜椿？</font><br><font color="1E90FF">崇拜……</font><br><font color="1E90FF">我想是的</font><br><font color="1E90FF">嗯，我确定是这样</font></p></blockquote><p>现在我脑海里浮现的是一个又一个的OIer <a href="https://oi.yuyuko.cc/">kririae</a> <a href="https://www.hh12.cn/">HigHwind</a> <a href="https://www.goldenpotato.cn/">GoldenPotato</a> <a href="http://www.cnblogs.com/Rye-Catcher">RyeCatcher</a><br>在我眼里，大家真的是一个又一个八重崎椿的存在，要我改编下上面的话来说，就是下面这样：</p><blockquote><p>蓝色是我说的话，棕色是RyeCatcher，HigHwind是红色<br><font color="1E90FF">我觉得作为OIer的追求者很好啊</font><br><font color="1E90FF">开始我从欣赏大佬的角度觉得他们很厉害，现在也是这样认为的，</font><br><font color="1E90FF">但又不仅仅是那样子了，因为他们也是学生</font><br><font color="1E90FF">他们做到了我无法做到的事，教会了我很多事，又能看穿事物</font><br><font color="1E90FF">他们甚至直面难以忘记的痛苦经过</font><br><font color="1E90FF">我越发地认为他们是一群神奇的人，我很高兴有这样的一群人在我身边注视着我，即使仅仅是出于学习原因</font><br><font color="1E90FF">改变自我，是一件既有趣又好玩的事</font><br><font color="1E90FF">而我又很高兴，这样的一群人借此带我走出困境</font><br><font color="1E90FF">你知道，HigHwind经常出现在电视上，而他和名流们共事后，他会这样说</font><br><font color="DC143C">能和那些国家队的人谈话真的是有趣又令人激动</font><br><font color="1E90FF">那时候作为一个普通的学生的我完全无法理解，不过现在我明白了</font><br><font color="1E90FF">即使是因为一些特殊原因能够在一起，能和那些凭借自身能力做成很多事的人在一起聊一聊就是一件趣事</font><br><font color="1E90FF">我想，可能是这样吧</font><br><font color="8B4513">你很崇拜OIer？</font><br><font color="1E90FF">崇拜……</font><br><font color="1E90FF">我想是的</font><br><font color="1E90FF">嗯，我确定是这样</font></p></blockquote><p>欸？！你们别跑啊！∑( 口 || 我没别的意思，就是觉得你们真的很厉害很可爱！我没弯啊！QAQ</p><p>咳咳……总之其实在12话之前，愁对椿的感情其实是一种很正常的友情，其他人的友情其实也有体现，包括为朋友排忧解难，这里就不过多分析了。（因为这里没有什么争议）</p><h2 id="爱情-LGBT"><a href="#爱情-LGBT" class="headerlink" title="爱情/LGBT"></a>爱情/LGBT</h2><p>本作在LGBT方面还算是比较保守的，也许是作者想把这部分留给读者思考吧。我觉得本作讨论的爱情更多的是广义上的，其实这本来就是真实的，如果爱情非要扯到异性，那就不得不提“养育下一代”，而这是一个过程，并不是原因。因此，如果你把一个当代人的爱情观单独抽开来看，可以发现它是与性别无关的，我一直认为性取向是在其他观念里面的东西而非爱情观。</p><p>作者对于爱的理解其实校长已经说出来了：我觉得爱的定义就是让你爱的人幸福快乐。<br>这是从对方角度出发，而从自身角度，葵也说过：毕竟爱情的起因不仅仅是“我爱你”或者“和我约会吧”，那样子的爱情是在绕圈子，而如果你意识到和某一个人在一起总是很快乐很有趣，那样也是爱情的一种开始吧。</p><p>但是其实作者在这上面含糊不清摸棱两可，其实可以看得出来，愁对椿其实是有爱情，但是前面提到过愁其实是性别观念很强的一个人，他可能在心中抑制着自己的爱情，而不断强调这是友情。另一方面，椿由于愁的真心，对愁产生了爱情，但是由于愁的模棱两可，其实最后并没有去成为对方的另一半（只是在最后亲吻了一下而已）</p><p>还有人说最后愁和葵走到了一起，其实我看也不是，葵在独白中提到了他其实曾经是把愁当成是恋爱的替代品，现在无论是什么回答他也接受，而愁这边还是在强调朋友的重要性😂，我看是没戏……</p><p>不过正因为这种含糊的结局导致本作无法上升到一个更高的高度——即如何对待LGBT.椿的态度是只要有爱就行，但是主角呢？真的是钢铁“直男”。对于这样子的结局，我只能强行理解为：“如果双方不是都认可LGBT的话是没有戏的。”这种显而易见的结论……真的是本作的败笔。</p><p>不过尽管如此，本作还是具有启示意义的，作者虽然模棱两可，但是它成功引导读者去思考LGBT的问题（至少我思考了）<br>引用一位网友的评论：“<strong>（这部作品）可以说是LGBT人群的辩白，真正的女装主义者宣言。经典中的经典，弥补人群间的间隔和歧视。</strong>”</p><h2 id="女装的象征含义"><a href="#女装的象征含义" class="headerlink" title="女装的象征含义"></a>女装的象征含义</h2><p>其实这也是主题的一点，后来我才想到的……<br>根据不同人的理解，其实本作的女装可以代表很多含义。<br>其实最概括地来讲，在这部作品里面，<strong>女装象征着资本</strong>。<br>椿一开始就说过他漂亮的女装是他最有力的武器，它可以让愁（包括其他男生）听话。同时，他也讨厌因为他身着女装的可爱而追求他的人，因为他知道，这些人只是喜欢他的女装外表，只是喜欢他的“资本”，当资本消逝的时候，这些人也会离他而去。<br>此外表现这一点的还有人们对资本不计代价的追求（绑架冬麻）</p><p>作品其实也没有深入讨论，我就不再赘述……</p><h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>愁向往椿，包括后面面对之前迫害他的那几名女性的态度的变化可以看出，不过作品也没有深入讨论……</p><h1 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h1><p>其实本作篇幅很短，后面作者也不够走心，所以真的没有什么好评价的，就写个大概吧。<br>|  人物 | 图片  | 评价  | 塑造评分（主观）  |<br>| ———— | ———— | ———— | ———— |<br>| 海棠愁  |  <img src="http://bubbleioa.top/wp-content/uploads/2019/05/%E6%84%81.png"> | 钢铁直男，下意识地抑制自己“不正常”的感情，为人坦诚，可以放心地和这种人做朋友  | 3.2/5  |<br>| 八重崎椿  |  <img src="http://bubbleioa.top/wp-content/uploads/2019/05/%E6%A4%BF.png"> | 本作最喜欢的人物，无论是背景还是感情以及前期的形象都渲染得很好，有那种渐渐看到他的原来的面目但是因此更加喜欢这个角色的感觉 | 4.5/5  |<br>| 松雪冬麻  | <img src="http://bubbleioa.top/wp-content/uploads/2019/05/%E5%86%AC%E9%BA%BB.jpg">  | 心疼，本作最惨角色，被作者当成工具人，作者还说删掉了不少悲伤的情节，性格讨喜，但在该作里并没有塑造的很好  | 3.7/5  |<br>| 夏芽葵  | <img src="http://bubbleioa.top/wp-content/uploads/2019/05/%E5%A4%8F%E8%8A%BD%E8%91%B5.jpg">  | 被作者照顾的角色，情感方面塑造不错，但是那一话过后我以为是个结束，结果到最后还要期待点什么……有点矛盾  | 3.4/5  |<br>| 久我山  | <img src="http://bubbleioa.top/wp-content/uploads/2019/05/%E4%B9%85%E6%88%91%E5%B1%B1.jpg">  | 本作唯一点明了是LGBT人群且拥有了理想生活的人，我觉得把椿映射到他身上，结局应该会好不少（至少不含糊了）  | 不予置评（戏份太少）  |<br>| 校长  | <img src="http://bubbleioa.top/wp-content/uploads/2019/05/%E6%A0%A1%E9%95%BF.jpg">  | 为了自己心爱的女性什么都敢做的人，喜欢这种性格  | 4.0/5  |</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果你看完了漫画，就会发现葵的感情线并没有很好地表达出来（也许是我看太快了），有一话是专门给他内心描写的，但是前面没有很多铺垫感觉很奇怪。后面也没有太多他的描写，但是后日谈的时候又重新提起，我就很懵逼，所以把这条线选择性忽视了，<strong>篇幅短是原罪</strong>(本来篇幅就短，还花了很多笔墨在教你如何女装上，我不是来看这个的啊喂！)。</p><p>留意到后日谈的最后两页（尤其是最有一页），其实感觉作者还是很敷衍，导致了本作的种种问题，心疼冬麻。。。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/hahaha.png"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/eeee.png"> </p><p>由于我是在回来的火车上看的，当时很疲惫了，尽管后面仔细地看了部分心理描写，但还是可能有些地方描述的不准确，见谅。</p><p>怎么说呢，虽然不是特别优秀地一部作品，但是它是第一个让我去思考LGBT人群的作品，尽管我不属于他们，但是如何对待他们是社会的一个共同问题。答案其实真的很简单——有爱就行。但是理解这个答案的过程却是令人费解的，因此有这样的作品真的是太好了，希望每一个LGBT都被温柔以待。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>THUSC2019赛前游记</title>
    <link href="/2019/05/21/THUSC2019%E8%B5%9B%E5%89%8D%E6%B8%B8%E8%AE%B0/"/>
    <url>/2019/05/21/THUSC2019%E8%B5%9B%E5%89%8D%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为什么要叫“赛前游记”？其实我是没有参加THUSC的，只是HH要参加，然后就顺便去THU参观了一下。</p></blockquote><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>做公交到东南门<img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_105720.jpg" alt="清华大学东南门"><br>居然不用任何手续直接进，没有吃早饭，所以直奔食堂而去。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_110623.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_111620.jpg"><br>但是没有卡，又不能用现金，所以没吃到食堂的饭（这一点还是要表扬下南昌大学的），只能去吃汉堡，这是我在北京吃到过的最辣的食物！<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_113624_2.jpg"><br>在吃完人生中最后一次在清华的饭后，打算去朱自清描写的荷塘月色的地方圣地巡礼，不知道是不是因为来的时候不对，完全没有课文中那么优美。</p><blockquote><p>可是热闹是他们的，我什么也没有。</p></blockquote><p><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_120922.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_122352.jpg"></p><p>由于完全没有什么准备，所以基本上就是在清华里面乱逛下面就放些图吧（有些会有点描述）。</p><p>闻一多先生的雕像和纪念他的亭子，这个钟里面被画满了涂鸦……<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_121535.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_121646.jpg"></p><p>考虑到当天是520，就想去一下那个叫做“情人坡”的地方看看有没有情侣（然而并没有）<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_124620.jpg"></p><p>去了下CS系，果然这种机会只有在名校才会有啊……<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_110924.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_132217.jpg"></p><p><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_120704.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_123158.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190520_120351.jpg"></p><p>逛了一下就没有了理智（体力），本来HH也是今天晚上的火车，但是由于THUPC马上就开始，所以就直接在附近住。<br>到宾馆休息（颓）了一下之后，发现时候已经不早，我的这趟旅途也该结束了……</p><p>祝HH在THUPC取得好成绩，<del>还有大家</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>APIO2019主持记</title>
    <link href="/2019/05/12/APIO2019%E4%B8%BB%E6%8C%81%E8%AE%B0/"/>
    <url>/2019/05/12/APIO2019%E4%B8%BB%E6%8C%81%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>刚刚考完 <kbd><a href="http://bubbleioa.top/archives/927">JXOI2019</a></kbd> ，回来还要补上落下的两天文化课，整个人都特别丧，一整天都没和人说过话。尽管APIO迫在眉睫，但完全没有想去准备的欲望，就连交互题也不想练了（之前只做过CF上的交互题的格式）。</p><p>CNBIO2019也在今天考完了，希望我们学校的大佬们好运吧。</p><h1 id="Day-1（报到）"><a href="#Day-1（报到）" class="headerlink" title="Day 1（报到）"></a>Day 1（报到）</h1><p>就当前面几天消失了吧233，其实就是在回归文化课，所以也没啥好写的。坐的是1h的高铁+12h的硬座。去北京的时候感觉还不错，旁边宜阳中学的老师居然主动向我搭话（他原先在我们学校教书），意外地还挺聊的来。我对面坐着的是一对情侣，疯狂发🐕粮，比起回来的时候要好多了……</p><p><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190516_094833.jpg"><br>上午就报了到，拿了狗牌，去宾馆，又去学校吃了中饭。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190516_112423.jpg"><br>饮食不错，没辣椒吃不来。</p><p>下午和另一位主持人@<u><a href="https://www.luogu.org/space/show?uid=20647">AlenaNuna</a></u>面基了。然后就写练习赛，试机的账号密码都是浮莲子233，后面三道原题然而我并不会切，神仙们都是两个小时把题全部切了orz<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190516_145627.jpg"></p><p>晚上见到了室友队爷@<u><a href="https://www.luogu.org/space/show?uid=46019">HigHwind</a></u>，这头像有点不妙吧233  <font color="FFFFFF">（这本子我看过）</font></p><p>了解到他从去年9月份（包括暑假的话是7月份）就开始停课，而且从初三就接触到OI，顿时觉得如果自己进队了反而还不正常。</p><h1 id="Day-2（培训1）"><a href="#Day-2（培训1）" class="headerlink" title="Day 2（培训1）"></a>Day 2（培训1）</h1><p>上午讲的是缓存读入与页面置换，原本以为会讲OI卡常技巧，结果其实是这方面的发展史与算法的发展，还算很有意思的，虽然还是掉了线orz<br>神仙们都在颓《我的世界》、《碧蓝航线》、《明日方舟》、则、各种galgame……然而我手机并没有信号所以只能不断尝试重连。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190517_080144.jpg"><br>中午@<u><a href="https://www.luogu.org/space/show?uid=56384">shadowice1984</a></u>神仙来了我们房，没想到他也退役了(后来APIO 243Au%%%)，强省竞争实在是太激烈了。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190517_140418.jpg"><br>下午是非神仙思路理解dp，神仙们好像不感兴趣就都走了，<u><a href="https://www.luogu.org/space/show?uid=56384">shadowice1984</a></u>和<u><a href="https://www.luogu.org/space/show?uid=46019">HigHwind</a></u>都先回去了(下面是上午下午人数对比图)。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190517_080140.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190517_163425.jpg"><br>下午还遇到了河南省实验中学的hxf（来推销他们学校的OJ的，雾），共同语言大概就是去他们学校培训过吧。</p><p>晚上和HH（指HigHwind，不是指HimeHina XD）交流了一下各自学校对OI的训练支持情况，了解到他来APIO和THUSC都是学校报销的，羡慕QAQ</p><h1 id="Day-3（比赛）"><a href="#Day-3（比赛）" class="headerlink" title="Day 3（比赛）"></a>Day 3（比赛）</h1><p>今年正好是首师大附中的招生咨询会，感觉这肯定是特意这样安排的！<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190518_080937.jpg"><br>练习赛都没有AK就来被锤，发了士力架好评。<br>努力地挣扎到了79pt，由于没有做过前面的APIO的题目，不清楚之前的难度，所以按照往年的分数线还觉得自己能有个Cu。<br>结果听说今年特别水（后来知道Cu都要110+），打铁了QAQ</p><p>考完后神仙们花了30min就讲完了题目，听的半懂不懂，过两天上网看平民题解吧orz</p><p><del>考完后就可以颓废啦！</del>没想到HH也是个War3er，于是就开开心心用手机热点开始一起颓废233，玩了一些2个人不可能过的图（其实是难度选太高了）。</p><h1 id="Day-4（培训2-amp-闭幕式）"><a href="#Day-4（培训2-amp-闭幕式）" class="headerlink" title="Day 4（培训2&amp;闭幕式）"></a>Day 4（培训2&amp;闭幕式）</h1><p>其实昨天晚上就拿到了主持稿的电子稿，但是由于在颓废根本没看，只记得有一个神奇的词叫做 “O I 人”，我脑子里瞬间有了一幅画面（还好这台词不是我读）</p><p>早上刮大风（其实昨天就开始了），呼吸不能。上午由首师大附中的学生讲渲染器，原来不但文化课学有余力，OI都学有余力的吗……真的是tql<br>内容还是挺有意思的，只不过还是掉线了Zzz……</p><p>下午神仙们将树上线性问题，为了主持的时候不出锅，我在大厅里先熟悉下稿子。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2019/05/IMG_20190519_204111.jpg" alt="闭幕式"><br>闭幕式还是比较顺利地进行了，虽然中途还是念错了几个字。<br>Dzd刚从山东赶过来，差点咕咕，所以讲的东西也没啥内容，反倒是王宏讲的很赞，把该吐槽的都吐槽了。<br>虽然相处时间不长，但是和其他主持人们合作的很愉快，江西、山东、北京、上海……为了各自的理想，不同的地方的OIer都来到这里，大家真的很可爱啊ww<br>和其他主持人聊天的过程中才知道原来有个东西叫做市选，我们市只有我一个人参加省选还要不要市选啊2333.</p><p>闭幕式结束后，回宾馆继续和HH颓War3，他也打铁了，比起我来说，他可能更加失落吧。</p><h1 id="Day-5（疏散）"><a href="#Day-5（疏散）" class="headerlink" title="Day 5（疏散）"></a>Day 5（疏散）</h1><p>同<u><a href="http://bubbleioa.top/archives/948">THUSC赛前游记</a></u>的Day1</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[JXOI2017]数列（动态规划）</title>
    <link href="/2019/05/09/%5BJXOI2017%5D%E6%95%B0%E5%88%97%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2019/05/09/%5BJXOI2017%5D%E6%95%B0%E5%88%97%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4063">题面链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目意思有点不好懂，其实就是在数列中找到与 $A_{i-1}$ 相邻的两项来限制 $A_i$ 的值，问方案数。</p><p>首先凭感觉，感觉越往后面的数可能的情况是更少的，整体呈收束趋势。</p><p>我们设用来更新 $A_i$ 的 $L$ 和 $R$ 为 $L_i$ 和 $R_i$ ,根据定义有 $L_{i-1} \leq A_{i-1} \leq R_{i-1}$ ，现在考虑更新 $A_i$ ，根据定义有 $L_{i-1} \le L_i \leq A_{i-1} $ ， $R_{i-1} \ge R_i \ge A_{i-1}$ ，即$ L_{i-1} \leq L_{i}, R_{i-1} \geq R_{i}$ 。</p><p>这种收束的性质会为我们后面的dp转移提供便利。</p><p>考虑设计一个很朴素的状态，即 $f_{i,k,l,r}$ 表示当前填到第 $i$ 个数，$A_1$ 到 $A_{i-1}$ 中小于等于 $k$ 的最大的数为 $l$ ，大于等于 $k$ 的最小的数为 $r$ </p><p>转移时有以下几种情况：</p><ol><li>$k,l,r$ 不相等， $A_{i-1}$ 要么是 $l$ 要么是 $r$ ，</li></ol><p>$$f_{i, k, l, r} = \sum_{j \leq l} f_{i-1, l, j, r}+\sum_{j \geq r} f_{i-1, r, l, j}$$</p><ol start="2"><li>$k=l=r$ </li></ol><p>若 $A_{i-1}=k$ 那么$$f_{i,k, k, k} = \sum_{j \leq k} \sum_{z \geq k} f_{i-1,k, j, z}$$ </p><p>否则，<br>$$f_{i,k,k,k}=\sum_{y\ne k}(\sum_{z\le y}f_{i-1,y,z,k}+\sum_{z\ge y}f_{i-1,y,k,z})$$<br>(y不等于k，不知道为什么latex乱掉了……)</p><p>这个 $O(nr_i^4)$ 的做法肯定会T，可以用前缀和达到 $O(nr_i^3)$ 计算发现过不了，但是实际上最大的点都能过，也许是我时间复杂度算错了吧。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int MOD=998244353;int n;int f[155][155][155];int r[51],maxr;int sl[155][155][155],sr[155][155][155];int main()&#123;    cin&amp;gt;&amp;gt;n;    for(int i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;r[i],maxr=max(maxr,r[i]+1);    for(int i=0;i&amp;lt;=maxr;i++)&#123;        sl[0][i][maxr]=sr[0][0][i]=1;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        memset(f,0,sizeof(f));        for(int j=1;j&amp;lt;=r[i];j++)&#123;            for(int l=0;l&amp;lt;j;l++)                for(int r=j+1;r&amp;lt;=maxr;r++)                    f[j][l][r]=(sl[l][l][r]+sr[r][l][r])%MOD;            for(int r=j;r&amp;lt;=maxr;r++)                f[j][j][j]=(f[j][j][j]+sl[j][maxr][r])%MOD;            for(int k=0;k&amp;lt;=maxr;k++)                if(k!=j)f[j][j][j]=(f[j][j][j]+sl[k][k][j]+sr[k][j][k])%MOD;        &#125;        memset(sl,0,sizeof(sl));        for(int j=1;j&amp;lt;=r[i];j++)            for(int l=0;l&amp;lt;=maxr;l++)                for(int r=j;r&amp;lt;=maxr;r++)                        sl[j][l][r]=(f[j][l][r]+(l==0?0:sl[j][l-1][r]))%MOD;                 memset(sr,0,sizeof(sr));                    for(int j=1;j&amp;lt;=r[i];j++)            for(int l=0;l&amp;lt;=j;l++)                for(int r=maxr;r&amp;gt;=0;r--)                     sr[j][l][r]=(f[j][l][r]+sr[j][l][r+1])%MOD;    &#125;    int ans=0;    for(int i=1;i&amp;lt;=r[n];i++)        for(int l=0;l&amp;lt;=i;l++)            for(int r=i;r&amp;lt;=maxr;r++)                ans=(ans+f[i][l][r])%MOD;    printf(&amp;quot;%d&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JXOI2019退役记</title>
    <link href="/2019/05/09/JXOI2019%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <url>/2019/05/09/JXOI2019%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这是我第一次参加省选，也是最后一次，还是早点占个坑吧~，希望不会咕掉。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>请了个假，一整天都在机房里，与其说是考前复习，不如说是调整下作息吧，其实比起之前晚自习在机房刷题，效率也没高到哪里去，最重要的一点是可以早点睡。要是我在考场上还打瞌睡那可就亏大了。</p><p>争取在考试前两天里再刷14道题把AC数冲到400，考完后打场cf从<font color="00FF00">pupil</font>毕业。</p><p>不过还是想吐槽一点，JXOI2019安排的时间太强了，就在CTS的前一天，而且也没说省选环境，虽然多半是Windows7  </p><p>做了前两年的题目，如果不挂分的话应该能拿到120pt，如果是前两年的话这个成绩还是很稳的，但今年JX多了好多dalao，很慌。</p><p>听说赣州中学的大佬们今天晚上就出发了，我还在机房。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>上午还是去了一下机房，看了一下可持久化Trie，没太理解（明明已经会了主席树），可能是太匆忙的缘故。出来的时候还被门卫拦住……在本子上登记了才让走。<br>途中绕路去看了下学BIO的小伙伴，但是那里没人了，估计是已经出发了吧。</p><hr><p>接下来就是40分钟的公交+50分钟的高铁（第一次坐一等座）+1小时的地铁（第一次坐地铁）……背着电脑好累，不敢想象APIO的时候我还要做12小时的硬座orz</p><hr><p>这时已经是下午了，先去了jkfz，说是4点30才让进，于是先去宾馆放了下东西，再到jkfz<br>环境很好的一所学校，遗憾的是今年不能去吃他们的食堂了……<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/jkfz1.jpg"><br>到了机房，除了键盘手感差一点真的无可挑剔，6代i5 + 8GB 内存，我们学校最新的机房都没这个配置<br><img src="http://bubbleioa.top/wp-content/uploads/2019/05/jkfz2.jpg"><br>确认环境正常后就去找地方吃饭了，今年由于没有收报名费，没在jkzf的食堂吃饭，遗憾QAQ<br>最后在学校旁边一家担担面店吃的，不是很好吃……</p><hr><p>晚上，由于自己是蒟蒻，完全不敢摸鱼，就打算看些掌握不牢固的高级算法，结果看不下去……<br>还是看些基础的内容复习下吧，免得挂分……</p><p>8点多钟的时候还有人从门缝里塞了一张 <code>色情小卡片</code> ，可惜我只对纸片人感兴趣。</p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>晚上教练打呼噜，把我吵醒了大概20分钟，后来起床喝水发出了点响声，教练就不打呼噜了，继续睡觉！</p><p>8点进jkfz，我们考试的时候教练不让进校园，门卫建议教练们去逛商场，事后被我们教练疯狂吐槽。</p><p>我发现我根据去年的情况制定的计划和实际情况完全不一样。<br>APIO推迟，JXOI推迟，以为是可怜题买了件可怜的T恤结果根本不是。考前在练对拍结果根本用不上（都是暴力）。之前想万一退役了省一还是很有用的，现在已经凉了……</p><p>JXOI是只有一天的省选，这样三道题是否合适呢？之前几年的考察内容都很好，有数据结构、组合数学、动态规划、贪心……也许是我太弱了，今年的题目真的是很迷。</p><p>具体情况请看各位大佬们在<kbd><a href="https://www.zhihu.com/question/319749392">知乎上的回答</a></kbd>吧，区别度小是吐槽的原因，估计今年省队名单根据NOIP2018来选都不会有什么差错，就感觉像是大学入学高考占70%，会考占30%，结果高考大家分差都在10分以内，除了给人一种“我还能翻盘”的虚无的希望，这样的考试还有什么意义呢？</p><p>退役了，感觉自己有点像熊巫女（TV版），最后还是自闭儿童，不如傻傻地毫无追求地当一个萌豚活得轻松。之前想打奥赛班，实验班那些提前退役的选手的脸，为此还荒废了一个月的文化课（作业都没动），结果只能换来这样的结局……不是值不值的问题，但是事实摆在这里，谁不会难过呢。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>分数出来了，期望80只拿了40，也许是哪里写挂了吧。不过即使是拿到了80也是进不了队的，按我的NOIP分数来算的话，得要120才能进队。<br>赛后看了下题解，T1树形DP，T2莫比乌斯反演，T3分治统计贡献。</p><p>T1、T2确实是做不出来，莫比乌斯反演我连模板题都没写过，T3的话稍微有点可惜，当时有大致的思路没想到如何统计贡献。</p><p>导致退役没进队的原因有很多，这里就简单列举几个吧：</p><ol><li><p>花的时间不够多<br>真正学奥赛的时间加起来也不过是暑假2m，NOIP前1m，寒假3w，省选前1m（只有晚上）。<br>旁人看来我花了太多时间在奥赛上，被他们说着说着，我好像也这么觉得了，其实和队爷比起来，这都不算什么……</p></li><li><p>信息交流不足<br>直到APIO的时候我才通过我室友知道有一个JXOI的群然后才看了题解。原先的埋头一个人搞奥赛其实只是圈地自萌罢了，我只看到了别人想给我看到的，然而并没有真正地去交流。</p></li><li><p>训练不科学<br>NOIP前其实没有怎么刷其他平台上的题目，都是在自己学校的刷，然后NOIP就只拿了300出头……作为对比，Linz在NOIP前刷了大量的Luogu的题目，NOIP中他也是我们学校中分数最高的。<br>省选前很少正规的考试和比赛，导致省选的时候还挂了40pt，由于还要兼顾文化课，导致我某些知识点不得不放弃（其中就放弃了莫比乌斯反演orz）</p></li></ol><p>真实退役啦！然而刚省选完的我对于OI还只是一个很肤浅的感情，在<kbd><a href="http://bubbleioa.top/archives/936">APIO2019</a></kbd>成长了几天后，才变得更成熟了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[P5343]【XR-1】分块（矩阵快速幂）</title>
    <link href="/2019/05/07/%5BP5343%5D%E3%80%90XR-1%E3%80%91%E5%88%86%E5%9D%97%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/"/>
    <url>/2019/05/07/%5BP5343%5D%E3%80%90XR-1%E3%80%91%E5%88%86%E5%9D%97%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P5343">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF559C] Gerald and Giant Chess（动态规划）</title>
    <link href="/2019/05/06/%5BCF559C%5D%20Gerald%20and%20Giant%20Chess%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2019/05/06/%5BCF559C%5D%20Gerald%20and%20Giant%20Chess%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF559C">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先介绍一个东西：多重集(multiset)的全排列（这里是特殊情况，即选的元素个数不超过任意集合中元素个数的情况）<br>我们定义集合的集合为多重集，比如我有 $a_1$ 个 $1$ ， $a_2$ 个 $2$ …… $a_n$ 个 $n$ 。<br>那么写成多重集就是 [latex]\left{\left{a_1·1\right},\left{a_2·2\right},\cdots,\left{a_n·n\right}\right}[/latex]<br>如果我们要从中取 $k$ 个数（上面说了，$k$ 不大于 $a_i$），那么有多少种方案呢？</p><p>具体证明请移步至<kbd><a href="https://en.wikipedia.org/wiki/Multiset">维基百科</a></kbd>，这里直接给出结论：<br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3085c625fdc63db0b0cf48f07516a78a87109a56" alt="multiset"><br>也就是 $C_{n+k-1}^{n+1}$  </p><p>那么这题其实如果我们把每一行看成一个集合，元素个数就是列数-1（因为我们最终目标是走到右下角，而如果走到了右侧，再走到右下角的方案已经确定，随意等价于走到右侧），如果没有黑格子的话，我们要选的元素个数也是列数-1，答案就是 $C_{H+W-2}^{H-1}$</p><p>而如果有黑格子，我们可以统计出不合法的方案数减去即可。</p><p>所谓不合法，就是在路径上走到过黑格子，为了避免重复，我们设 $f[i]$ 为只经过第 $i$ 个黑格子的方案数，对于它的求法，可以把它当成右下角，求贡献，对于区域内的黑格子，根据乘法原理，它们产生的不合法的方案数为 $f[j]\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}$ 即原点到他的方案数乘上以第 $j$ 个黑格子为左上角，第 $i$ 个黑格子为右下角的子矩阵的方案数。</p><p>具体实现时可以按照坐标排个序，减少枚举量，设右下角为第 $n+1$ 个黑格子，方便计算答案，还有就是不要弄混横纵坐标。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;#define x first#define y secondusing namespace std;typedef long long ll;const int MOD=1e9+7;int h,w,n,ans; pair&amp;lt;int,int&amp;gt;node[2003];ll fact[200003];ll inv[200003];ll f[2003];ll qpow(ll a,ll b,ll p)&#123;    ll ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=ans*a%p;        a=a*a%p;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;void pre(int n)&#123;    fact[0]=1;    for(int i=1;i&amp;lt;=n;i++)&#123;        fact[i]=fact[i-1]*i%MOD;    &#125;    inv[n]=qpow(fact[n],MOD-2,MOD);    for(int i=n-1;i&amp;gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;int C(int n,int m)&#123;    if(n==m)return 1;     return fact[n]*inv[m]%MOD*inv[n-m]%MOD;&#125;int main()&#123;    cin&amp;gt;&amp;gt;h&amp;gt;&amp;gt;w&amp;gt;&amp;gt;n;    for(int i=1;i&amp;lt;=n;i++)&#123;        cin&amp;gt;&amp;gt;node[i].x&amp;gt;&amp;gt;node[i].y;    &#125;    pre(200000);    node[n+1].x=h,node[n+1].y=w;    sort(node+1,node+2+n);    for(int i=1;i&amp;lt;=n+1;i++)&#123;        f[i]=C(node[i].x+node[i].y-2,node[i].x-1);        for(int j=1;j&amp;lt;i;j++)&#123;            if(node[i].x&amp;lt;node[j].x||node[i].y&amp;lt;node[j].y)continue;            f[i]=(f[i]-(ll)f[j]*C(node[i].y-node[j].y+node[i].x-node[j].x,node[i].x-node[j].x)%MOD)%MOD;        &#125;        while(f[i]&amp;lt;0)f[i]+=MOD;    &#125;    cout&amp;lt;&amp;lt;f[n+1]&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[HAOI2016]找相同字符（后缀数组）</title>
    <link href="/2019/05/05/%5BHAOI2016%5D%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <url>/2019/05/05/%5BHAOI2016%5D%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3181">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最近学后缀数组学得有点晕，还是要多练啊。<br>题目就一句话：求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。</p><p>根据容斥原理，只要分别求出两个子串合并后的答案和两个子串单独的答案，最后的答案就是它们相减。</p><p>问题的关键就是如何在可以接受的复杂度内求这个答案。（我一开始连这个答案是什么都不知道）<br>实际上我们要求的是所有子串的lcp的和，可以把它想象成一个枚举起点，长度就是贡献的过程。  </p><p>至于怎么求，其实首先要知道任意两个子串的lcp为它们之间Height数组的最小值，这样用ST表 $O(1)$ 查询可以使得整体复杂度达到 $O(n^2)$</p><p>但这还不够，我们发现，随着枚举的子串字典序增大，Height数组的最小值只会越来越小，于是我们可以用单调栈来维护。</p><p>具体来说，我们设 $f[i]$ 为字典序为 $i$ 的字符串和它之前的字符串产生的贡献，如果它的Height是当前最小的，则 $f[i]$ 为 $Height[i]\times (i-1)$ 而如果不是最小的，那就是上一个比它小的贡献+ $Height[i]\times (i-sk[top])$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int MAXN=2000005;int Height[MAXN],tax[MAXN],tp[MAXN],sa[MAXN],rk[MAXN];int sk[MAXN],f[MAXN];int n,m=127,len1;string s1,s2,str;ll ans1,ans2,ans3;int a[MAXN];void RSort()&#123;    for(int i=1;i&amp;lt;=m;i++)tax[i]=0;    for(int i=1;i&amp;lt;=n;i++)tax[rk[i]]++;    for(int i=1;i&amp;lt;=m;i++)tax[i]+=tax[i-1];    for(int i=n;i&amp;gt;=1;i--)sa[tax[rk[tp[i]]]--]=tp[i];&#125;bool cmp(int *f,int x,int y,int w)&#123;    return f[x]==f[y]&amp;amp;&amp;amp;f[x+w]==f[y+w];&#125;ll Suffix()&#123;    ll ans=0;    for(int i=1;i&amp;lt;=n;i++)rk[i]=a[i],tp[i]=i,f[i]=0;//f数组初始化不要用memset，会T    RSort();int p=0;    for(int w=1;p&amp;lt;n;w+=w,m=p)&#123;        p=0;for(int i=n-w+1;i&amp;lt;=n;i++)tp[++p]=i;        for(int i=1;i&amp;lt;=n;i++)if(sa[i]&amp;gt;w)tp[++p]=sa[i]-w;        RSort();swap(tp,rk);rk[sa[1]]=p=1;        for(int i=2;i&amp;lt;=n;i++)rk[sa[i]]=cmp(tp,sa[i],sa[i-1],w)?p:++p;    &#125;    int k=0,j=0;    for(int i=1;i&amp;lt;=n;Height[rk[i++]]=k)&#123;        for(k=k?k-1:k,j=sa[rk[i]-1];a[i+k]==a[j+k];k++);    &#125;    int top=0;    for(int i=2;i&amp;lt;=n;i++)&#123;        while(top&amp;amp;&amp;amp;Height[sk[top]]&amp;gt;=Height[i])top--;        if(!top)f[i]=Height[i]*(i-1);        else f[i]=f[sk[top]]+Height[i]*(i-sk[top]);        sk[++top]=i;        ans+=f[i];    &#125;    return ans;&#125;void clear()&#123;    memset(sa,0,sizeof(sa));    memset(Height,0,sizeof(Height));    m=127;&#125;int main()&#123;    cin&amp;gt;&amp;gt;s1&amp;gt;&amp;gt;s2;    len1=s1.length();    str=s1+&amp;quot;#&amp;quot;+s2;    n=s1.length();    for(int i=1;i&amp;lt;=n;i++)a[i]=s1[i-1];    ans1=Suffix();    n=s2.length();    for(int i=1;i&amp;lt;=n;i++)a[i]=s2[i-1];    clear();    ans2=Suffix();    n=str.length();    for(int i=1;i&amp;lt;=n;i++)a[i]=str[i-1];    clear();    ans3=Suffix();    cout&amp;lt;&amp;lt;ans3-ans2-ans1&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF427D]Match &amp;amp; Catch(后缀数组)</title>
    <link href="/2019/05/03/%5BCF427D%5DMatch%20&amp;amp;%20Catch(%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84)/"/>
    <url>/2019/05/03/%5BCF427D%5DMatch%20&amp;amp;%20Catch(%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF427D">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目大意：求最小不重复相同子串。</p><p>考虑把两个字符串合并起来，求出sa，rk和Height数组。</p><p>我们可以从小到大枚举子串长度k，然后再枚举后缀。<br>具体来说，我们是根据子串字典序从小到大枚举后缀的<br>如果Height[i]不小于k（即第i-1个子串和第i个子串的最长公共前缀不小于k），<br>并且如果此后缀的起始点在第一个字符串，cnt1++<br>否则cnt2++</p><p>cnt1和cnt2分别代表最长公共子串出现在第一个字符串和第二个字符串的次数，由于是连续更新的，所以假如上一轮cnt1=1，现在更新cnt2=1那么说明这两个子符串有相同的长度大于k的公共子串，但是不是唯一还不知道。<br>也就是说这个数字只在两轮更新中有用，如果cnt1&gt;1或cnt2&gt;1都没有价值了（要么没有公共子串，要么有重复的）。<br>如果要确保唯一性，就要当Height[i]枚举到小于k的时候，如果此时cnt1==1&amp;&amp;cnt2==1的话，则有解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;string s1,s2,str;int len1,tot,m;const int MAXN=10004;int a[MAXN],Height[MAXN],tax[MAXN],tp[MAXN],sa[MAXN],rk[MAXN];void RSort()&#123;    for(int i=1;i&amp;lt;=m;i++)tax[i]=0;    for(int i=1;i&amp;lt;=tot;i++)tax[rk[i]]++;    for(int i=1;i&amp;lt;=m;i++)tax[i]+=tax[i-1];    for(int i=tot;i&amp;gt;=1;i--)sa[tax[rk[tp[i]]]--]=tp[i];&#125;bool cmp(int *f,int x,int y,int w)&#123;    return f[x]==f[y]&amp;amp;&amp;amp;f[x+w]==f[y+w];&#125;void Suffix()&#123;    m=127;    for(int i=1;i&amp;lt;=tot;i++)rk[i]=a[i],tp[i]=i;    int p=0;RSort();    for(int w=1;p&amp;lt;tot;w+=w,m=p)&#123;        p=0;for(int i=tot-w+1;i&amp;lt;=tot;i++)tp[++p]=i;        for(int i=1;i&amp;lt;=tot;i++)if(sa[i]&amp;gt;w)tp[++p]=sa[i]-w;        RSort();swap(rk,tp);rk[sa[1]]=p=1;        for(int i=2;i&amp;lt;=tot;i++)rk[sa[i]]=cmp(tp,sa[i],sa[i-1],w)?p:++p;    &#125;    int j=0,k=0;    for(int i=1;i&amp;lt;=tot;Height[rk[i++]]=k)&#123;        for(k=k?k-1:k,j=sa[rk[i]-1];a[i+k]==a[j+k];k++);    &#125;&#125;bool solve(int k,int div)&#123;    int cnt1=0,cnt2=0;    for(int i=1;i&amp;lt;=tot;i++)&#123;        if(Height[i]&amp;lt;k)&#123;            if(cnt1==1&amp;amp;&amp;amp;cnt2==1)&#123;                return true;                &#125;            cnt1=0;cnt2=0;            if(sa[i]&amp;lt;=div)cnt1++;            else if(sa[i]&amp;gt;=div)cnt2++;            continue;        &#125;        if(sa[i]&amp;lt;=div)cnt1++;        else if(sa[i]&amp;gt;=div)cnt2++;    &#125;    return cnt1==1&amp;amp;&amp;amp;cnt2==1;//如果枚举完了也要判断一下&#125;int main()&#123;    cin&amp;gt;&amp;gt;s1&amp;gt;&amp;gt;s2;    len1=s1.length();    str=s1+&amp;#039;#&amp;#039;+s2;//将两个字符串隔开来，避免sa等数组重叠    tot=len1+s2.length()+1;    for(int i=1;i&amp;lt;=tot;i++)a[i]=str[i-1];     Suffix();//后缀数组    int ans=-1;    for(int i=1;i&amp;lt;=len1;i++)&#123;//枚举长度        if(solve(i,len1))&#123;            ans=i;break;        &#125;    &#125;    printf(&amp;quot;%d\n&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linz的AFO感言（转）</title>
    <link href="/2019/05/03/Linz%E7%9A%84AFO%E6%84%9F%E8%A8%80%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <url>/2019/05/03/Linz%E7%9A%84AFO%E6%84%9F%E8%A8%80%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这个鬼人退役后文化成绩那么好，特意留下他的AFO感言来鞭尸（雾</p><p>[gallery link=”file” size=”medium” ids=”909,910,911,912,913”]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[JXOI2018]游戏 （组合数学）</title>
    <link href="/2019/04/29/%5BJXOI2018%5D%E6%B8%B8%E6%88%8F%20%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89/"/>
    <url>/2019/04/29/%5BJXOI2018%5D%E6%B8%B8%E6%88%8F%20%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4562">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们称当一个数 $k$ 除了它本身的因数不在这个序列里的时候， $k$ 为特异数。</p><p>我们发现，当且仅当我们选完最后一个特异数的时候，整个数列被选完。</p><p>于是枚举每个位置为最后一个特异数的位置计算期望，答案为：</p><p>$$ans=\sum_{i=1}^{n} i\times sum\times C_{n-sum}^{n-i}\times (n-i)! \times (i-1)! $$</p><p>其中 $i$ 为选花费， $sum$ 为特异数的个数 </p><p>求逆元的时候要线性推，要不然会T</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MOD=1e9+7;const int MAXN=10000010;typedef long long ll;ll l,r;ll sum,ans;bool book[MAXN];ll fact[MAXN];ll inv[MAXN];ll qpow(ll a,ll b,ll p)&#123;    ll ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=ans*a%p;        a=a*a%p;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;void pre()&#123;    for(int i=l;i&amp;lt;=r;i++)&#123;        if(book[i])continue;        sum++;        for(int j=i;j&amp;lt;=r;j+=i)&#123;            book[j]=1;        &#125;    &#125;    fact[0]=1;    for(int i=1;i&amp;lt;=r;i++)&#123;        fact[i]=fact[i-1]*i%MOD;    &#125;    inv[r]=qpow(fact[r],MOD-2,MOD);    for(int i=r-1;i&amp;gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;ll C(ll n,ll m)&#123;    if(n&amp;lt;m)return 0;    return fact[n]*inv[n-m]%MOD*inv[m]%MOD;&#125;int main()&#123;    cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;    pre();    ll n=r-l+1;    for(int i=1;i&amp;lt;=n;i++)&#123;        ans=(ans+i*C(n-sum,n-i)%MOD*fact[n-i]%MOD*fact[i-1]%MOD*sum%MOD)%MOD;    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[SDOI2010]古代猪文</title>
    <link href="/2019/04/28/%5BSDOI2010%5D%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/"/>
    <url>/2019/04/28/%5BSDOI2010%5D%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2480">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数论好题，结合了卢卡斯定理，中国剩余定理，费马小定理。</p><p>网上题解很多这里就不细说了，数论我还是要加油呀！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MOD = 999911659;typedef long long ll;ll p[5] = &#123;0, 2, 3, 4679, 35617&#125;;ll fact[40003];ll a[5];ll exgcd(ll a, ll b, ll &amp;amp;x, ll &amp;amp;y)&#123;    if (b == 0)    &#123;        x = 1, y = 0;        return a;    &#125;    ll d = exgcd(b, a % b, x, y);    ll z = x;    x = y;    y = z - (a / b) * y;    return d;&#125;ll mul(ll a, ll b, ll mod)&#123;    ll ans = 0;    while (b)    &#123;        if (b &amp;amp; 1)            ans = (ans + a) % mod;        a = (a + a) % mod;        b &amp;gt;&amp;gt;= 1;    &#125;    return ans;&#125;ll excrt()//想练excrt于是就写了ex的，其实普通的crt就可以&#123;    ll ans = 0;    ll lcm = 1;    ll x, y;    for (int i = 1; i &amp;lt;= 4; i++)    &#123;        ll lx = lcm;        ll ly = p[i];        ll r = (a[i] - ans % p[i] + p[i]) % p[i];        ll d = exgcd(lx, ly, x, y);        ll k = mul(x, (r / d), p[i]);        ans += k * lcm;        lcm = lcm / d * p[i];        ans = (ans % lcm + lcm) % lcm;    &#125;    return ans;&#125;ll qpow(ll a, ll b, ll p)&#123;    ll ans = 1;    while (b)    &#123;        if (b &amp;amp; 1)            ans = ans * a % p;        a = a * a % p;        b &amp;gt;&amp;gt;= 1;    &#125;    return ans;&#125;ll C(ll n, ll m, ll p)&#123;    if (n &amp;lt; m)        return 0;    return fact[n] * qpow(fact[n - m], p - 2, p) % p * qpow(fact[m], p - 2, p) % p;&#125;ll lucus(ll n, ll m, ll p)&#123;    if (n &amp;lt; m)        return 0;    if (n == 0)        return 1;    return lucus(n / p, m / p, p) * C(n % p, m % p, p) % p;&#125;void pre(ll p)&#123;    fact[0] = 1;    for (ll i = 1; i &amp;lt;= p; i++)    &#123;        fact[i] = fact[i - 1] * i % p;    &#125;&#125;int main()&#123;    ll q, n;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;    if (q == MOD)    &#123;        cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;        return 0;    &#125;    for (ll k = 1; k &amp;lt;= 4; k++)    &#123;        pre(p[k]);        for (ll i = 1; i * i &amp;lt;= n; i++)        &#123;            if (n % i == 0)            &#123;                a[k] = (a[k] + lucus(n, i, p[k])) % p[k];                if (i * i != n)                    a[k] = (a[k] + lucus(n, n / i, p[k])) % p[k];            &#125;        &#125;    &#125;    cout &amp;lt;&amp;lt; qpow(q, excrt(), MOD) &amp;lt;&amp;lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>漩涡</title>
    <link href="/2019/04/28/%E6%BC%A9%E6%B6%A1/"/>
    <url>/2019/04/28/%E6%BC%A9%E6%B6%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人们生活在漩涡之中，大多数时候人们会顺着漩涡漂流，但有时会受到不公平的待遇，于是想反抗这漩涡。成败固然重要，但可悲的是，现在很多人都失去了反抗的意志，成为了漩涡的一部分。</p><blockquote><p>“凡是反人性的，不公的，你都可以在你的文章中批判，高考作文如此，平时写文章更可如此” ——CDQZ李老</p></blockquote><p>笔者只是这个世界上的沧海一粟，主要批判的是自己周围发生的一些事情，虽然可能很幼稚，很无逻辑，但是可以肯定的一点是，我批判的对象肯定是反人性的或不公的。</p><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>半期考试结束了，也快省选了，总有一种不好的预感，总觉得要“赔了夫人又折兵”。身边退役的OIer文化课都恢复地不错，yanyu在我们班都rank8了，Linz在奥赛班都rank2去了（虽然现在奥赛班有十多个人都在生物奥赛停课中）。</p><p>“近几年是我们学校最支持奥赛的几年。”今天听到我们班主任的惊人发言，我真的想好好讲讲学校是多么“支持”奥赛的。</p><p>18届，分班的时候奥赛班和A班平均分一样，“合情合理”的，奥赛班在每次考试的要求都是与A班相平，也就是说要让奥赛班的学生每天拥有28个小时或者睡眠效率提高3倍。<br>“大多数”学生都做不到，那怎么办呢？学校觉得奥赛不至于占用这么多时间，充其量就是“锦上添花”的作用，说白了就是给学生一套“时装”，“皮肤”，拿到省二就是“钻石段位”，省一就是“最强王者”。这也说的过去，因为平均每天不到1小时的学习时间，能进省队除非你是卢本伟。</p><p>学校当然也不希望“卢本伟”出现在自己学校，以免“败坏”了学校的名声。<br>于是呢，学奥赛的时间被大幅度打压，就是那种你即使有“外挂”，也用不出来的那种。<br>一周学奥赛的时间大概是： 2h(周1)+2h(周3)+3h(周6)=7h(一周)<br>也就是 1 h/day  </p><p>当然，太过压迫也不好，于是每到联考前，奥赛还允许停一个月的课，这有多久呢？<br>30day，但是我们学校是没有双休的，如果那些有双休的学校每周多拿出1天学奥赛呢？一年就有52day！<br>而且停课30day是会影响文化成绩的，也要花更多时间去补，而每周抽出1天来，对于大多数学生都不会有太大负担（指有双休的学校）</p><p>既然制度上这么不支持，那么财政上呢？</p><p>官方说：“国赛才报销。”</p><p><strong>重大消息！笔者将给第一个前往仙女座的宇航员报销全额费用！</strong></p><p>实际上，联赛和省选也会报销，但是这些钱真的是杯水车薪，尤其是今年年初的破事之后，这些费用真的不贵……</p><p>至于WC/APIO/CTSC，是要全额自费的，当然，如果你有幸获奖，学校也会毫不吝啬地把你的名字挂到喜报上去。</p><p>暑假上奥赛教练的工资甚至还要我们来出……</p><p>好吧好吧，搞奥赛又不是差这些钱，重要的还是学习。那么学校提供的学习环境怎么样呢？</p><p>机房很大，开一个空调完全没感觉的那种。电脑没一个能用，基本上就是把电脑的网线、显示屏、鼠标、键盘拆下来，连到自己的笔记本上用。之前直接向校长提出要奥赛专用机房，结果校长都没记在本子上。</p><hr><p>学校的态度很明显，奥赛是用来自招的，管你是兴趣还是什么奥林匹克精神，奥赛教练和学生都是工具人，干好分内的，不要想有的没的。你上进，吃力不讨好，每天混下日子，也就那么过去了。我们教练多次想去当年级干士，因为带奥赛又辛苦又没好处。之前的奥赛表彰大会上，说什么十个左右省一就是“全面开花”，希望得奖的同学在文化课上“继续努力”。</p><hr><p>好在我们班主任还是很支持的，最近每天晚上都在机房刷题，现在平均每天有4小时左右学奥赛的时间，但是之前落下来的东西太多，我们学校又只有我一个人在准备省选，现在学的也不知道怎么样。</p><p>如果5月省选我没进省队呢？学校不可能去改变政策。尽管我的学弟们很聪明，但是在这种政策下，想进省队是很难的。</p><p>即便进了省队，学校又会有什么很大的改变吗？也不见得。</p><p>能坚持到现在，也是源于自己的喜欢，以及想反抗学校这种迫害奥赛生的行为。</p><p>这里补充一段来自<a href="http://bubbleioa.top/archives/908">Linz的AFO感言</a>里的内容，部分错别字有修改</p><blockquote><p>终于，复赛后我取得了我们学校第一，江西省19（除去高三）的成绩，顿时觉得省选是有希望的。但文化课落后了很多，就补了一个多月的文化课，奥赛基本上没怎么动过。在这期间，我了解到学校对我们奥赛是多么“重视”，就连补课的事都拖了一个礼拜，甚至有管理层的人竟然还不打算给我们补课，实在是凉透了我们的心。出乎我的意料，我竟然入选了ccf的冬令营。之后，每天又开始拼命地学奥赛。班主任不允许我们在晚自习使用电脑，就连去机房都不行<del>他甚至还让我们不要用电脑，<strong>用纸写代码</strong>（滑稽）[1]</del>。为了学奥赛，我趁自己还坐在最后一排，每天晚自习把电脑放在桌子底下，偷偷看博客学知识，也不怕被抓，还觉得自己赚大发了。就这样过了一段时间，抱着可以逃过一次期末考地想法，我踏上了前往广州的高铁。</p></blockquote><p>[1]：补充一点，xf（我们学校另一位大佬）还去找他们班主任理论，结果被骂哭了。</p><p>虽然很想吐槽这想小学生的作文水平<del>我也好不到哪里去</del>，但是最朴实不加修饰的语言，才能看到最真实的学校。</p><p>10多年前，我们学校还有人靠奥赛保送，成绩也是名列江西省前茅。为什么会变成现在这样呢？这不是我该反思的问题，我只是在这里待3年，而我们学校却存在100年了，我相信学校不是没有这样的能力，而是想不想背负更多的责任和义务。</p><blockquote><p>第一章更新与5月1日</p></blockquote><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>也不知是好消息还是坏消息，五一假期有两天，比往常多了一天。但真正留下来能搞奥赛的时间真的不多，还有省选前最后一场CF(不过Educational R是真的有阴影)</p><p>这两天我可以安排写作业，也可以搞奥赛，但都不能都做，如果有4天的话应该还是游刃有余的。</p><p>我肯定会选择后者，但我相知道为什么我会选后者，这些事是我平常压根不会去想的。</p><hr><p>记得开学的时候,班上讨论得最多的就是《流浪地球》，大部分人围绕着中国科幻电影的角度聊着，某位大佬的讨论引起了我的兴趣（剧透警告）：<del>地球上的人们团结一心想点燃木星大气，失败了，最后还是靠一名宇航员和一个空间站的代价点燃了，那为什么不一开始直接这样做，省的费那么大的力气呢？</del></p><p>其实这个问题应该是看完很久后才会去想的，因为电影里的情节安排不会让你认为这样是不合理的。但是这个问题确实有思考的价值。</p><p><strong>人会坚持自己之前一直所努力做的事情。</strong>说的积极一点是坚持，消极一点是惰性，又或是因为深信着”坚持努力就会有回报“这种鬼话。总之，在当下这个时代，这种品质应该来说是不好的吧。</p><p><strong>人总是会贪心地看问题。</strong>所谓贪心，其实就是目光放的比较近，没那么长远。这里并没有贬义地成分，相反，贪心地去解决问题有时能剩下不少决策时间致使结果朝着更好的方向发展。</p><hr><p>从我们学校重新搞信息学奥赛到我这一届是第三届，之前我们学校有人因为信息学奥赛直接受益吗？没有，Linz的哥哥（已经毕业）去了西安交大，还是靠高校专项降了60（其实裸分也能上，总之和信奥没有直接关系），还有几个学长（快要毕业）只有省一，他们文化成绩都很好，今年名校政策又这样，基本上就是很难发挥自招的作用。</p><p>而我，面对这样的情况，任选择希望。</p><p>这不是深谋远虑的结果，这也不是贪心的结果，这个决定是来源于人类本源的情感，无逻辑的。我并不是没去想选择后者的原因，而是这种情感没有办法用理性的语言所表述罢了。</p><p>人类的历史上从来不缺少希望。面对波斯压倒性的优势，斐力庇第斯还是将马拉松平原的捷报传到雅典。面对德国的铁骑，苏军背靠着莫斯科，守卫着家园。</p><p>我希望我能在奥赛方面取得理想的成绩；我希望学校能改变制度，培养出真正的人才；</p><p>我希望所有读到这篇文章的读者们，对你坚守的，对你喜欢的，对你讨厌的，都抱有希望，不要放弃。</p><p>只要不断前行，道路就会不断延伸下去……</p><blockquote><p>第二章写于5月1日</p></blockquote><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>这里想讲讲我们的奥赛教练，在一个本来没有任何希望的弱省弱校，他为我们付出了很多，能发展成今天这样已经很不容易了（就像初生演替一样）。我们都很喜欢我们的奥赛教练，上个元宵节我们学生还一起商量出钱请教练出去吃饭（在一般的人都退役了的情况下，全员到齐了）。</p><p>但作为教练，他的几种做法我还是不认同的（尽管这里面有些是学校的原因）。</p><p>首先就是太强调天赋。</p><p>如果是前期刚招来学生的时候说说无妨，无非就是劝退那些不是真正想要学奥赛的人。</p><p>但是我们奥赛教练至始至终都在说什么奥赛看天赋，什么生源不够好。这确实是实事，但对学生说这些，能改变什么吗？什么都改变不了！反而会带来消极影响。</p><p>就举个例子来说吧，之前在常州培训（包括在郑州也是）的时候被虐爆，结果大家都觉得是自己天赋比其他人差，其他人学的好是因为天赋好。错！这个结论对了一半，但思考的方向完全错了。我们当时完全没有想过别人强是因为别人比我们多了10倍的刷题量，只是觉得别人比我小开始学，而且比我有天赋。</p><p>当初教练给我们举hzwer的励志故事来告诉我们学奥赛要努力，于是我们把hzwer的800题看成最高标准。孰不知各位dalao一个个都是1k+的恐怖题量，彩虹猫的3k+更是一个天文数字。</p><p>还有一点就是太看重文化成绩。</p><p>如果我们学校有双休，奥赛训练模式和CDQZ，长郡中学一样，我觉得是可以做到两开花的，但在我们学校不行。</p><p>这样的做法，最终落得暑假学了一暑假奥赛文化课还考rank1的dalao（上一届学长），NOIP2017也只有295分（可能记错了，但就在这个分数左右）</p><p>扯远了一点说，在人大的<a href="https://oi.men.ci/">Menci</a>，高三回归文化课的时候不也只有467，但是高考也很厉害啊。在哈工大的<a href="http://ruanx.pw/">阮行止</a>，停了两年课，高考不也有630+</p><p>就拿最近的一点来说，linz在班上rank2，yy在班上也有rank8，在奥赛的赛场上经历过风吹雨打的OIer岂是文化课能打倒的？奥赛教练可能也想过这样做，但面临着多方面的压力。</p><p>教练看重文化成绩+家长看重文化成绩+班主任看重文化成绩，在这种情况下，谁能看重奥赛呢？（除非你像我一样头铁）</p><p>我们教练不是一个只想让我们拿个省一就了事的教练，在这样一个小城破校能遇到这样一位教练是我福报（不含贬义），我们教练已经做到了在这个制度下最好的结果，想要有所突破，还需要更多头铁的学生“牺牲”自我来发起“革命”。</p><blockquote><p>第三章写于2019年5月3日，五四运动100周年前一天</p></blockquote><h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>开学的时候学校修了一座公园，虽然学生基本不会到那里去，但是毕竟没什么影响，所以大部分人都把它忘了。  </p><p>然后就是原先从来没有收过的空调维护费开始收了（之前只收电费），虽然不知道为什么这种东西隔了4年才开始收，但毕竟大家都用了空调，这钱叫就交吧。</p><p>四月份各大高校自招简章都出来了，可以看出自招正在收紧，我有种不好的预感。</p><p>果然，原本奥赛的联赛和省选都可以报销路费，住宿费的，现在取消了。那学校留给我们的还有什么呢？就信息学奥赛来说，不过是一个遮蔽风雨的房间和电、网罢了。相较之下，九中投入的支持要比我们大得多，OJ用的都是学校官网的服务器。</p><blockquote><p>第四章写于5月6日</p></blockquote><h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p>咕咕咕<br>关键词 停电</p><h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><p>咕咕咕<br>关键词 wlzbjxb 洋务运动</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1155 Educational Codeforces Round 63]题解合集</title>
    <link href="/2019/04/24/%5BCF1155%20Educational%20Codeforces%20Round%2063%5D%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/"/>
    <url>/2019/04/24/%5BCF1155%20Educational%20Codeforces%20Round%2063%5D%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>2小时6道题，所以请记住，对于cf比赛，<strong>犹豫就会败北，果断就会白给</strong></p><h1 id="CF1155A-Reverse-a-Substring"><a href="#CF1155A-Reverse-a-Substring" class="headerlink" title="CF1155A Reverse a Substring"></a><a href="https://www.luogu.org/problemnew/show/CF1155A">CF1155A Reverse a Substring</a></h1><p>如果字符大小非严格单增，显然无解，如果出现前面字符大于后面的字符的情况，输出它们的位置即可。</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n;string str;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;str;char last=str[0];int pos=0;    for(int i=1;i&amp;lt;str.length();i++)&#123;        if(last==str[i])&#123;pos=i;continue;&#125;        if(last&amp;lt;str[i])&#123;last=str[i];pos=i;&#125;        else &#123;            printf(&amp;quot;YES\n%d %d&amp;quot;,pos+1,i+1);            return 0;        &#125;    &#125;    printf(&amp;quot;NO&amp;quot;);    return 0;&#125;</code></pre><h1 id="CF1155B-Game-with-Telephone-Numbers"><a href="#CF1155B-Game-with-Telephone-Numbers" class="headerlink" title="CF1155B Game with Telephone Numbers"></a><a href="https://www.luogu.org/problemnew/show/CF1155B">CF1155B Game with Telephone Numbers</a></h1><p>一开始还以为是博弈论（<del>我傻了</del>）……结果一个简单的贪心就OK了</p><p>一轮游戏会将数字取到只剩11个，如果序列中前 $n-10$ 个元素中，8的数量大于其他的数量，那么显然先手会把其中不是8的取完，先手必胜。如果不大于，后手会把所有的8取完，先手必败。</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n;int a[100005]; int main()&#123;    cin&amp;gt;&amp;gt;n;int cnt=0;    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%1d&amp;quot;,&amp;amp;a[i]);    for(int i=1;i&amp;lt;=n-10;i++)&#123;         if(a[i]==8)cnt++;         else cnt--;    &#125;    if(cnt&amp;gt;0)printf(&amp;quot;YES\n&amp;quot;);    else        printf(&amp;quot;NO\n&amp;quot;);    return 0;&#125;</code></pre><h1 id="CF1155C-Alarm-Clocks-Everywhere"><a href="#CF1155C-Alarm-Clocks-Everywhere" class="headerlink" title="CF1155C Alarm Clocks Everywhere"></a><a href="https://www.luogu.org/problemnew/show/CF1155C">CF1155C Alarm Clocks Everywhere</a></h1><p>我们要找到一个 x和d 使得 $x+kd = a_i$  k为正整数</p><p>如果我们的时间累积到 $a_i$ 了，那么我们其实就是要满足 $a_i+kd=a_{i+1}$ 即 $a_{i+1}-a_i=kd$</p><p>所以我们就是要用一个间隔来遍历到所有时间点，这个间隔显然是所有相邻时间间隔的gcd，记为d</p><p>然后看看第二行里面有没有d的约数，有的话就输出</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int MAXN=300003;int n,m;ll x,d,z;ll gcd(ll a,ll b)&#123;    return b?gcd(b,a%b):a;&#125;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    scanf(&amp;quot;%lld&amp;quot;,&amp;amp;x);    for (int i=1;i&amp;lt;n;i++) &#123;        scanf(&amp;quot;%lld&amp;quot;, &amp;amp;z);        d=gcd(d,abs(z-x));    &#125;    for(int i=1;i&amp;lt;=m;i++)&#123;        ll p;cin&amp;gt;&amp;gt;p;        if(d%p==0)&#123;            printf(&amp;quot;YES\n%lld %d&amp;quot;,x,i);            return 0;        &#125;    &#125;    printf(&amp;quot;NO&amp;quot;);    return 0;&#125;</code></pre><h1 id="CF1155D-Beautiful-Array"><a href="#CF1155D-Beautiful-Array" class="headerlink" title="CF1155D Beautiful Array"></a><a href="https://www.luogu.org/problemnew/show/CF1155D">CF1155D Beautiful Array</a></h1><p>其实就是最长连续子串的变形。</p><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>$s$</td><td>$s_i$ 表示整个序列乘上 $x$ 后的前缀和</td></tr><tr><td>$L$</td><td>$L_i$ 表示 $i$ 位置<strong>往前</strong>的最大连续子串和</td></tr><tr><td>$R$</td><td>$R_i$ 表示 $i$ 位置<strong>往后</strong>的最大连续子串和</td></tr></tbody></table><p>假如我们选择了 $i$ 到 $j$ ($j\le i$) 这一段乘上 $x$ 那么答案就为 $$s[i]-s[j-1]+R[i+1]+L[j-1]$$</p><p>我们可以枚举 $s[i]+R[i+1]$ ，用 $max(L[j-1]-s[j-1])$ 来更新答案</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;ll a[300005];ll s[300005],L[300005],R[300005];int main() &#123;    int n;ll x;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;x;    ll ans=0;    for (int i=1; i&amp;lt;=n; i++) &#123;cin&amp;gt;&amp;gt;a[i];ans+=a[i];s[i]=x*a[i];s[i]+=s[i-1];&#125;    ans=max(ans,0LL);    for (int i=1; i&amp;lt;=n; i++) L[i]=max(L[i-1]+a[i],0LL);    for (int i=n; i&amp;gt;=1; i--) R[i]=max(R[i+1]+a[i],0LL);    ll mx=-1LL&amp;lt;&amp;lt;62;    for (int i=1; i&amp;lt;=n; i++) &#123;        mx=max(mx,L[i-1]-s[i-1]);        ans=max(ans,R[i+1]+s[i]+mx);    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OSU三连！（期望）</title>
    <link href="/2019/04/19/OSU%E4%B8%89%E8%BF%9E%EF%BC%81%EF%BC%88%E6%9C%9F%E6%9C%9B%EF%BC%89/"/>
    <url>/2019/04/19/OSU%E4%B8%89%E8%BF%9E%EF%BC%81%EF%BC%88%E6%9C%9F%E6%9C%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>三道一样的题目，所以放一起了</p></blockquote><h1 id="P1365-WJMZBMR打osu-Easy"><a href="#P1365-WJMZBMR打osu-Easy" class="headerlink" title="[P1365] WJMZBMR打osu! / Easy"></a><a href="https://www.luogu.org/problemnew/show/P1365">[P1365] WJMZBMR打osu! / Easy</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> &amp;lt;bits/stdc++.h&amp;gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string str;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">double</span> x[<span class="hljs-number">1000003</span>], ans[<span class="hljs-number">10000003</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &amp;gt;&amp;gt; n;<br>    cin &amp;gt;&amp;gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &amp;lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">double</span> p = <span class="hljs-number">0.5</span>;<br>        <span class="hljs-keyword">if</span> (str[i - <span class="hljs-number">1</span>] == &amp;#<span class="hljs-number">039</span>;o&amp;#<span class="hljs-number">039</span>;)<br>            p = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i - <span class="hljs-number">1</span>] == &amp;#<span class="hljs-number">039</span>;x&amp;#<span class="hljs-number">039</span>;)<br>            p = <span class="hljs-number">0</span>;<br>        x[i] = (x[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) * p;<br>        ans[i] = ans[i - <span class="hljs-number">1</span>] + (x[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * p;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;quot;%<span class="hljs-number">.4</span>lf&amp;quot;, ans[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="CF235B-Let’s-Play-Osu"><a href="#CF235B-Let’s-Play-Osu" class="headerlink" title="[CF235B]Let’s Play Osu!"></a><a href="https://www.luogu.org/problemnew/show/CF235B">[CF235B]Let’s Play Osu!</a></h1><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> &amp;lt;bits/stdc++.h&amp;gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">double</span> x[MAXN], ans[MAXN];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &amp;gt;&amp;gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &amp;lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">double</span> p;<br>        cin &amp;gt;&amp;gt; p;<br>        x[i] = (x[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) * p;<br>        ans[i] = ans[i - <span class="hljs-number">1</span>] + (x[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * p;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;quot;%<span class="hljs-number">.15</span>lf&amp;quot;, ans[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1654-OSU"><a href="#P1654-OSU" class="headerlink" title="[P1654]OSU!"></a><a href="https://www.luogu.org/problemnew/show/P1654">[P1654]OSU!</a></h1><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> &amp;lt;bits/stdc++.h&amp;gt;</span><br><span class="hljs-keyword">double</span> x[<span class="hljs-number">100003</span>][<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    std::cin &amp;gt;&amp;gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &amp;lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">double</span> p;<br>        std::cin &amp;gt;&amp;gt; p;<br>        x[i][<span class="hljs-number">0</span>] = (x[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * p;<br>        x[i][<span class="hljs-number">1</span>] = (x[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">2</span> * x[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * p;<br>        x[i][<span class="hljs-number">2</span>] = x[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + (<span class="hljs-number">3</span> * (x[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + x[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>) * p;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;quot;%<span class="hljs-number">.1</span>lf&amp;quot;, x[n][<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1151C]Problem for Nazar(倍增)</title>
    <link href="/2019/04/19/%5BCF1151C%5DProblem%20for%20Nazar(%E5%80%8D%E5%A2%9E)/"/>
    <url>/2019/04/19/%5BCF1151C%5DProblem%20for%20Nazar(%E5%80%8D%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1151/problem/C">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这次的题目真的都还挺不错的，考的比较活<br><strong>two times more</strong>这个关键信息告诉我们序列变化的规律，即为 $2^i$ 变换一次<br>于是我们可以考虑倍增  </p><p>我们用 $s[i]$ 来表示第1到i段(每一次变化称为一段)的数字和<br>$ls1$ 为奇数序列，$ls2$ 为偶数序列<br>$lst1$ 表示当前奇数序列的首项，$lst2$ 同理  </p><p>假设现在计算第i段的值（假设是奇数段，偶数段同理）  </p><p>我们就有：</p><ul><li>首项：$lst1$</li><li>末项：$lst1+(2^{i-1})\times 2$</li><li>项数：$2^{i-1}$</li></ul><p>于是得到值为：<br>$$(lst1+2^{j-1}-1)\times 2^{i-1}$$</p><p>预处理完之后我们就可以处理查询啦（与上面同理）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int MAXN = 61;ll l, r;ll p[MAXN], s[MAXN], l1[MAXN], l2[MAXN];ll calc(ll x)&#123;    for (int i = 60; i &amp;gt;= 0; i--)    &#123;        if (p[i] &amp;lt;= x)        &#123;            if (i &amp;amp; 1)                return (s[i] + ((l2[i] + x - p[i] - 1) % mod) * ((x - p[i]) % mod)) % mod;            return (s[i] + ((l1[i] + x - p[i] - 1) % mod) * ((x - p[i]) % mod)) % mod;        &#125;    &#125;    return 0;&#125;void pre()&#123;    ll lst1 = 1, lst2 = 2;    l1[0] = 1, l2[0] = 2;    for (int i = 1; i &amp;lt;= 60; i++)    &#123;        p[i] = p[i - 1] + (1ll &amp;lt;&amp;lt; (i - 1));        if (i &amp;amp; 1)        &#123;            s[i] = (s[i - 1] + ((lst1 + (1ll &amp;lt;&amp;lt; i - 1) - 1) % mod) * ((1ll &amp;lt;&amp;lt; i - 1) % mod)) % mod;            lst1 += 1ll &amp;lt;&amp;lt; i;        &#125;        else        &#123;            s[i] = (s[i - 1] + ((lst2 + (1ll &amp;lt;&amp;lt; i - 1) - 1) % mod) * ((1ll &amp;lt;&amp;lt; i - 1) % mod)) % mod;            lst2 += 1ll &amp;lt;&amp;lt; i;        &#125;        l1[i] = lst1, l2[i] = lst2;    &#125;&#125;int main()&#123;    pre();    cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;    cout &amp;lt;&amp;lt; ((calc(r) - calc(l - 1)) % mod + mod) % mod &amp;lt;&amp;lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1151D]Stas and the Queue at the Buffet(贪心)</title>
    <link href="/2019/04/19/%5BCF1151D%5DStas%20and%20the%20Queue%20at%20the%20Buffet(%E8%B4%AA%E5%BF%83)/"/>
    <url>/2019/04/19/%5BCF1151D%5DStas%20and%20the%20Queue%20at%20the%20Buffet(%E8%B4%AA%E5%BF%83)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1151/problem/D">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN = 100005;typedef long long ll;ll a[MAXN], b[MAXN];ll pos[MAXN];ll n, ans;bool cmp(int i, int j)&#123;    return a[i] - b[i] &amp;gt; a[j] - b[j];&#125;int main()&#123;    cin &amp;gt;&amp;gt; n;    for (int i = 1; i &amp;lt;= n; i++)    &#123;        cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];        pos[i] = i;    &#125;    sort(pos + 1, pos + 1 + n, cmp);    for (int i = 1; i &amp;lt;= n; i++)    &#123;        ans += a[pos[i]] * (i - 1) + b[pos[i]] * (n - i);    &#125;    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1151B]Dima and a Bad XOR(思维题)</title>
    <link href="/2019/04/19/%5BCF1151B%5DDima%20and%20a%20Bad%20XOR(%E6%80%9D%E7%BB%B4%E9%A2%98)/"/>
    <url>/2019/04/19/%5BCF1151B%5DDima%20and%20a%20Bad%20XOR(%E6%80%9D%E7%BB%B4%E9%A2%98)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1151/problem/B">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>学OI学傻了，一开始想到一个 $O(m^n)$ 的暴力，显然是过不了的，后面想到一个 $O(2^nm)$ 的做法，就没思路了</p><p>其实正解很简单。</p><p>我们先取好一组（这里默认就是第一列），如果它的值大于0，那就是答案了，输出即可。</p><p>如果不大于0，它的值肯定就为0了，对于每一行，如果能找到一个数与当前所选的数不一致的数，那就选它（因为它们的二进制数肯定不同，当前异或和为0，换一个不一样的数，疑惑和就肯定大于0了）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int ma[503][503];int sel[501];int n, m;int cur;void out()&#123;    printf(&amp;quot;TAK\n&amp;quot;);    for (int i = 1; i &amp;lt;= n; i++)        printf(&amp;quot;%d &amp;quot;, sel[i]);    exit(0);&#125;int main()&#123;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;    for (int i = 1; i &amp;lt;= n; i++)    &#123;        for (int j = 1; j &amp;lt;= m; j++)        &#123;            cin &amp;gt;&amp;gt; ma[i][j];            sel[i] = 1;        &#125;        cur ^= ma[i][1];    &#125;    if (cur &amp;gt;= 1)    &#123;        printf(&amp;quot;TAK\n&amp;quot;);        for (int i = 1; i &amp;lt;= n; i++)            printf(&amp;quot;%d &amp;quot;, sel[i]);        exit(0);    &#125;    for (int i = 1; i &amp;lt;= n; i++)    &#123;        for (int j = 1; j &amp;lt;= m; j++)        &#123;            if (ma[i][j] != ma[i][1])            &#123;                sel[i] = j;                out();            &#125;        &#125;    &#125;    printf(&amp;quot;NIE&amp;quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[JXOI2018]守卫（dp）</title>
    <link href="/2019/04/18/%5BJXOI2018%5D%E5%AE%88%E5%8D%AB%EF%BC%88dp%EF%BC%89/"/>
    <url>/2019/04/18/%5BJXOI2018%5D%E5%AE%88%E5%8D%AB%EF%BC%88dp%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4563">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><del>要是今年也有这么简单的题目就好了</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN = 5003;int f[MAXN][MAXN];int n;int h[MAXN];bool check(int x, int mid, int y)&#123;    double k1 = (h[mid] - h[x]) / (mid - x);    double k2 = (h[y] - h[mid]) / (y - mid);    return k1 &amp;lt; k2;&#125;int main()&#123;    cin &amp;gt;&amp;gt; n;    for (int i = 1; i &amp;lt;= n; i++)        cin &amp;gt;&amp;gt; h[i];    for (int i = 1; i &amp;lt;= n; i++)    &#123;        f[i][i] = 1;        f[0][0] ^= f[i][i];        int mid = 0;        for (int j = i - 1; j &amp;gt;= 1; j--)        &#123;            if (!mid || check(j, mid, i))                mid = j;            f[j][i] = min(f[j][mid - 1], f[j][mid]) + f[mid + 1][i];            f[0][0] ^= f[j][i];        &#125;    &#125;    cout &amp;lt;&amp;lt; f[0][0] &amp;lt;&amp;lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[P4310]绝世好题</title>
    <link href="/2019/04/18/%5BP4310%5D%E7%BB%9D%E4%B8%96%E5%A5%BD%E9%A2%98/"/>
    <url>/2019/04/18/%5BP4310%5D%E7%BB%9D%E4%B8%96%E5%A5%BD%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4310">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n;int f[35];int main()&#123;    cin &amp;gt;&amp;gt; n;    for (int i = 1; i &amp;lt;= n; i++)    &#123;        int x;        cin &amp;gt;&amp;gt; x;        int maxx = 1;        for (int i = 0; i &amp;lt;= 30; i++)        &#123;            if (x &amp;amp; (1 &amp;lt;&amp;lt; i))                maxx = max(maxx, f[i] + 1);        &#125;        for (int i = 0; i &amp;lt;= 30; i++)        &#123;            if (x &amp;amp; (1 &amp;lt;&amp;lt; i))                f[i] = max(maxx, f[i]);        &#125;    &#125;    int ans = 0;    for (int i = 0; i &amp;lt;= 30; i++)        ans = max(ans, f[i]);    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>之前代码一直是我的毒瘤码风真的很抱歉QAQ</title>
    <link href="/2019/04/18/%E4%B9%8B%E5%89%8D%E4%BB%A3%E7%A0%81%E4%B8%80%E7%9B%B4%E6%98%AF%E6%88%91%E7%9A%84%E6%AF%92%E7%98%A4%E7%A0%81%E9%A3%8E%E7%9C%9F%E7%9A%84%E5%BE%88%E6%8A%B1%E6%AD%89QAQ/"/>
    <url>/2019/04/18/%E4%B9%8B%E5%89%8D%E4%BB%A3%E7%A0%81%E4%B8%80%E7%9B%B4%E6%98%AF%E6%88%91%E7%9A%84%E6%AF%92%E7%98%A4%E7%A0%81%E9%A3%8E%E7%9C%9F%E7%9A%84%E5%BE%88%E6%8A%B1%E6%AD%89QAQ/</url>
    
    <content type="html"><![CDATA[<p>以后题解代码都是格式化过的啦！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[SHOI2001]小狗散步（最大匹配）</title>
    <link href="/2019/04/18/%5BSHOI2001%5D%E5%B0%8F%E7%8B%97%E6%95%A3%E6%AD%A5%EF%BC%88%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89/"/>
    <url>/2019/04/18/%5BSHOI2001%5D%E5%B0%8F%E7%8B%97%E6%95%A3%E6%AD%A5%EF%BC%88%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2526">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>把人走的点当作左部节点，🐕走的当作右部<br>对于每个人走的节点，如果他与下一个节点的距离的两倍大于某个从当前节点走到右部节点+右部节点走到下一节点的距离，即可连边<br>输出方案的话，注意到如果右部节点被匹配，match[i]就是匹配它的左部节点，存起来输出即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=10003;typedef pair&amp;lt;int,int&amp;gt; P;int Head[MAXN],to[MAXN&amp;lt;&amp;lt;1],Nt[MAXN&amp;lt;&amp;lt;1],tot;int match[MAXN];bool vis[MAXN];int rmatch[MAXN];int n,m;P master[MAXN],dog[MAXN];double dis(int x_1,int y_1,int x_2,int y_2)&#123;    return sqrt((x_1-x_2)*(x_1-x_2)+((y_1-y_2)*(y_1-y_2)));&#125;void add(int x,int y)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    Head[x]=tot;&#125;int dfs(int x)&#123;    for(int i=Head[x],y;i;i=Nt[i])&#123;        if(vis[y=to[i]])continue;        vis[y]=1;        if(!match[y]||dfs(match[y]))&#123;            match[y]=x;return true;        &#125;    &#125;    return false;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    for(int i=1;i&amp;lt;=n;i++)&#123;        int x,y;cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;        master[i]=make_pair(x,y);    &#125;    for(int i=1;i&amp;lt;=m;i++)&#123;        int x,y;cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;        dog[i]=make_pair(x,y);    &#125;    for(int i=1;i&amp;lt;n;i++)&#123;        for(int j=1;j&amp;lt;=m;j++)&#123;            if(dis(master[i].first,master[i].second,master[i+1].first,master[i+1].second)*2&amp;gt;dis(master[i].first,master[i].second,dog[j].first,dog[j].second)+dis(dog[j].first,dog[j].second,master[i+1].first,master[i+1].second))&#123;                add(i,j+n);            &#125;        &#125;    &#125;    int ans=0;    for(int i=1;i&amp;lt;n;i++)&#123;        memset(vis,0,sizeof(vis));        if(dfs(i))ans++;    &#125;    printf(&amp;quot;%d\n&amp;quot;,ans+n);    for(int j=1;j&amp;lt;=m;j++)&#123;        if(match[j+n])&#123;            rmatch[match[j+n]]=j;        &#125;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        printf(&amp;quot;%d %d &amp;quot;,master[i].first,master[i].second);        if(i!=n&amp;amp;&amp;amp;rmatch[i])&#123;            printf(&amp;quot;%d %d &amp;quot;,dog[rmatch[i]].first,dog[rmatch[i]].second);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[ZJOI2007]矩阵游戏（最大匹配）</title>
    <link href="/2019/04/18/%5BZJOI2007%5D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%EF%BC%88%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89/"/>
    <url>/2019/04/18/%5BZJOI2007%5D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%EF%BC%88%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P1129">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两眼题</p><p>考虑每一行，如果当前列为1，则行与列连边</p><p>于是我们左部是每一行，右部是列，可以发现，如果有解，当且仅当每一列都有行与之匹配</p><p>跑匈牙利即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=40003;int match[MAXN];bool vis[MAXN];int Head[MAXN],to[MAXN&amp;lt;&amp;lt;1],Nt[MAXN&amp;lt;&amp;lt;1],tot;int t,n;void add(int x,int y)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    Head[x]=tot;&#125;bool dfs(int x)&#123;    for(int i=Head[x],y;i;i=Nt[i])&#123;        if(vis[y=to[i]])continue;        vis[y]=1;        if(!match[y]||dfs(match[y]))&#123;            match[y]=x;return true;        &#125;    &#125;    return false;&#125;int main()&#123;    cin&amp;gt;&amp;gt;t;    while(t--)&#123;        cin&amp;gt;&amp;gt;n;        memset(Head,0,sizeof(Head));tot=0;memset(Nt,0,sizeof(Nt));memset(match,0,sizeof(match));        for(int i=1;i&amp;lt;=n;i++)&#123;            for(int j=1;j&amp;lt;=n;j++)&#123;                int a;cin&amp;gt;&amp;gt;a;                if(a==1)add(i,j+n);//个人理解原因，不加n也行            &#125;        &#125;        int i;        for(i=1;i&amp;lt;=n;i++)&#123;            memset(vis,0,sizeof(vis));            if(dfs(i));            else break;        &#125;        if(i==n+1)printf(&amp;quot;Yes\n&amp;quot;);        else printf(&amp;quot;No\n&amp;quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1139E]Maximize Mex（二分图最大匹配）</title>
    <link href="/2019/04/17/%5BCF1139E%5DMaximize%20Mex%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89/"/>
    <url>/2019/04/17/%5BCF1139E%5DMaximize%20Mex%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF1139E">题目链接</a></p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 $n$ 个学生 $m$ 个社团，每个学生有一个能力值 $p_i$ 属于 $c_i$ 社团，接下来的 $d$ 天里，每天由校长钦点一个学生滚蛋，然后由你从每个社团选一个人（没人就不选），对于每天，求这些人 $p_i$ 的 $mex$ 的最大值</p><p>$mex$ 即为序列中<strong>最小的非负整数</strong></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑二分图匹配</p><p>左部为学生的能力值，右部为社团。</p><p>将学生的能力值与其社团连边。</p><p>从最后一天开始匹配，往前的话，由于人只多不少， $mex$ 不会减少（最坏的情况你都可以选择上一次的人员构成）</p><p>代码里都加了一，最后答案减了一，这是因为我写的链式前向星和匈牙利不能有0元素（其实稍微改改也行）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=5003*2;int Head[MAXN],to[MAXN&amp;lt;&amp;lt;1],Nt[MAXN&amp;lt;&amp;lt;1],tot;int n,m,d;int p[MAXN],c[MAXN],ans[MAXN];int del[MAXN];bool delt[MAXN];bool vis[MAXN];int match[MAXN];void add(int x,int y)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    Head[x]=tot;&#125;bool dfs(int x)&#123;    for(int i=Head[x],y;i;i=Nt[i])&#123;        if(vis[y=to[i]])continue;vis[y]=1;        if(!match[y]||dfs(match[y]))&#123;            match[y]=x;return true;        &#125;    &#125;    return false;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    for(int i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;p[i];    for(int i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;c[i];    cin&amp;gt;&amp;gt;d;    for(int i=1;i&amp;lt;=d;i++)&#123;cin&amp;gt;&amp;gt;del[i];delt[del[i]]=1;&#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(delt[i])continue;        add(p[i]+1,c[i]+5001);    &#125;    int t=1;    for(int i=d;i&amp;gt;=1;i--)&#123;        memset(vis,0,sizeof(vis));        while(dfs(t))&#123;            t++;            memset(vis,0,sizeof(vis));        &#125;        ans[i]=t;        add(p[del[i]]+1,c[del[i]]+5001);    &#125;    for(int i=1;i&amp;lt;=d;i++)cout&amp;lt;&amp;lt;ans[i]-1&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1153E]Serval and Snake（二分）</title>
    <link href="/2019/04/15/%5BCF1153E%5DServal%20and%20Snake%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89/"/>
    <url>/2019/04/15/%5BCF1153E%5DServal%20and%20Snake%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF1153E">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>人生第一道交互题，感觉很神奇（还好并不难）<br>考虑以下情况：</p><ol><li>如果我们没有框中头尾，势必有一条“进入”矩形的边，就有一条“出去”的边。</li><li>如果我们只框中头或尾，肯定少一条“进入”或“出去”的边。</li><li>如果我们同时框中了头尾，肯定少两条“进入”或“出去”的边。</li></ol><p>综上，当ask的答案为奇数时，我们框中了头或尾，为偶数时可能同时框中，可能同时没框中。</p><p>可以先确定头尾是否在同一列</p><ol><li>不在同一列，分别对它们所在列二分，找到对应的点。</li><li>在同一列，再二分行数，找到对应的点。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,x;int x_1,y_1,x_2,y_2;int i,j;int ask(int x,int y,int z,int k)&#123;    printf(&amp;quot;? %d %d %d %d\n&amp;quot;,x,y,z,k);    fflush(stdout);    int ans;    cin&amp;gt;&amp;gt;ans;    return ans;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n;    for(i=1;i&amp;lt;n;i++)if(ask(1,1,n,i)&amp;amp;1)break;    if(i!=n)&#123;        for(j=n;j&amp;gt;1;j--)if(ask(1,j,n,n)&amp;amp;1)break;        int l=1,r=n;        while(l&amp;lt;r)&#123;            int mid=(l+r+1)&amp;gt;&amp;gt;1;             if(ask(mid,i,n,i)&amp;amp;1)l=mid;            else r=mid-1;        &#125;        x_1=l;y_1=i;        l=1,r=n;        while(l&amp;lt;r)&#123;            int mid=(l+r+1)&amp;gt;&amp;gt;1;             if(ask(mid,j,n,j)&amp;amp;1)l=mid;            else r=mid-1;        &#125;        x_2=l,y_2=j;    &#125;    else &#123;        for(i=1;i&amp;lt;n;i++)if(ask(1,1,i,n)&amp;amp;1)break;        for(j=n;j&amp;gt;1;j--)if(ask(j,1,n,n)&amp;amp;1)break;        int l=1,r=n;        while(l&amp;lt;r)&#123;            int mid=(l+r+1)&amp;gt;&amp;gt;1;             if(ask(i,mid,i,n)&amp;amp;1)l=mid;            else r=mid-1;        &#125;        x_1=i;y_1=l;        l=1,r=n;        while(l&amp;lt;r)&#123;            int mid=(l+r+1)&amp;gt;&amp;gt;1;             if(ask(j,mid,j,n)&amp;amp;1)l=mid;            else r=mid-1;        &#125;        x_2=j,y_2=l;    &#125;    printf(&amp;quot;! %d %d %d %d\n&amp;quot;,x_1,y_1,x_2,y_2);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF1153C]Serval and Parenthesis Sequence(贪心)</title>
    <link href="/2019/04/14/%5BCF1153C%5DServal%20and%20Parenthesis%20Sequence(%E8%B4%AA%E5%BF%83)/"/>
    <url>/2019/04/14/%5BCF1153C%5DServal%20and%20Parenthesis%20Sequence(%E8%B4%AA%E5%BF%83)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF1153C">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心大水题，然后比赛的时候就被疯狂hack，至少现在下面的策略是能过的。</p><ul><li>首先n要是偶数才有解</li><li>最左边是左括号，最右边是右括号（如果是问号直接变成对应的括号）</li><li>如果有解，肯定是左括号数目=右括号数目的，于是扫一遍字符串计数，当左括号没满足数目上限的时候一直填左括号</li></ul><p>就这样~</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;string s;int l,r,n;bool check()&#123;    int zhan=0;    for(int i=1;i&amp;lt;=n-2;i++)&#123;        if(s[i]==&amp;#039;(&amp;#039;)zhan++;        else &#123;            zhan--;            if(zhan&amp;lt;0)return 0;        &#125;    &#125;    if(zhan==0)return 1;    return 0;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n;cin&amp;gt;&amp;gt;s;    if(n%2!=0)&#123;        printf(&amp;quot;:(&amp;quot;);return 0;    &#125;    if(s[0]==&amp;#039;?&amp;#039;)s[0]=&amp;#039;(&amp;#039;;    if(s[n-1]==&amp;#039;?&amp;#039;)s[n-1]=&amp;#039;)&amp;#039;;    if(s[0]!=&amp;#039;(&amp;#039;||s[n-1]!=&amp;#039;)&amp;#039;)&#123;        printf(&amp;quot;:(&amp;quot;);return 0;    &#125;    if(n==2)&#123;cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;return 0;&#125;    for(int i=1;i&amp;lt;n-1;i++)&#123;        if(s[i]==&amp;#039;(&amp;#039;)l++;        if(s[i]==&amp;#039;)&amp;#039;)r++;    &#125;    if(l&amp;gt;=(n&amp;gt;&amp;gt;1)||r&amp;gt;=(n&amp;gt;&amp;gt;1))&#123;        printf(&amp;quot;:(&amp;quot;);return 0;    &#125;    for(int i=1;i&amp;lt;=n-2;i++)&#123;        if(s[i]==&amp;#039;?&amp;#039;)&#123;            if(l+2&amp;lt;=(n&amp;gt;&amp;gt;1))&#123;l++;s[i]=&amp;#039;(&amp;#039;;&#125;            else &#123;r++;s[i]=&amp;#039;)&amp;#039;;&#125;        &#125;    &#125;    if(check())cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;    else printf(&amp;quot;:(&amp;quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF817F] MEX Queries (线段树+离散化)</title>
    <link href="/2019/04/13/%5BCF817F%5D%20MEX%20Queries%20(%E7%BA%BF%E6%AE%B5%E6%A0%91+%E7%A6%BB%E6%95%A3%E5%8C%96)/"/>
    <url>/2019/04/13/%5BCF817F%5D%20MEX%20Queries%20(%E7%BA%BF%E6%AE%B5%E6%A0%91+%E7%A6%BB%E6%95%A3%E5%8C%96)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF817F">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一道线段树模板题，离散化需要注意下，居然交了10次，丢人……</p><p>细节还是很多的，最近都在写平衡树，一开始把线段树写成和权值树那样的分治方法了orz</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;#define lt p&amp;lt;&amp;lt;1#define rt p&amp;lt;&amp;lt;1|1using namespace std;const int MAXN=500005;typedef long long ll;//全开ll吧ll l[MAXN],r[MAXN],ls[MAXN&amp;lt;&amp;lt;2],opt[MAXN];ll n,cnt;struct SegTree&#123;    ll l,r;    ll val,tag;&#125;t[MAXN&amp;lt;&amp;lt;3];ll read()&#123;    ll x=0,f=1;char ch=getchar();    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;inline void update(int p)&#123;    t[p].val=t[lt].val+t[rt].val;&#125;inline void pushdown(int p)&#123;    ll mid=((t[p].l+t[p].r)&amp;gt;&amp;gt;1);    if(t[p].tag==1)&#123;        t[lt].val=mid-t[p].l+1;        t[rt].val=t[p].r-mid;        t[lt].tag=1,t[rt].tag=1;    &#125;    if(t[p].tag==0)&#123;        t[lt].val=t[rt].val=0;        t[lt].tag=0,t[rt].tag=0;    &#125;    t[p].tag=-1;&#125;void build(int p,ll l,ll r)&#123;//建树    t[p].l=l;t[p].r=r;ll mid=(l+r)&amp;gt;&amp;gt;1;    if(l==r)&#123;        t[p].tag=0;//初始的时候全是0（其实这里为-1也行）        return;    &#125;    build(lt,l,mid);build(rt,mid+1,r);&#125;void change(int p,ll L,ll R,int type)&#123;    if(L&amp;lt;=t[p].l&amp;amp;&amp;amp;R&amp;gt;=t[p].r)&#123;        t[p].tag=type;t[p].val=(t[p].r-t[p].l+1)*type;return ;//打标记，更新值，如果为1就是区间长度，否则为0    &#125;    pushdown(p);    ll mid=(t[p].l+t[p].r)&amp;gt;&amp;gt;1;    if(L&amp;lt;=mid)change(lt,L,R,type);    if(R&amp;gt;mid)change(rt,L,R,type);    update(p);&#125;void rev(int p,ll L,ll R)&#123;    if(t[p].l&amp;gt;=L&amp;amp;&amp;amp;t[p].r&amp;lt;=R&amp;amp;&amp;amp;t[p].tag!=-1)&#123;        t[p].tag^=1;t[p].val=t[p].r-t[p].l+1-t[p].val;return;//翻转，更新标记，值也“翻转”    &#125;    pushdown(p);    ll mid=(t[p].l+t[p].r)&amp;gt;&amp;gt;1;    if(L&amp;lt;=mid)rev(lt,L,R);    if(R&amp;gt;mid)rev(rt,L,R);    update(p);&#125;ll query(int p)&#123;    if(t[p].l==t[p].r)return t[p].l;    ll mid=(t[p].l+t[p].r)&amp;gt;&amp;gt;1;    pushdown(p);    if(t[lt].val&amp;lt;mid-t[p].l+1)return query(lt);//如果左子树还有0，往左子树找    else return query(rt);&#125;int main()&#123;    n=(int)read();    ls[++cnt]=1;//！！！防止左边爆炸！    for(int i=1;i&amp;lt;=n;i++)&#123;        opt[i]=read();l[i]=read();r[i]=read();        ls[++cnt]=l[i];ls[++cnt]=r[i];ls[++cnt]=r[i]+1;//！！！防止右边爆炸（其实只要加一个max(r[i])+1就行    &#125;    build(1,1,cnt);    sort(ls+1,ls+cnt+1);    ll len=unique(ls+1,ls+cnt+1)-ls-1;    for(int i=1;i&amp;lt;=n;i++)&#123;        ll x=lower_bound(ls+1,ls+len+1,l[i])-ls;        ll y=lower_bound(ls+1,ls+len+1,r[i])-ls;        if(opt[i]==1)change(1,x,y,1);        else if(opt[i]==2)change(1,x,y,0);        else rev(1,x,y);        printf(&amp;quot;%lld\n&amp;quot;,ls[query(1)]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[TJOI2017]DNA（字符串+哈希）</title>
    <link href="/2019/04/13/%5BTJOI2017%5DDNA%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2+%E5%93%88%E5%B8%8C%EF%BC%89/"/>
    <url>/2019/04/13/%5BTJOI2017%5DDNA%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2+%E5%93%88%E5%B8%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3763">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目大意：给两个串，S，T，问S中有多少个子串与T的差异是在3个字符以内的。</p><p>这道题解法有很多，像什么SAM，FFT，NTT之类的，然而我只会哈希orz</p><p>二分找它们的最长公共前缀，最多能跳3次，没了……</p><p>设N为S的长度，M为T的长度<br>时间复杂度 $O((N-M)\times (logM))$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef unsigned long long ull;const int P=131,MAXN=100005;ull hash1[MAXN];ull hash2[MAXN];ull Q[MAXN];int n,len1,len2;string str;int num(char ch)&#123;    if(ch==&amp;#039;A&amp;#039;)return 0;    if(ch==&amp;#039;T&amp;#039;)return 1;    if(ch==&amp;#039;C&amp;#039;)return 2;    return 3;&#125;ull ask(int type,int l,int r)&#123;    if(type==1)return hash1[r]-hash1[l-1]*Q[r-l+1];    else return hash2[r]-hash2[l-1]*Q[r-l+1];&#125;int lcp(int x,int y,int r)&#123;    int l=1,mid,t=0;    while(l&amp;lt;=r)&#123;        mid=(l+r)&amp;gt;&amp;gt;1;        if(ask(1,x,x+mid-1)==ask(2,y,y+mid-1))&#123;            t=mid;            l=mid+1;        &#125;        else r=mid-1;    &#125;    return t;&#125;bool check(int x)&#123;    int r=x+len2-1,y=1;    for(int i=0;i&amp;lt;3;i++)&#123;        int t=lcp(x,y,len2-y+1);        x+=t+1;        y+=t+1;        if(y&amp;gt;len2)return 1;    &#125;    return ask(1,x,r)==ask(2,y,len2);&#125;void solve()&#123;    int ans=0;    for(int i=1;i&amp;lt;=len1-len2+1;i++)&#123;        if(check(i))ans++;    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;&#125;int main()&#123;    Q[0]=1;    for(int i=1;i&amp;lt;=100000;i++)Q[i]=Q[i-1]*P;    cin&amp;gt;&amp;gt;n;    while(n--)&#123;        cin&amp;gt;&amp;gt;str;        len1=str.length();        for(int i=0;i&amp;lt;len1;i++)&#123;            i+=1;            hash1[i]=hash1[i-1]*P+num(str[i-1]);            i-=1;        &#125;        cin&amp;gt;&amp;gt;str;        len2=str.length();        for(int i=0;i&amp;lt;len2;i++)&#123;            i+=1;            hash2[i]=hash2[i-1]*P+num(str[i-1]);            i-=1;        &#125;        solve();        memset(hash1,0,sizeof(hash1));        memset(hash2,0,sizeof(hash2));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF533F]Encoding(哈希)</title>
    <link href="/2019/04/07/%5BCF533F%5DEncoding(%E5%93%88%E5%B8%8C)/"/>
    <url>/2019/04/07/%5BCF533F%5DEncoding(%E5%93%88%E5%B8%8C)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF533F">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>哈希真的是个好东西,在O(N)预处理之后,能在O(1)的时间内枚举任意子串.<br>这道题我们可以考虑对每种字母进行哈希.<br>具体来讲,hash1[i][c]存储的是字母c的哈希值(位置)</p><p>这样处理之后,就在S串里面枚举长度为T串的子串,再枚举两种字母,如果26个字母哈希值能够相等,那么这样的变化是没问题的</p><p>时间复杂度 $O(N\times 26\times 26)$</p><p>这里进制为131,模数为 $2^{64}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;typedef long long ll;const ll p=131;const int N=210000;int n,m;char sr1[N],sr2[N];unsigned long long hash1[N][28],hash2[N][28],Q[N];int Ans[N],ans;int main()&#123;    int i,j,k,x,y;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    scanf(&amp;quot;%s%s&amp;quot;,sr1+1,sr2+1);    Q[0]=1;    for(i=1;i&amp;lt;=n;++i)        Q[i]=Q[i-1]*p;    for(j=0;j&amp;lt;=25;++j)        for(i=1;i&amp;lt;=n;++i)&#123;            hash1[i][j]=hash1[i-1][j]*p;            if(sr1[i]-&amp;#039;a&amp;#039;==j)hash1[i][j]+=1;        &#125;    for(j=0;j&amp;lt;=25;++j)        for(i=1;i&amp;lt;=m;++i)&#123;            hash2[i][j]=hash2[i-1][j]*p;            if(sr2[i]-&amp;#039;a&amp;#039;==j)hash2[i][j]+=1;        &#125;    int cnt;    for(i=1;i&amp;lt;=n-m+1;++i)&#123;        cnt=0;        for(x=0;x&amp;lt;26;++x)&#123;            if(cnt!=x)break;            for(y=0;y&amp;lt;26;++y)                if(hash2[m][x]==hash1[i+m-1][y]-hash1[i-1][y]*Q[m])                    if(hash2[m][y]==hash1[i+m-1][x]-hash1[i-1][x]*Q[m])&#123;                        cnt++;                        break;                    &#125;        &#125;        if(cnt==26) Ans[++ans]=i;    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    for(i=1;i&amp;lt;ans;++i)printf(&amp;quot;%d &amp;quot;,Ans[i]);    if(ans!=0)printf(&amp;quot;%d&amp;quot;,Ans[ans]);&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF611D]New Year and Ancient Prophecy(动态规划)</title>
    <link href="/2019/04/06/%5BCF611D%5DNew%20Year%20and%20Ancient%20Prophecy(%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)/"/>
    <url>/2019/04/06/%5BCF611D%5DNew%20Year%20and%20Ancient%20Prophecy(%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF611D">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$f[i][j]$ 表示 当前串为第j个位置到第i个位置的串的方案数</p><p>$O(n^3)$ 做法<br>$ f[i][j]=\sum_{j-k&lt; i-j}f[j][k]$   </p><p>若 $s(k+1,j)&lt; s(j+1,i),j-k=i-j$ 则 $f[i][j]+=f[j][k]$</p><p>$O(n^2)$ 做法<br>考虑 $O(1)$ check $s(k+1,j)&lt;s(j+1,i)$   </p><p><del>逗逼</del>神仙做法：SA<br>简单做法：求 $lcp(I,j)$ 即$s[i],s[j]$ 的最长公共前缀<br>若 $lcp(k,j)&lt;j-k-1 $ 并且  $s[k+ lcp(k,j)+1]&lt; s[j+ lcp(k,j)+1]$ 则合法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int MAXN=5010,MOD=1e9+7;char str[MAXN];ll f[MAXN][MAXN],sum[MAXN][MAXN];int lcp[MAXN][MAXN];int n,a[MAXN];int check(int x,int y)&#123;    if(lcp[x][y]&amp;gt;=y-x)return false;//y-x就是区间长度    if(a[x+lcp[x][y]]&amp;lt;a[y+lcp[x][y]])return true;    if(a[x+lcp[x][y]]&amp;gt;a[y+lcp[x][y]])return false;    return 0;&#125;/*sum[i][j]保存的是f[i][1]+f[i][2]+...+f[i][j]*/int main()&#123;    cin&amp;gt;&amp;gt;n;    scanf(&amp;quot;%s&amp;quot;,str+1);    for(int i=1;i&amp;lt;=n;i++)&#123;        a[i]=str[i]-&amp;#039;0&amp;#039;;    &#125;    for(int i=n;i&amp;gt;=1;i--)&#123;//预处理最长公共前缀        for(int j=n;j&amp;gt;=1;j--)&#123;            if(a[i]==a[j])lcp[i][j]=lcp[i+1][j+1]+1;        &#125;    &#125;    for(int i=1;i&amp;lt;=n;i++)f[i][1]=1;//初始化    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=i;j++)&#123;            if(a[j]==0)continue;//不能有前导0            int k=2*j-i;k=max(1,k);//左端点            f[i][j]=(f[i][j]+sum[j-1][j-1]-sum[j-1][k-1]+MOD)%MOD;            k--;            if(k&amp;gt;=0&amp;amp;&amp;amp;check(k,j))f[i][j]=(f[i][j]+f[j-1][k])%MOD;        &#125;        for(int j=1;j&amp;lt;=i;j++)sum[i][j]=(sum[i][j-1]+f[i][j])%MOD;    &#125;    ll ans=0;    for(int i=1;i&amp;lt;=n;i++)ans=(ans+f[n][i])%MOD;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOI2018]屠龙勇士</title>
    <link href="/2019/04/06/%5BNOI2018%5D%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/"/>
    <url>/2019/04/06/%5BNOI2018%5D%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4774">题目链接</a></p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>中国剩余定理”裸题”</p><blockquote><p>这就当是我对(扩展)中国剩余定理的总结吧,还有好多细节的方面的归纳.</p></blockquote><h2 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h2><p>用途就是解出<a href="https://www.luogu.org/problemnew/show/P4777">这类问题</a><br>我们可以先考虑模数两两互质的情况下的做法.<br>我们想构造出一个合式使得 $x= r_1+r_2+r_3+\cdots +r_n$ 其中 $m_i$ 可以整除除了第i项的其他项  </p><p>于是我们可以通过一下做法达到我们的目的:<br>我们先开一个变量lcm来存它们的最小公倍数(如果两两互质,结果显然是它们的乘积)<br>然后开一个数组 $M_i=\frac{lcm}{m_i}$ 就是把每项的模数给剔除出来<br>设 $t_i$ 是 $M_it_i\equiv1\ (mod\ m_i)$的一个解.</p><p>于是答案就是 $ans=\displaystyle\sum_{i=1}^na_iM_it_i$<br>通解就是 $ans+klcm$ 其中k是整数</p><h2 id="扩展中国剩余定理-exCRT"><a href="#扩展中国剩余定理-exCRT" class="headerlink" title="扩展中国剩余定理(exCRT)"></a>扩展中国剩余定理(exCRT)</h2><p>这才是大多数题目真正会用到的算法,因为它不必要求模数两两互质,我们还是可以通过刚刚的想法来做<br>假设前 $k-1$ 个方程的解是 $x$ , 前 $k-1$ 的lcm还是用 $lcm$ 表示<br>则前 $k-1$ 个方程的通解是 $x+im$ 其中i是整数  </p><p>现在求第 $k$ 个方程,我们需要一个整数t,满足 $x+tm\equiv a_k\ (mod\ m_k)$<br>等价于 $tm\equiv a_k-x\ (mod\ m_k)$</p><p>答案更新为 $x=x+tm$</p><h2 id="回到这道题上来"><a href="#回到这道题上来" class="headerlink" title="回到这道题上来"></a>回到这道题上来</h2><p>不难发现,这道题其实就是要求如下的线性同余方程组<br>$$\begin{cases}x\equiv a_1\times ATK_1^{-1}\ (mod\ p_1)\x\equiv a_2\times ATK_2^{-2}\ (mod\ p_2)\ \cdots\ x\equiv a_n\times ATK_n^{-n}\ (mod\ p_n) \end{cases}$$</p><p>至于每一项的ATK,可以用multiset处理出来(想快一点手写平衡树)</p><p>但是我们发现,如果ATK不与模数互质的话,它的逆元是不好求的  </p><blockquote><p>同余的<strong>消去律</strong>:<br>如果 $ab\equiv ac\ (mod\ n)$,而 $d=gcd(a,n)$ ,那么a可以在同余式两边消去<br>$b\equiv c\ (mod\ \frac{n}{d})$<br>特别是当a和n互质,$ab\equiv ac\ (mod\ n)$ 可推到 $b \equiv  c\ (mod\ n)$</p></blockquote><p>根据模运算的消去律,我们可以去掉最大公因数 $gcd(ATK_i*lcm,p_i)$ 如果左式无法整除,则无解 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int MAXN=100005;ll a[MAXN],p[MAXN],bone[MAXN],atk[MAXN],ans;int n,m;ll read()&#123;    ll x=0,f=1;char ch=getchar();    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;ll mul(ll a,ll b,ll mod)&#123;    a = (a % mod + mod) % mod;//可能为负数,不加60分    b = (b % mod + mod) % mod;    ll ans=0;    while(b)&#123;        if(b&amp;amp;1)ans=(ans+a)%mod;        a=(a+a)%mod;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;ll exgcd(ll a,ll b,ll &amp;amp;x,ll &amp;amp;y)&#123;    if(b==0)&#123;x=1,y=0;return a;&#125;    ll d=exgcd(b,a%b,x,y);    ll z=x;x=y;y=z-y*(a/b);    return d;&#125;ll gcd(ll a,ll b)&#123;    return b?gcd(b,a%b):a;&#125;ll inverse(ll a, ll mod) &#123;    ll x, y;    exgcd(a, mod, x, y);    return (x % mod + mod) % mod;&#125;ll excrt()&#123;    ans=0;    ll lcm=1;    for(int i=1;i&amp;lt;=n;i++)&#123;        ll ax=mul(atk[i],lcm,p[i]);        ll bx=a[i]-mul(atk[i],ans,p[i]);        ll d=gcd(ax,p[i]);        if(bx%d!=0)&#123;            ans=-1;            return 0;        &#125;        ll x=mul(bx/d,inverse(ax/d,p[i]/d),p[i]/d);        ans+=lcm*x,lcm*=p[i]/d;    &#125;    ans=(ans%lcm+lcm)%lcm;    return lcm;&#125;int main()&#123;    int t=read();    while(t--)&#123;        multiset&amp;lt;ll&amp;gt;bst;ans=0;        n=read(),m=read();        for(int i=1;i&amp;lt;=n;i++)a[i]=read();        for(int i=1;i&amp;lt;=n;i++)p[i]=read();        for(int i=1;i&amp;lt;=n;i++)bone[i]=read();        for(int i=1;i&amp;lt;=m;i++)&#123;ll x=read();bst.insert(x);&#125;        ll mx=0;        for(int i=1;i&amp;lt;=n;i++)&#123;            multiset&amp;lt;ll&amp;gt;::iterator it = bst.upper_bound(a[i]);            if (it != bst.begin()) &#123;                it--;            &#125;            atk[i] = (*it), bst.erase(it), bst.insert(bone[i]);            mx = max(mx, (a[i] + atk[i] - 1) / atk[i]);        &#125;        ll lcm=excrt();ll x=ans;        if(x!=-1&amp;amp;&amp;amp;x&amp;lt;mx)&#123;            x+=lcm*((mx-x+lcm-1)/lcm);        &#125;        cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF616E]Sum of Remainders</title>
    <link href="/2019/04/02/%5BCF616E%5DSum%20of%20Remainders/"/>
    <url>/2019/04/02/%5BCF616E%5DSum%20of%20Remainders/</url>
    
    <content type="html"><![CDATA[<p>其实和<a href="https://www.luogu.org/problemnew/show/P2261">余数求和</a>是同一道题…<br>但是范围加大取模就有点容易载坑</p><p>还是说一下思路吧</p><p>首先我们要求的是:</p><p>$$\displaystyle\sum_{i=1}^m n\ mod \ i$$</p><p>其实取模操作特殊在没有什么特殊性<br>基本上看到这种形式就会想到 $n\ mod\ i=n-  \left\lfloor\frac{n}{i}\right\rfloor\times i$</p><p>于是我们其实就是要求<br>$$n\times m-\displaystyle\sum_{i=1}^m\left\lfloor\frac{n}{i}\right\rfloor\times i$$</p><p>左边这一坨很好求,右边这一坨就要用到<strong>整除分块</strong></p><p>其实也不是什么难理解的东西,其实就是<strong>整除中,被除数一定的情况下,商随除数的增大而减小</strong><br>由于是整数,所以这个减小是呈现出阶梯状的.<br>于是我们就想通过当前的商,来推出当前阶梯在截止(<del>在哪里需要减小</del>)</p><p>听起来很难,其实稍微理解下就好(以下为非严谨但是易于理解的证明)<br>首先我们设 $t=\left\lfloor\dfrac{n}{i}\right\rfloor$<br>这个就是我们当前阶梯的高度了<br>$t$ 的数学含义是, $n$ 里面包含了几个 $i$<br>假设我们现在每个阶梯高度都是 $t$<br>那么最多能维持多少个阶梯呢<br>答案显然是 $\left\lfloor\dfrac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$  个<br>于是我们的右边界就算出来了(还要对边界取min),时间复杂度$O(\sqrt{N})$</p><p>好吧我承认这样可能更难理解orz</p><pre><code class="cpp">/*要特别注意边界情况*/#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long LL;const LL mod=1e9+7;LL n,m,ans,up,sum,r;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    ans=(n%mod)*(m%mod)%mod;    up=min(n,m);    sum=0;    for(LL i=1;i&amp;lt;=up;++i)&#123;        r=min(n/(n/i),up);        LL a=i+r;        LL b=r-i+1;        if(a&amp;amp;1)b/=2;        else a/=2;        sum=(sum+((a%mod)*(b%mod)%mod)*(n/i)%mod)%mod;        i=r;    &#125;    cout&amp;lt;&amp;lt;(ans-sum+mod)%mod&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre><p>好吧 我就给出严谨一点的证明<br>对于 $x\in [1,n]$ , 设 $g(x)=\left\lfloor\dfrac{n}{\left\lfloor\frac{n}{x}\right\rfloor}\right\rfloor$<br>设 $f(x)=\dfrac{n}{x}$  注意这里的 $n$ 为常数<br>对 $f(x)$ 求导得到 $f’(x)=-\dfrac{n}{x^2}$ 在 $[1,n]$ 衡小于0<br>$f(x)$ 在 $[1,n]$ 单调递减<br>而 $g(x)\ge \left\lfloor\dfrac{n}{\frac{n}{x}}\right\rfloor=x$<br>所以 $\left\lfloor\dfrac{n}{x}\right\rfloor\ge \left\lfloor\dfrac{n}{g(x)}\right\rfloor$  </p><p>而且, $\left\lfloor\dfrac{n}{g(x)}\right\rfloor\ge \left\lfloor\dfrac{n}{\dfrac{n}{\left\lfloor\frac{n}{x}\right\rfloor}}\right\rfloor=\left\lfloor\dfrac{n}{x}\right\rfloor$</p><p>所以 $\left\lfloor\dfrac{n}{x}\right\rfloor=\left\lfloor\dfrac{n}{g(x)}\right\rfloor$</p><p>这个 $x$ 就是我们刚刚枚举的 $i$<br>可以注意到,我们求出了一个 $g(x)$ 肯定是不小于 $x$ 但是它们的整除 $n$ 的值却是一样的,且它是符合要求的数里面最大的.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[ZJOI2007]报表统计</title>
    <link href="/2019/03/26/%5BZJOI2007%5D%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/"/>
    <url>/2019/03/26/%5BZJOI2007%5D%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P1110">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>又是一道题一晚上系列(数据结构一生之敌)</p><p>调了很久的原因其实是写错了一个变量,其实还是很简单的</p><p>这里用的平衡树是Treap</p><p>你可以把原始数列看成n个链表,首尾相连的那种,但是我们要分段存<br>用vector就很舒服</p><p>然后对于第三个操作,其实只要每次进入平衡树的元素查找下前驱后继与它本身作差取最小值即可(这里的前驱后继是<strong>非严格</strong>的)</p><p>对于第二个操作,每次插入一个元素,总会创造两个差值关系并且减去一个差值关系<br>我们可以用两个<strong>小根堆</strong>分别维护产生的差值和删去的差值,每次询问时,不断弹出顶端相同元素后,第一个堆顶就是答案了</p><p>这种做法还是有点慢的(最慢1500ms,开了O2 790ms),如果当年省选不开O2的话有点悬</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=600304,INF=0x7fffffff;int pos[MAXN];//可以不用int minn=INF;vector&amp;lt;int&amp;gt;b[MAXN];struct delhp&#123;    priority_queue&amp;lt;int&amp;gt;q1,q2;    void insert(int kind,int x)&#123;        if(kind==1)q1.push(-x);//小根堆        else q2.push(-x);    &#125;    int top()&#123;        while(q1.size()&amp;amp;&amp;amp;q2.size())&#123;            if(q1.top()!=q2.top())return -q1.top();            q1.pop();q2.pop();        &#125;    &#125;&#125;q;struct Treap&#123;    int l,r;    int val,dat;    int cnt,size;&#125;a[MAXN];int tot,root;int read()&#123;    int x=0,f=1;char ch=getchar();    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;void update(int p)&#123;    a[p].size=a[a[p].l].size+a[a[p].r].size+a[p].cnt;&#125;int New(int x)&#123;    a[++tot].val=x;    a[tot].dat=rand();    a[tot].size=a[tot].cnt=1;    return tot;&#125;void build()&#123;    New(-INF);New(INF);    a[1].r=2;    root=1;    update(root);&#125;void zig(int &amp;amp;p)&#123;    int q=a[p].l;    a[p].l=a[q].r;a[q].r=p;p=q;    update(a[p].r);update(p);&#125;void zag(int &amp;amp;p)&#123;    int q=a[p].r;    a[p].r=a[q].l;a[q].l=p;p=q;    update(a[p].l);update(p);&#125;void insert(int &amp;amp;p,int val)&#123;    if(p==0)&#123;        p=New(val);        return;    &#125;    if(val==a[p].val)&#123;        a[p].cnt++;        update(p);        return;    &#125;    if(val&amp;lt;a[p].val)&#123;        insert(a[p].l,val);        if(a[a[p].l].dat&amp;gt;a[p].dat)zig(p);    &#125;    else &#123;        insert(a[p].r,val);        if(a[a[p].r].dat&amp;gt;a[p].dat)zag(p);    &#125;    update(p);&#125;int GetPre(int val)&#123;    int ans=1;    int p=root;    while(p)&#123;        if(val==a[p].val)&#123;            if(a[p].cnt&amp;gt;1)return a[p].val;            else if(a[p].l&amp;gt;0)&#123;                p=a[p].l;                while(a[p].r&amp;gt;0)p=a[p].r;                ans=p;            &#125;            break;        &#125;        if(a[p].val&amp;lt;val&amp;amp;&amp;amp;a[p].val&amp;gt;a[ans].val)ans=p;        p=val&amp;lt;a[p].val?a[p].l:a[p].r;    &#125;    return a[ans].val;&#125;int GetNext(int val)&#123;    int ans=2;    int p=root;    while(p)&#123;        if(val==a[p].val)&#123;            if(a[p].cnt&amp;gt;1)return a[p].val;            else if(a[p].r&amp;gt;0)&#123;                p=a[p].r;                while(a[p].l&amp;gt;0)p=a[p].l;                ans=p;            &#125;            break;        &#125;        if(a[p].val&amp;gt;val&amp;amp;&amp;amp;a[p].val&amp;lt;a[ans].val)ans=p;        p=val&amp;lt;a[p].val?a[p].l:a[p].r;    &#125;    return a[ans].val;&#125;int main()&#123;    int n=read(),m=read();    build();    for(int i=1;i&amp;lt;=n;i++)&#123;        int x=read();        pos[i]=x;        b[i].push_back(x);        if(i!=1)q.insert(1,abs(pos[i]-pos[i-1]));        if(minn!=0)&#123;//维护操作3            insert(root,pos[i]);            int xx=GetNext(pos[i]);            int yy=GetPre(pos[i]);            if(xx!=INF&amp;amp;&amp;amp;xx!=-INF)minn=min(minn,xx-pos[i]);            if(yy!=INF&amp;amp;&amp;amp;yy!=-INF)minn=min(minn,pos[i]-yy);        &#125;    &#125;    for(int i=1;i&amp;lt;=m;i++)&#123;        char s[20];        scanf(&amp;quot;%s&amp;quot;,s);        int len=strlen(s);        if(len==6)&#123;            int x=read(),k=read();            b[x].push_back(k);            if(minn!=0)insert(root,k);            q.insert(1,abs(k-*(b[x].end()-2)));//*号为解除引用,如果不加上则返回的是迭代器            if(b[x+1].size())&#123;//防止越界RE                q.insert(1,abs(k-*(b[x+1].begin())));                q.insert(2,abs(*(b[x].end()-2)-*(b[x+1].begin())));            &#125;            if(minn!=0)&#123;                int xx=GetNext(k);                int yy=GetPre(k);                if(xx!=INF&amp;amp;&amp;amp;xx!=-INF)minn=min(minn,xx-k);                if(yy!=INF&amp;amp;&amp;amp;yy!=-INF)minn=min(minn,k-yy);            &#125;        &#125;        else if(len==7)&#123;            printf(&amp;quot;%d\n&amp;quot;,q.top());        &#125;        else &#123;            printf(&amp;quot;%d\n&amp;quot;,minn);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[ZJOI2006]书架</title>
    <link href="/2019/03/25/%5BZJOI2006%5D%E4%B9%A6%E6%9E%B6/"/>
    <url>/2019/03/25/%5BZJOI2006%5D%E4%B9%A6%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2596">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题一开始用的是Treap写的,死活调不出来,题解又全是指针的</p><p>然后就用splay来写,发现思路自然了许多</p><p>引用自<a href="https://www.luogu.org/blog/FlierKing/solution-p2596">FlierKing</a></p><blockquote><p>平衡树，需支持五个操作：</p></blockquote><ol><li>将某元素置顶：将元素旋到根，然后将左子树合并到该元素的后继</li><li>将某元素置底：将元素旋到根，然后将右子树合并到该元素的前驱</li><li>将某元素提前/滞后1位：直接与该元素的前驱/后继交换位置及信息</li><li>询问指定元素排名：将元素旋到根，输出size-1</li><li>询问指定排名元素：在树上find</li></ol><table><thead><tr><th align="center">数组名称</th><th align="center">数组作用</th></tr></thead><tbody><tr><td align="center">pos</td><td align="center">保存了编号为i的书在splay中的编号</td></tr><tr><td align="center">v</td><td align="center">保存了splay编号为i的节点对应的书的编号</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=80005;int rt,n,m;int ch[MAXN][2],fa[MAXN],pos[MAXN],v[MAXN],tot,size[MAXN];int read()&#123;    int x=0,f=1;char ch=getchar();    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;void pushup(int x)&#123;    size[x]=size[ch[x][0]]+size[ch[x][1]]+1;    pos[v[ch[x][0]]]=ch[x][0];    pos[v[ch[x][1]]]=ch[x][1];&#125;void rotate(int x,int &amp;amp;k)&#123;    int y=fa[x],z=fa[y],kind;    if(ch[y][0]==x)kind=1;    else kind=0;    if(k==y)k=x;    else &#123;        if(ch[z][0]==y)ch[z][0]=x;        else ch[z][1]=x;    &#125;    ch[y][kind^1]=ch[x][kind];    fa[ch[y][kind^1]]=y;    ch[x][kind]=y;    fa[y]=x;    fa[x]=z;    pushup(x);pushup(y);&#125;void splay(int x,int &amp;amp;k)&#123;    while(x!=k)&#123;        int y=fa[x],z=fa[y];        if(y!=k)&#123;            if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k);            else rotate(y,k);        &#125;        rotate(x,k);    &#125;&#125;int find(int x,int k)&#123;    int s=size[ch[x][0]];    if(k==s+1)return x;    if(k&amp;lt;=s)return find(ch[x][0],k);    else return find(ch[x][1],k-s-1);&#125;void top(int x)&#123;//将某元素置顶    x=pos[x];    splay(x,rt);//将元素旋到根    /*将左子树合并到该元素的后继*/    if(!ch[x][0])return;    if(!ch[x][1])ch[x][1]=ch[x][0],ch[x][0]=0;    else &#123;        int y=find(rt,size[ch[x][0]]+2);        fa[ch[rt][0]]=y;        ch[y][0]=ch[rt][0];        ch[rt][0]=0;        splay(y,rt);    &#125;&#125;void bottom(int x)&#123;//将某元素置底    x=pos[x];    splay(x,rt);//将元素旋到根    /*将右子树合并到该元素的前驱*/    if(!ch[x][1])return;    if(!ch[x][0])ch[x][0]=ch[x][1],ch[x][1]=0;    else &#123;        int y=find(rt,size[ch[x][0]]);        fa[ch[rt][1]]=y;        ch[y][1]=ch[rt][1];        ch[rt][1]=0;        splay(y,rt);    &#125;&#125;void ins(int f,int x)&#123;//将某元素提前/滞后1位    if(!f)return;    /*与该元素的前驱/后继交换位置及信息*/    splay(pos[x],rt);    int y=find(rt,f==1?size[ch[pos[x]][0]]+2:size[ch[pos[x]][0]]);    int x1=v[y],x2=pos[x];    swap(pos[x],pos[x1]);    swap(v[x2],v[y]);&#125;void geta(int x)&#123;//询问指定元素排名    splay(x,rt);//将元素旋到根，输出size-1    printf(&amp;quot;%d\n&amp;quot;,size[ch[x][0]]);&#125;void insert(int x)&#123;    v[++tot]=x;size[tot]=1;pos[x]=tot;    ch[tot][0]=ch[tot][1]=0;    if(tot&amp;gt;1)&#123;        ch[tot-1][1]=tot;fa[tot]=tot-1;        splay(tot,rt);    &#125;&#125;int main()&#123;    n=read();m=read();    rt=1;    for(int i=1;i&amp;lt;=n;i++)&#123;        insert(read());    &#125;    char s[20];    while(m--)&#123;        scanf(&amp;quot;%s&amp;quot;,s);        switch(s[0])&#123;            case &amp;#039;T&amp;#039;:                top(read());                break;            case &amp;#039;B&amp;#039;:                bottom(read());                break;            case &amp;#039;I&amp;#039;:                ins(read(),read());                break;            case &amp;#039;A&amp;#039;:                geta(pos[read()]);                break;            case &amp;#039;Q&amp;#039;://询问指定排名元素                printf(&amp;quot;%d\n&amp;quot;,v[find(rt,read())]);//find                break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CQOI2014]排序机械臂</title>
    <link href="/2019/03/25/%5BCQOI2014%5D%E6%8E%92%E5%BA%8F%E6%9C%BA%E6%A2%B0%E8%87%82/"/>
    <url>/2019/03/25/%5BCQOI2014%5D%E6%8E%92%E5%BA%8F%E6%9C%BA%E6%A2%B0%E8%87%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3165">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题坑了我好久,其实不难,就是有个地方与模板不一样导致错误(死背模板的后果)</p><p>考虑用splay维护区间翻转,每次的翻转左边界是确定的,而右边界则是第i小的数所在位置</p><p>输入存在a数组里,按高度排序,每次我们就取出a[i].id,它的位置作为右边界,每次输出它的size</p><p>由于每次都单独地splay(a[i].id,rt) ,所以旋转的时候也要下放标记,其实以后都可以这样写,应该也不会T</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=100004;int n,rt;int ch[MAXN][2],fa[MAXN],size[MAXN],rev[MAXN];struct node&#123;    int id,hight;    bool operator&amp;lt;(const node&amp;amp; b)&#123;        if(hight!=b.hight)return hight&amp;lt;b.hight;        else return id&amp;lt;b.id;    &#125;&#125;a[MAXN];inline void pushup(int x)&#123;    size[x]=size[ch[x][0]]+size[ch[x][1]]+1;&#125;void pushdown(int x)&#123;    if(rev[x])&#123;        swap(ch[x][0],ch[x][1]);        rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;rev[x]=0;    &#125;&#125;void rotate(int x,int &amp;amp;k)&#123;    int y=fa[x],z=fa[y],kind;    pushdown(y);pushdown(x);    if(ch[y][0]==x)kind=1;    else kind=0;    if(y==k)k=x;    else &#123;        if(ch[z][0]==y)ch[z][0]=x;        else ch[z][1]=x;    &#125;    ch[y][kind^1]=ch[x][kind];    fa[ch[y][kind^1]]=y;    ch[x][kind]=y;    fa[y]=x;    fa[x]=z;    pushup(x);pushup(y);&#125;void splay(int x,int &amp;amp;k)&#123;    while(x!=k)&#123;        int y=fa[x],z=fa[y];        if(y!=k)&#123;            if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k);            else rotate(y,k);        &#125;        rotate(x,k);    &#125;&#125;void build(int l,int r,int f)&#123;    if(l&amp;gt;r)return ;    int mid=(l+r)/2;    if(mid&amp;lt;f)ch[f][0]=mid;else ch[f][1]=mid;    fa[mid]=f;size[mid]=1;    if(l==r)return;    build(l,mid-1,mid);build(mid+1,r,mid);    pushup(mid);&#125;int find(int x,int k)&#123;    pushdown(x);int s=size[ch[x][0]];    if(k==s+1)return x;    if(k&amp;lt;=s)return find(ch[x][0],k);    else return find(ch[x][1],k-s-1);&#125;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    rt=(n+3)/2;    build(1,n+2,rt);    for(int i=2;i&amp;lt;=n+1;i++)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i].hight);        a[i].id=i;    &#125;    sort(a+2,a+n+2);    for(int i=2;i&amp;lt;=n+1;i++)&#123;        splay(a[i].id,rt);        int ans=size[ch[rt][0]]+1;        printf(&amp;quot;%d &amp;quot;,ans-1);        int x1=find(rt,i-1);        int y1=find(rt,ans+1);        splay(x1,rt);splay(y1,ch[x1][1]);        rev[ch[y1][0]]^=1;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>苏幕遮</title>
    <link href="/2019/03/21/%E8%8B%8F%E5%B9%95%E9%81%AE/"/>
    <url>/2019/03/21/%E8%8B%8F%E5%B9%95%E9%81%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>苏幕遮</p></blockquote><blockquote><p>往边关<br>沙塞月<br>胡马嘶风<br>茄鼓吹霜雪<br>一片寒蝉声里咽<br>无限凄凉<br>冷落天涯别</p></blockquote><blockquote><p>举旌旗<br>砺兵器<br>独驾单骑<br>驰骋看山河<br>纵使荆棘长满路<br>砥砺前行<br>微雨沾衣热</p></blockquote><p>这是一首奥赛词<br>然而为了像词所以选了和奥赛没有关系的意象  </p><p>其实上阙是九歌写的，我觉得还满意，于是改了一下就用他的了<br>上阙主要描写NOIP后，几个鬼人就退了（明明考得比我好），还有几个鬼人开学考后就退了，欺骗我感情<br>其实比起凄凉，我对他们的离开更多的是愤怒QWQ</p><p>下阙是我自己写的，即便是我独自一人，即便道路上布满荆棘，还是想要去更高，更广阔的地方去看看呐，每每看到别人的励志或者是退役的文章，总是有一股难以言表的感情涌上心头（微雨），但是总能激励我继续前行（沾衣热）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[P4886]快递员</title>
    <link href="/2019/03/16/%5BP4886%5D%E5%BF%AB%E9%80%92%E5%91%98/"/>
    <url>/2019/03/16/%5BP4886%5D%E5%BF%AB%E9%80%92%E5%91%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4886">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个<del>淀粉质</del>点分治有点意思，与其他的点分治的题目不同的是，这题目并没有让你费劲心思怎么去用log的复杂度进行内层的统计，而是让你想到如何确定当前答案是否最优。<br>（下面不会讨论点分治的具体实现，此题不适合作为点分治入门题）</p><p>在此我们可以将情况分为两种：</p><ol><li><strong>点对内</strong><br><img src="http://bubbleioa.top/wp-content/uploads/2019/03/4886-1.png"><br>如图，我们的树长这样（假设边权全部为1），标红的是一对点对(6,7)，当前的根为1<br>现在的问题是，当前求出来的答案 $ans=4$ 是最优答案吗？<br>是！<br>显然如果如果往2或5走并不会影响答案，而往其他子树走，答案都要增加。<br>这时输出最优答案  </li></ol><p>（开始复读）</p><ol start="2"><li><strong>点对间</strong><br><img src="http://bubbleioa.top/wp-content/uploads/2019/03/4886-2.png" alt="图2"><br>如图，我们的树长这样（假设边权全部为1），标红的是一对点对(8,7)，标绿的是另一对(6,4)，当前的根为1<br>现在的问题是，当前求出来的答案 $ans=6$ 是最优答案吗？<br>是！<br>显然如果如果往绿点或5红点走并不会影响答案，而往其他子树走，答案都要增加。<br>这时输出最优答案</li></ol><p>（复读结束）</p><p>但是还没完，就刚刚两个点对的那幅图来说，我们显然不希望走没有点对经过的边，因此你可以看到 $solve$ 函数中最后并没有对每个子树都递归。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>代码有点虚长，都是假的^_^</p></blockquote><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int N=200003,M=290003;int Head[N],to[M],val[M],Nt[M],tot;int size[N],d[N],b[N];bool v[N],w[N];pair&amp;lt;int,int&amp;gt;points[N];int n,m;int root,now_part,ans=2147483647;struct Tstack&#123;    int num[N],p;    int top()&#123;        return num[p];    &#125;    void pop()&#123;        p--;    &#125;    void push(int x)&#123;        num[++p]=x;    &#125;    void clear()&#123;        p=0;    &#125;    int size()&#123;        return p;    &#125;&#125;s;int read()&#123;    int x=0,f=1;char ch=getchar();    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;void add(int x,int y,int z)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    val[tot]=z;    Head[x]=tot;&#125;void find_root(int x,int S)&#123;    v[x]=1;size[x]=1;int max_part=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(v[y]||w[y])continue;        find_root(y,S);        size[x]+=size[y];        max_part=max(size[y],max_part);    &#125;    max_part=max(max_part,S-size[x]);    if(max_part&amp;lt;now_part)&#123;        now_part=max_part;        root=x;    &#125;&#125;void dfs(int x,int fa,int rt)&#123;    b[x]=rt;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(y==fa)continue;        d[y]=d[x]+val[i];        dfs(y,x,rt);    &#125;&#125;void solve(int x)&#123;    if(w[x])&#123;        printf(&amp;quot;%d\n&amp;quot;,ans);        exit(0);    &#125;    w[x]=1;    d[x]=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        d[y]=val[i];        dfs(y,x,y);    &#125;    int maxx=0,last=0;    for(int i=1;i&amp;lt;=m;i++)&#123;        int x=points[i].first,y=points[i].second;        if(d[x]+d[y]&amp;gt;maxx)&#123;            maxx=d[x]+d[y];            s.clear();            s.push(i);        &#125;        else if(d[x]+d[y]==maxx)&#123;            s.push(i);        &#125;    &#125;    ans=min(ans,maxx);    while(s.size())&#123;        int i=s.top();s.pop();        int x=points[i].first,y=points[i].second;        if(b[x]!=b[y])&#123;printf(&amp;quot;%d\n&amp;quot;,ans);exit(0);&#125;//in points        else if(!last)last=b[x];        else if(last!=b[x])&#123;printf(&amp;quot;%d\n&amp;quot;,ans);exit(0);&#125;//between points    &#125;    memset(v,0,sizeof(v));    now_part=2147483647;    find_root(last,size[last]);    solve(root);&#125;int main()&#123;    n=read();m=read();    for(int i=1;i&amp;lt;n;i++)&#123;        int x,y,z;        x=read();        y=read();        z=read();        add(x,y,z);        add(y,x,z);    &#125;    for(int i=1;i&amp;lt;=m;i++)&#123;        int x,y;        x=read();y=read();        points[i]=make_pair(x,y);    &#125;    now_part=2147483647;    find_root(root=1,n);    solve(root);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】快速傅里叶变换(FFT)</title>
    <link href="/2019/03/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2(FFT)/"/>
    <url>/2019/03/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2(FFT)/</url>
    
    <content type="html"><![CDATA[<h1 id="0-0-前言"><a href="#0-0-前言" class="headerlink" title="0.0 前言"></a>0.0 前言</h1><h2 id="0-1-关于本篇文章"><a href="#0-1-关于本篇文章" class="headerlink" title="0.1 关于本篇文章"></a>0.1 关于本篇文章</h2><p>本篇文章写作主要有两个目的，一是本人想对这一块的知识进行系统的梳理，还有就是将《算法导论》上的知识写成更适合OIer学习的格式（这本书由于各种原因是真的难啃）</p><p>为了方便阅读理解，在看本篇文章的时候我们规定一些标记：</p><ol><li><p>重点难点强调将以<strong>加粗</strong>形式标注</p></li><li><p>长篇幅引用将以如下形式标注：</p><blockquote><p>我是引用内容</p></blockquote></li><li><p>*(括号斜体)*中内容为原书没有，本人为了方便理解，在不改变意思的情况下加上的内容，如果有误欢迎联系我</p></li><li><p>循环变量将优先使用j表示，i要作为虚数单位。</p></li><li><p><font face='STKaiti'>楷体字为定理或引理</font></p></li></ol><h2 id="0-2-FFT是用来干什么的？"><a href="#0-2-FFT是用来干什么的？" class="headerlink" title="0.2 FFT是用来干什么的？"></a>0.2 FFT是用来干什么的？</h2><p>将多项式乘法从 $O(n^2)$ 加速到 $O(nlogn)$ 。</p><h2 id="0-3-前置知识"><a href="#0-3-前置知识" class="headerlink" title="0.3 前置知识"></a>0.3 前置知识</h2><p>有以下的只是基础会让你的学习变得更加轻松</p><ol><li>复数</li><li>多项式基本概念</li><li>矩阵基本运算</li></ol><h2 id="0-4-基本原理框架"><a href="#0-4-基本原理框架" class="headerlink" title="0.4 基本原理框架"></a>0.4 基本原理框架</h2><p>为了更方便地理解下面每个概念的意义，先给出算法实现的大体框架：<br><img src="http://bubbleioa.top/wp-content/uploads/2019/03/FFT.png"></p><h1 id="1-0-多项式"><a href="#1-0-多项式" class="headerlink" title="1.0 多项式"></a>1.0 多项式</h1><h2 id="1-1-多项式基本概念"><a href="#1-1-多项式基本概念" class="headerlink" title="1.1 多项式基本概念"></a>1.1 多项式基本概念</h2><p>为了让我们对多项式的基本概念达成共识，这部分简单内容还是稍微提下：</p><ol><li>多项式表示：$A(x)=\displaystyle\sum_{j=0}^{n-1}a_jx^j$</li><li>多项式的系数：其中， [latex]{a_0,a_1,\cdots,a_{n-1} }[/latex] 被称为<strong>系数</strong>，<strong>所有系数都属于复数集合C</strong>  </li><li>多项式的次数： $A(x)$ 的具有非零系数的最高次的次数，记为 $degree(A)$ </li><li>次数界：<strong>任何</strong>一个严格大于次数的整数<br>这就是一般的多项式，如果拿来相乘的话，时间复杂度为$O(n^2)$</li></ol><h2 id="1-2-多项式的表示"><a href="#1-2-多项式的表示" class="headerlink" title="1.2 多项式的表示"></a>1.2 多项式的表示</h2><h3 id="1-2-1-系数表达"><a href="#1-2-1-系数表达" class="headerlink" title="1.2.1 系数表达"></a>1.2.1 系数表达</h3><p>多项式 $A(x)=\displaystyle\sum_{j=0}^{n-1}a_jx^j$ 的系数表达为一个由系数组成的向量 $a=(a_0,a_1,\cdots,a_{n-1})$<br>这也是我们平时最常用的表达方式。</p><h3 id="1-2-2-点值表达"><a href="#1-2-2-点值表达" class="headerlink" title="1.2.2 点值表达"></a>1.2.2 点值表达</h3><blockquote><p>一个次数界为 $n$ 的多项式 $A(x)$的点值表达就是一个由 $n$ 个点值对所组成的集合</p></blockquote><center>[latex]\left\{ (x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1}) \right\}[/latex]</center>使 $k=0,\ 1,\ 2, \cdots, n-1$ 所有的 $x_k$ 各不相同，$$y_k=A(x_k)$$一个多项式可以有很多不同的点值表达。<p>在求点值表达的时候我们可以使用秦九韶算法，但这样的做法的时间复杂度任然是 $O(n^2)$ 之后我们将会讨论如何优化这一过程。<br>求值计算的逆运算称为<strong>插值</strong>。</p><h3 id="1-2-3-插值多项式的唯一性（可跳过）"><a href="#1-2-3-插值多项式的唯一性（可跳过）" class="headerlink" title="1.2.3 插值多项式的唯一性（可跳过）"></a>1.2.3 插值多项式的唯一性（可跳过）</h3><blockquote><p><font face='STKaiti'>对于任意 $n$ 个点值对组成的集合 [latex]{(x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1})}[/latex] ，其中所有的 $x_k$ 都不同；那么存在唯一的次数界为 $n$ 的多项式 $A(x)$ ，满足 $y_k=A(x_k),k=0,1,\cdots,n-1$ 。</font></p></blockquote><blockquote><p><strong>证明</strong> 证明主要是根据某个矩阵存在逆矩阵。<br>$$\begin{bmatrix}1&amp;x_0&amp;x_0^2&amp;\cdots&amp;x_0^{n-1}\1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1}\\vdots&amp;\vdots&amp;\vdots&amp;\cdots&amp;\vdots\1&amp;x_{n-1}&amp;x_{n-1}^2&amp;\cdots&amp;x_{n-1}^{n-1}\end{bmatrix}\begin{bmatrix}a_0\a_1\\vdots\a_{n-1}\end{bmatrix}=\begin{bmatrix}y_0\y_1\\vdots\y_{n-1}\end{bmatrix}$$<br>左边矩阵的行列式值为：<br>$$\displaystyle\prod_{0\le j&lt; k\le n-1}(x_k-x_j)$$</p></blockquote><p>下略（需要用到矩阵相关知识，这一部分内容超出本人理解范围，而且不影响我们的算法）</p><h1 id="2-0-单位复数根"><a href="#2-0-单位复数根" class="headerlink" title="2.0 单位复数根"></a>2.0 单位复数根</h1><h2 id="2-1-单位复数根的定义"><a href="#2-1-单位复数根的定义" class="headerlink" title="2.1 单位复数根的定义"></a>2.1 单位复数根的定义</h2><p>单位负数根就是我们之前说的选的特殊值，它具有一些神奇的性质以至于我们可以分治的方法，来用它求点值表达。<br>我们定义<strong>n次单位复数根</strong>是满足 $\omega_n=1$ 的复数 $\omega$ 。<br>为什么这样定义呢？我们现在需要用到<strong>欧拉公式</strong>：<br>$$e^{iu}=cos(u)+isin(u)$$</p><p>如下图（ $\omega$ 表示的是 $\omega_8^1$ 其他的都是它的次幂），说明 $n$ 个单位复数根均匀地分布在以复平面的<strong>原点为圆心的单位半径的圆周</strong>上<br>$$\omega_n=e^{\frac{2\pi i}{n}}$$</p><div id="applet_container"></div><script src="http://ggbstudy.top/ggb/deployggb.js"></script><script>new GGBApplet({"ggbBase64":"UEsDBBQACAgIAMqDbU4AAAAAAAAAAAAAAAAXAAAAZ2VvZ2VicmFfZGVmYXVsdHMyZC54bWztWt9zmzgQfr7+FRqeeg+xAYNxMiGdtDM3l5k0zVwynb7KsMa6gMQhEeP89SckDDj+Ucd2EydNHiJWrIT0favdleTTT0USo3vIOGHUN6yOaSCgAQsJjXwjF6OjgfHp7MNpBCyCYYbRiGUJFr7hlpp1Oyl1ep5T1qGCkxPKrnACPMUB3ARjSPAlC7BQqmMh0pNudzKZdGaddlgWdaNIdAoeGkgOiHLfqB5OZHdzjSY9pW6bptX98fVSd39EKBeYBmAgOdgQRjiPBZePEEMCVCAxTcE3UkaoMFCMhxD7xnUpoY+jDOBPA1WNJAamcfbhj1M+ZhPEhv9CIOtElkPdTgndUke+/sJilqHMNzzPQJEuhr5hu66BcJyOsW+YWjnGU8jQPY7rGpwLFqj2qnaEYw4zXfmlrywE/cap9ClJFIqIC0jlSA3EU4BQPekZyodUfkix1+qP8JsxTmHhOwFjWchR4RtX+MpA06p80KVSUZjdkIeqsduuFdMYWjM67VZwbwZ8CCnQUCrNoW9thX5/oNAvi6Eu3iL4zr7A/0bbkNtbQW7ZrsJcle8mvwHqF/QfiORc2tj33rF/FuznLd7ZCnVTYW6+McSVisaWl/99I2BJGkOxR0JiQhtwL5VQk2FvF2/bZJgvQoW5dypKmDSoYkyCOwqcl4g33ysf/iahDJpqHEwmWETInixvoHuA/+gclUQySaTOeno4RKVUI34zkxuStgvL7yQtI4nlIi5HdEGFTKAllnIGfGEodwDprezqG73NMOVl4q11ZlCv5jPD03Vcuu9cvh4uRzlVnV59x1nNUC7z5pEce9imdbtUYmVQ69juoXL7c7TWI7V7+H8VC+CJ1r0fM+xv511s01kOb8d7hWZ4L6fNGpy+V2INUu8959mfC16SwOJMACeY/mybEE+jlq+4nsk1T57mafcxPnmD5/YU1661sB4sU/9ZzrFpWX25ez9Q+tcDP7cluK4rGuitF4L+QBfZajQDRklQT+qLlmocnd/E1exh70QioNpzc4QKU6lNTdX4wawOxwtLyVNLvX2wdLVqLyeUkQKd6xbnWvHc1kVPF44u3Bq47TZsivJUerlWmv8oxDjb7djeguN5k8bwDFsNmieQtVzJ1UyujcrVzkT2l8Mc5Ru4jlX2s9paeExCaVoJkSQdSfYSXCgW8ZCzOBdwE2QAtLla0uY9IaEYlwml/PaIFKUZ6T7RmGXkgVFRo4HK1XEeq0uo9oJYaj72usR50YjlfHf27JhGcbNgz7XUkKHP7ZXS46O4ZRy14TQrNPsde9CzBm7P9Czv2B30N0TXGjTo6hcbgzvnkSpmNghFlrmxRe3ukZ7kP+xl/gNnQXNo2jNX2Yg58Ox+3+nb7vGxZ/Udb2ebWdgB/1VXNHu0l8gJWstrKebKmh6r/ioHv+aomgU5b86qtVQjN/hNsimcFyQmOJs+I/ICiiafuVVC61L+AIFfPRVJR9QM7UJLrTtuPZkRkShSnMgGFRv0Mw7uoozlNFyMhnuZunWoNrcazCFjMeDGoX2eya0b7IW8ZBVwmwecX7ZagzEEd0NWzMXP9T6J8GZlXCqhdYO8ZGXsElaPDtZEtjnR3PQC82jh/LPb+hlRd/ZTpbP/AVBLBwh/yyUBwQQAADElAABQSwMEFAAICAgAyoNtTgAAAAAAAAAAAAAAABcAAABnZW9nZWJyYV9kZWZhdWx0czNkLnhtbO1X3U7bMBS+Hk9h+Z7Gzk9LUQOq2MUmARriZrductpkS+1gu23Kq+0d9kxz7DSk0E6jKkKayEWOf86P/X0nx87ospoXaAlS5YLHmPYIRsATkeZ8FuOFnp6e4cuLk9EMxAwmkqGpkHOmYxzVmq2d6fWCQViPoUrl51zcsjmokiVwn2QwZ9ciYdqqZlqX5563Wq16G6c9IWfebKZ7lUoxMgviKsZN49y42zJaBVbdJ4R632+unfvTnCvNeAIYmcWmMGWLQivThALmwDXS6xJinAieJ4GJUbAJFDH+yrXZAST1ylCykEtj3xjHOKARwRcnn0YqEyskJj+MXoy1XEBrbzterWOmr0QhJJIx9qMII4Me9QcYTWJsQGFFmTHT6lHiHhoOCaV96jvzgq1BoiUram07whZaJNajHZ2yQsFG18S+ESm4mbDR5/ncIoyUhtIEx0iVAKltud2bdZQmkGW24y9X9xkr4WWcnMO9XheAdJYnPzkow0rUcVY3vuRpCnXiOBvIZ8CXBighlckEYqOviVV/JE1+VdT219TOPlI3bO3NFmReobGzGDvFse9E4EToRNRCBQ/crVPV7xiXTJrkM46Sen7kNTnwIhtYlatOMozr7uetBCDBQQlALP3kOfn/GdX7UUdNGwwWv3/9nQT71SVMalA54x06ruqJ53z0P/jYzcd+gE1cDh1cv9n+Fq6mlh6E63BogfXp0EJrZVvpomPBuw+kRAiZKlS5YuJKjH2v2lBTVp9jTfS9tXcX2ORAsEWxziCVgj/h3Rl6gjxoID/ky3stTTQKLE8RfXEchQ0k0bBPwn54NM6O/UnsR5yDbrd/W7e7GEcfGB8D44cFS21dbyC42/S7WNPD7kok3F2ce4M3LyBvccHZeb2pB90dZu3Eo986fO2NB437TgycOHNi2KCzn0S1kFNzHd911DZT23yG78Xnk+N3PW7pv54AXud3w9v80lz8AVBLBwhyzZtN2QIAAFkNAABQSwMEFAAICAgAyoNtTgAAAAAAAAAAAAAAABYAAABnZW9nZWJyYV9qYXZhc2NyaXB0LmpzSyvNSy7JzM9TSE9P8s/zzMss0dBUqK4FAFBLBwjWN725GQAAABcAAABQSwMEFAAICAgAyoNtTgAAAAAAAAAAAAAAAAwAAABnZW9nZWJyYS54bWzdW91u2zgWvu48BaGrZBHbJEVSUmF3kP5hBugUxWZ3sNiLAWSJttnIkiDJPynmYi/2Zp5m3mT6DvMke0hKtmK7TZSkGWenVSlRh+fwfN/hOUdIZvj9ep6gpSxKlaUjh/Sxg2QaZbFKpyNnUU16vvP9i++GU5lN5bgI0SQr5mE1criW3KyDp77rMT2n4pGDmf+av339tke497LH3rzlveBN4PVev/YD9yVh/NWbwEFoXarnafY+nMsyDyN5Ec3kPHyXRWFllM6qKn8+GKxWq35jvp8V08F0Ou6vy9hBsPW0HDn1zXNQd23RyjXiFGMy+NdP76z6nkrLKkwj6SDt1kK9+O7ZcKXSOFuhlYqrGYDACXXQTKrpTDsagFMDLZWDt7mMKrWUJaxtPRqnq3nuGLEw1e+f2TuUbPxxUKyWKpYFANSnnLiUept/mYOyQsm0qoVJbXTQqBsulVxZvfrOmGQ48IAFVapxIkfOJExK8EulkwIw3TyX1VUixyGYrYoFPG93RM7MHxBRn6RWB65aLOAdxmf68uDivMagZduAVGVZYjRj9CsiiGO4EAnQGRIezFBEOGIw48OMh1w9xwlDLtIixEWMwcj0NBH6HYf1HCNCYBpRjChFlCDqwiPniAvEPb2QgqwIjDIMl5aG7cDl6jnXhcvMuQwuqu9AEbdqYBPcFeaOa2nQz6nevpl0fcQCMKQnuEeQC3uAZw8j0Ohq9cQ4wTDSfwliWj31EPUR6AO/tWZMu7BST+zQ0pDCD5Ei4DJs7ZDCrlMCDGDw7UwPxA7UzmL7iF07UDswO3Arw+xKZkWto5hZGebe18PGP7eLf37LP6KdAD707s3gIr1vYvavB1Y/CvtoogwTXM/6djbQj+Kezrh3coa0rNqT2cVoY5IQym5vk97H5tZNv4ub90T3ILYckpL+a649k26n87eXFe9gUVw7eQ/jMPNvbZ5Q/9FtevhgsrEjqceHISK4PRH3TUwbIPjXTQ4HTT0e1iCgcqZlG5uVnJcaF89Fgm6qo9D1qy6RHkUeR55oFcozXSoF31ZLXSv9a9WS+62SCfVS6EnP1F8oUrrg2fJJWVNBz+oa+uteDYWSx7ZVDzaoVRGEoEQjoRNkXf5gF3RTACnXNZAKBEWSUyR0Ev5CLXRQnpVqg+xMJvkGIAOiSvNFdR24aB43kVBlIB4mpvOrF8RZdPlyF2sZllVbLzRN297MNlHXWrdnwyQcywRa3AsdCQgtw0SfWmNhkqUVanKrcIw60yYO5SJKVKzC9GdgvunI3i/mY1kgc5tpL40SvRxt+klC3VY/6QdWJsqyIr64KiFQ0Prfssh00Pl94QUehaaLeUI3hVf2jSv8PqXQGxEWYJdxziFQo1AHOeWiH/Ag4B4T+jWsOfgG1lrDcnkhqwq8L1G4lmWD9rRQcfv+x/JllsQbXPNMpdWrMK8Whfk2AJcK7dF5Ok2kwdFwDE12dDnO1hcGQCqsrn9c5TqfWvvj6assyQpU6B2CH9N6HNvRyOiNbaSwkcFGomZJK928JwE1EmYc29FIAcV2a7WjpPESN1ZUaT9YnDqi6hSkw0M37ItUVe+ah0pFl1tHtbwlv0HwukryQCqHg524G9YnoonCeRZLG8Gulb/2fngpi1QmWnBRytJ9bUW3G44g3lW6yBalfWPpHtQLPoTV7DyN/y6ncIg/hDqNVrC9XSWxjNQcFtr5Gv1QR8Y/wV07G8tpIRuU7BYtN/XeUZkXMozLmZTVhiF7SLZi2LrYODUso0LlOpbRGJL4pdzGa6zKEIpA3PJI+1rCpiOdkQD7SuPuoHBRzbLCfJ+FlZ7RZ30Nmyn1x61lDo2cz79BpllDRvrzv7//cnJyQtHf0Of/nMK/f/yOBsg/PQU+TZybo2IMykTO4Zvu2nwTCqDPpAogHWXjj5CddmJlCy+8PngYzLEJk3wWbgBLwiudjloJzWj7aRMkTeinQJjBARJQbsMvl9IGrt0u3OSgzpz2VlSo8mIW5nIvWgxVJVrrr1sPewQLzyfEFxwyGeSkA9Ow+U+blNliurQnIsrmeSLX9rXBTicVa5e3Z/fCo4b9AI9QT2oWP//2ywndoQzdxFl4J8qEbzjTw9gOd+PsZuRFH2oNdV2d813hCSF7xDPgk7tjze6M9biFtdsV6/GRY907FM+Hwlx8e+hBxzxMY5SaNvfHVOdoQMzZ9lghHjnrcyhOAAgZOVfm1qK3qBqBc6u31nYDP+dHzg+2bLTBfxB0fwZXs2IH2nMLK+T0XUwXX8d0abU1oC3uXRPwN0S0U15vjG16sGoG3U4KGUKn79p9bG9+UHEs7UdCloeRqnTG8vwvHpmwqGQJHVHdbVfw/EGzaNPN+d0JDPf4W3bib3nM/N1UHZ4kY+M9xladGFsdM2Mda8wREbjfDEStZoB1bQaiIy82PWLPEXykM8HgGz4gzHO5S+GIPUL930c7bqHNu6IdHzvae/Fv09jB4/L42MsW9qIr9vLYsSd93xWBh0nge5RgGng2xq/sKXh8uCctuL2ucE+OHO69iGZfiHTvr4B+2oLe7wr99Mihtym9R/uMBTRweeDTgHlYsMfJ6bdvgaZ7LdCsUws0O+YW6GYWjqjruT1nkz3OVCfO1DFz1jFpPUkC5R6BHzsR+PGYCbxFkX+SpMV7pF12Iu3yqEnr2BU/SQajPQaTTgwmR83gjV+RR8TZ11o7u+4klrlMYQ/V6V/a6n3Ln3W9D98bzsz4yY4P2WOjkfNqUSybT0pzf7I+RSNUW9rhYbJIzY83N9Da1beAH8nlZpsPHvsTtZbx7k+Nv4TufaP7a1GaXM1kXLTwOS+imZrLWELg38H44C6BTQkxoDLPoKqHBtY+w/Y/HggMSYA/eKjjLqHeCcoPV0U4V/EjwhgYGAMLI8X/JzAWqpw/IojC/gqOBTEQTwLEQftXOcyvaNX/h8CL/wFQSwcI2Tf6BKAIAADSMAAAUEsBAhQAFAAICAgAyoNtTn/LJQHBBAAAMSUAABcAAAAAAAAAAAAAAAAAAAAAAGdlb2dlYnJhX2RlZmF1bHRzMmQueG1sUEsBAhQAFAAICAgAyoNtTnLNm03ZAgAAWQ0AABcAAAAAAAAAAAAAAAAABgUAAGdlb2dlYnJhX2RlZmF1bHRzM2QueG1sUEsBAhQAFAAICAgAyoNtTtY3vbkZAAAAFwAAABYAAAAAAAAAAAAAAAAAJAgAAGdlb2dlYnJhX2phdmFzY3JpcHQuanNQSwECFAAUAAgICADKg21O2Tf6BKAIAADSMAAADAAAAAAAAAAAAAAAAACBCAAAZ2VvZ2VicmEueG1sUEsFBgAAAAAEAAQACAEAAFsRAAAAAA==","borderColor":null,"enableShiftDragZoom":false,"enableRightClick":false,"width":1000,"height":773}, 'applet_container').inject('html5')</script><p>细心的读者可能已经发现，在这 $n$ 个单位复数根内，似乎它们总是成对存在（比如 $\omega_8^8$ 和 $\omega_8^4$ ），这是不是意味着我们能分治地去处理求值问题呢？</p><h2 id="2-2-0-三大引理"><a href="#2-2-0-三大引理" class="headerlink" title="2.2.0 三大引理"></a>2.2.0 三大引理</h2><p>在这一小节中，将介绍单位复数根的三大引理，这也是降低算法时间复杂度的关键。</p><h3 id="2-2-1-消去引理"><a href="#2-2-1-消去引理" class="headerlink" title="2.2.1 消去引理"></a>2.2.1 消去引理</h3><blockquote><p><font face='STKaiti'>对于任何整数 $n\ge 0, k\ge 0, d&gt;0$，总有</font><br>$$\omega_{dn}^{dk}=\omega_{n}^{k}$$</p></blockquote><p><strong>证明</strong>    首先我们可以形象地理解这个结论，假设我把单位圆分成 $n$ 份，从 $\omega_{n}^{0}$ 开始，取第 $k$ 份，和我把单位圆分成 $dn$ 份，从 $\omega_{dn}^{0}$ 开始，取第 $dk$ 份是不是取到的边是一样的？ 如果你喜欢严谨一点的话，下面的推导式子也不难理解。<br>$$\omega_{dn}^{dk}=(e^{\frac{2\pi i}{dn}})^{dk}=(e^{\frac{2\pi i}{n}})^k=\omega_{n}^{k}$$</p><h3 id="2-2-2-折半引理"><a href="#2-2-2-折半引理" class="headerlink" title="2.2.2 折半引理"></a>2.2.2 折半引理</h3><blockquote><p><font face='STKaiti'>如果 $n&gt;0$ *(且)*为偶数，那么 $n$ 个 $n$ 次单位复数根的平方的集合就是 $n/2$ 个 $n/2$ 次单位复数根的集合</font></p></blockquote><p>从上面的文字来理解其实是有点抽象的，其实根据图像这个结论是显然的，在图像上，这个引理就是(下面虽然是引用但是是本人总结的)：</p><blockquote><p><font face='STKaiti'>我们称单位复数根与实轴正半轴的角为夹角，那么一个单位复数根逆时针转动两倍的夹角会等价于，它先转过180°，再转过两倍的夹角</font></p></blockquote><p><strong>证明</strong>    $$(\omega_n^{k+n/2})^2=\omega_n^{2k+n}=\omega_n^{2k}\omega_n^n=\omega_n^{2k}=(\omega_n^{k})^2$$</p><p>有了它，就可以进行分治了。<br>只要运用以上两个引理，就可以进行快速求值，因此建议读者先跳过求和引理，等到需要的时候再回头看(其实不是很难)。</p><h3 id="2-2-3-求和引理（建议先跳过）"><a href="#2-2-3-求和引理（建议先跳过）" class="headerlink" title="2.2.3 求和引理（建议先跳过）"></a>2.2.3 求和引理（建议先跳过）</h3><blockquote><p>对于任意整数 $n\ge1$ 和不能被 $n$ 整除的非负整数 $k$ ，有<br>$$\displaystyle\sum_{j=0}^{n-1}(\omega_n^k)^j=0$$</p></blockquote><p>这些引理一个比一个抽象……但是不难发现，如果把图中复平面内的向量全部加起来，就是一个零向量，<strong>显然</strong>成立QWQ</p><p>好吧 还是给出严谨的证明</p><p><strong>证明</strong> 等比数列求和公式不但适用于实数，也适用于复数，因此：<br>$$\displaystyle\sum_{j=0}^{n-1}(\omega_n^k)^j=\frac{(\omega_n^k)^n-1}{\omega_n^k-1}=\frac{(\omega_n^n)^k-1}{\omega_n^k-1}=\frac{(1)^k-1}{\omega_n^k-1}=0$$</p><h1 id="3-0-FFT的递归实现"><a href="#3-0-FFT的递归实现" class="headerlink" title="3.0 FFT的递归实现"></a>3.0 FFT的递归实现</h1><h2 id="3-1-DFT离散傅里叶变换"><a href="#3-1-DFT离散傅里叶变换" class="headerlink" title="3.1 DFT离散傅里叶变换"></a>3.1 DFT离散傅里叶变换</h2><p>被上面的一团东西搞晕了？别忘了我们的目的是什么？对，求值（最终目标是实现 $O(nlogn)$ 的多项式乘法)</p><p>普通求值的复杂度是平方级别的，那是基于随机选点（或者叫做随意选点）。</p><blockquote><p>现在，我们希望计算多项式<br>$$A(x)=\displaystyle\sum_{j=0}^{n-1}a_jx^j$$<br>在 $n$ 个 $n$ 次单位复数根处的值。<br>现在多项式还是以系数的形式给出 $a=(a_0,a_1,\cdots,a_{n-1})$ ,定义结果为 $y_k$:<br>$$y_k=A(\omega_n^k)=\sum_{j=0}^{n-1}a_j\omega_n^{kj}$$</p></blockquote><p>我们称 $y$ 就是 $a$ 的<strong>离散傅里叶变换</strong>(DFT)<br>我们记作 $y=DFT_n(a)$</p><h2 id="3-2-FFT能够快速实现的奥秘"><a href="#3-2-FFT能够快速实现的奥秘" class="headerlink" title="3.2 FFT能够快速实现的奥秘"></a>3.2 FFT能够快速实现的奥秘</h2><p>假设 &amp;n&amp; 为2的整数幂  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>省选倒计时</title>
    <link href="/2019/03/06/%E7%9C%81%E9%80%89%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <url>/2019/03/06/%E7%9C%81%E9%80%89%E5%80%92%E8%AE%A1%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<p>[wpcdt-countdown id=”719”]</p><p>JXOI2018 考点：<br>游戏： 数学（组合数，逆元），主要考察综合数学能力，会将题目转化为数学计算式，并且进行优化求解<br>守卫： 动态规划，这三题里面最简单的一题<br>排序问题： 数学（期望），贪心，哈希</p><p>JXOI2017 考点：<br>颜色： 统计题（线段树），求点对贡献<br>数列： 动态规划<br>加法： 二分</p><p>JXOI2017整体来讲码量较大，而JXOI2018则思维难度较大，在只有4个小时不到的时间里能写完两题都有点难度<br>这两年的考点中都有动态规划，并且难度适中，而数学考察的难度则有很大，本蒟蒻瑟瑟发抖</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>点分治学习笔记</title>
    <link href="/2019/03/01/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/03/01/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p><del>淀粉质</del>点分治是一种统计方法，具体来说，是对树上的点的一些值来进行统计，标准的点分治统计复杂度为 $O(Nlog^2N)$ 是解决树上疑难杂症的不三之选（还有一个是树形dp）</p><h2 id="算法思路-amp-amp-具体问题"><a href="#算法思路-amp-amp-具体问题" class="headerlink" title="算法思路&amp;&amp;具体问题"></a>算法思路&amp;&amp;具体问题</h2><p><a href="https://www.luogu.org/problemnew/show/P3806">【洛谷P3806】点分治</a></p><blockquote><p>给你一棵树，有m个询问，每个询问包含一个k，问树中是否存在距离为k的点对</p></blockquote><p>这是一道很好的模板题，在这道题里面，我们具体关注点分治的想法与实现，其中有些地方复杂度会爆炸（还是能过），这里我们不做讨论</p><p>很容易得到一个 $O(N^2)$ 的算法，我们首先选一个点，然后再枚举第二个点。</p><p>但是别忘了，这是一棵树。</p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=88a02b436d061d95694b3f6a1a9d61b4/e4dde71190ef76c6864ea9509e16fdfaaf516728.jpg" alt="随便一颗树"></p><p>假设最上面的那个节点是根，那么所有经过它的所有路径有什么特点？</p><ol><li>以它为端点。</li><li>经过它。</li></ol><p>把这些路径统计起来后，对于每个子树也统计这样的路径（注意要把根删掉），不断进行这样的分治，路径就被不重不漏地统计出来了<br>基于分治的思想，我们需要用树的重心来作为根。</p><p>于是这一题就轻松地写出来啦</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=10003;int Head[MAXN],Nt[MAXN&amp;lt;&amp;lt;1],to[MAXN&amp;lt;&amp;lt;1],val[MAXN&amp;lt;&amp;lt;1],tot;int size[MAXN],d[MAXN],a[MAXN],b[MAXN];bool w[MAXN],v[MAXN],ap[10000003];//ap用来保存出现过的路径长度，w数组用来表示删去的根节点int n,m,k[MAXN],now_part,root;int all;void add(int x,int y, int z)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    val[tot]=z;    Head[x]=tot;&#125;void find_root(int x)&#123;//寻找树的重心    v[x]=1;    size[x]=1;    int max_part=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(v[y]||w[y])continue;        find_root(y);        size[x]+=size[y];        max_part=max(max_part,size[y]);    &#125;    max_part=max(max_part,all-size[x]);    if(max_part&amp;lt;now_part)&#123;        now_part=max_part;        root=x;    &#125;&#125;void dfs(int x,int deep)&#123;    v[x]=1;    if(b[x]==0)b[x]=x;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i],z=val[i];        if(w[y]||v[y])continue;        a[++a[0]]=y;        if(deep&amp;gt;0)b[y]=b[x];        else b[y]=y;        d[y]=d[x]+z;        ap[d[y]]=1;        dfs(y,deep+1);    &#125;&#125;void work(int x)&#123;    memset(v,0,sizeof(v));    memset(d,0,sizeof(d));    memset(b,0,sizeof(b));    w[root]=1;    a[0]=0;    dfs(x,0);//统计路径（以根为端点）    for(int i=1;i&amp;lt;=a[0];i++)&#123;//这里复杂度会爆炸        for(int j=i;j&amp;lt;=a[0];j++)&#123;            ap[d[a[i]]]=ap[d[a[j]]]=1;            if(j!=i&amp;amp;&amp;amp;b[a[i]]!=b[a[j]])ap[d[a[i]]+d[a[j]]]=1;//统计路径（经过根），b相同说明在同一个子树，不统计        &#125;    &#125;    for(int i=Head[root];i;i=Nt[i])&#123;//分治        int y=to[i];        if(w[y])continue;        all=size[y];        root=0,now_part=1&amp;lt;&amp;lt;30;        find_root(y);        work(root);    &#125;&#125;    int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);all=n;    for(int i=1;i&amp;lt;n;i++)&#123;        int x,y,z;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);        add(x,y,z);        add(y,x,z);    &#125;    for(int i=1;i&amp;lt;=m;i++)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k[i]);    &#125;    now_part=1&amp;lt;&amp;lt;30;    find_root(1);    work(root);    for(int i=1;i&amp;lt;=m;i++)&#123;        if(ap[k[i]])printf(&amp;quot;AYE\n&amp;quot;);        else printf(&amp;quot;NAY\n&amp;quot;);    &#125;    return 0;&#125;</code></pre><p>轻松的A了上面一题之后，突然觉得点分治很简单（然而这只是我的错觉），这是因为上面的点分治是“假的”，下面这一题可以说明问题出在哪</p><p><a href="https://www.luogu.org/problemnew/show/P2634">【P2634】聪聪可可</a></p><blockquote><p>给你一棵树，问你有多少个点对之间的距离能被3整除</p></blockquote><p>有了上一题的经验，于是套上了点分治的模板，然后就TLE了QAQ，60Pt</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=20005;int Head[MAXN],Nt[MAXN&amp;lt;&amp;lt;1],to[MAXN&amp;lt;&amp;lt;1],val[MAXN&amp;lt;&amp;lt;1],tot;bool v[MAXN],w[MAXN];int size[MAXN],d[MAXN],b[MAXN],a[MAXN];int n,root,ans;int now_part=1&amp;lt;&amp;lt;30;void add(int x,int y,int z)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    val[tot]=z;    Head[x]=tot;&#125;void find_root(int S,int x)&#123;    size[x]=1;    v[x]=1;    int max_part=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(v[y]||w[y])continue;        find_root(S,y);        size[x]+=size[y];        max_part=max(max_part,size[y]);    &#125;    max_part=max(max_part,S-size[x]);    if(max_part&amp;lt;now_part)&#123;        now_part=max_part;        root=x;    &#125;&#125;        void dfs(int x,int step)&#123;    v[x]=1;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i],z=val[i];        if(w[y]||v[y])continue;        d[y]=d[x]+z;        if(d[y]%3==0)ans++;        a[++a[0]]=y;        if(step==0)b[y]=y;        else b[y]=b[x];        dfs(y,step+1);    &#125;&#125;        void work(int x)&#123;    w[x]=1;    memset(d,0,sizeof(d));    memset(v,0,sizeof(v));    a[0]=0;    dfs(x,0);    for(int i=1;i&amp;lt;=a[0];i++)&#123;        for(int j=i+1;j&amp;lt;=a[0];j++)&#123;            if(b[a[i]]!=b[a[j]]&amp;amp;&amp;amp;(d[a[i]]+d[a[j]])%3==0)ans++;//问题出在这        &#125;    &#125;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(w[y])continue;        memset(v,0,sizeof(v));        find_root(size[y],y);        work(y);    &#125;&#125;int gcd(int a,int b)&#123;    return b?gcd(b,a%b):a;&#125;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;n;i++)&#123;        int x,y,z;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);        add(x,y,z);add(y,x,z);    &#125;    find_root(n,1);    work(root);    ans*=2;    ans+=n;    int g=gcd(ans,n*n);    printf(&amp;quot;%d/%d&amp;quot;,ans/g,n*n/g);    return 0;&#125;</code></pre><p>问题就出在我们统计路径的时候没有做到$O(N)$，一般来说，题目中总会有些特殊的性质来帮助你在这一步可以做到$O(N)$</p><p>比如这一题，我们可以用以下策略来统计：</p><ol><li>保存d数组时保存的是 mod 3 后的余数，并统计每种值的数量储存在yu数组里面</li><li>根节点的 $yu[0]^2+2yu[1]yu[2]$ 加入答案（0+0的路径还是3的倍数，1+2的路径也是3的倍数，后面的*2是排列顺序不同，前面不*2是因为两个距离根为0的点已经被yu[0]统计了，它们都在里面）</li><li>上面一个肯定有重复（在同一子树内的点对也被统计到了），于是我们对于每一棵子树，再减去 $yu[0]^2+2yu[1]yu[2]$ （这里不是分治）</li><li>再进行分治</li></ol><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=20003;int Head[MAXN],to[MAXN&amp;lt;&amp;lt;1],val[MAXN&amp;lt;&amp;lt;1],Nt[MAXN&amp;lt;&amp;lt;1],tot;int d[MAXN],size[MAXN];int now_part;bool w[MAXN],v[MAXN];int n,root,ans;int yu[4];int gcd(int a,int b)&#123;    return b?gcd(b,a%b):a;&#125;void add(int x,int y,int z)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    val[tot]=z;    Head[x]=tot;&#125;void find_root(int S,int x)&#123;    size[x]=1;    v[x]=1;    int max_part=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(v[y]||w[y])continue;        find_root(S,y);        size[x]+=size[y];        max_part=max(max_part,size[y]);    &#125;    max_part=max(max_part,S-size[x]);    if(max_part&amp;lt;now_part)&#123;        now_part=max_part;        root=x;    &#125;&#125;void dfs(int x,int fa)&#123;    yu[d[x]]++;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i],z=val[i];        if(w[y]||fa==y)continue;        d[y]=(d[x]+z)%3;        dfs(y,x);    &#125;&#125;int calc(int x,int now)&#123;    yu[0]=yu[1]=yu[2]=0;    d[x]=now%3;    dfs(x,0);    return yu[0]*yu[0]+2*yu[1]*yu[2];&#125;void work(int x)&#123;    w[x]=1;    ans+=calc(x,0);    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(w[y])continue;        ans-=calc(y,val[i]);        root=0,now_part=1&amp;lt;&amp;lt;30;        memset(v,0,sizeof(v));        find_root(size[y],y);        work(root);    &#125;&#125;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;n;i++)&#123;        int x,y,z;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);        add(x,y,z);add(y,x,z);    &#125;    now_part=1&amp;lt;&amp;lt;30;    find_root(n,1);    work(root);    int g=gcd(n*n,ans);    printf(&amp;quot;%d/%d&amp;quot;,ans/g,n*n/g);    return 0;&#125;</code></pre><p><a href="https://www.luogu.org/problemnew/show/P4149">P4149 [IOI2011]Race</a></p><blockquote><p>给一棵树，每条边有权。求一条简单路径，权值和等于K，且边的数量最小。</p></blockquote><p>这一题其实和一开始的模板题没两样，只不过数据范围很大，统计路径的时候不能再$O(N^2)$了</p><p>用一棵平衡树来维护就行（set足够）</p><p>由于这是存在性问题，所以不用在意统计子树时的重复统计</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=200003;int n,k;int Head[MAXN],to[MAXN&amp;lt;&amp;lt;1],val[MAXN&amp;lt;&amp;lt;1],Nt[MAXN&amp;lt;&amp;lt;1],tot;int root,now_part,cnt;int size[MAXN];pair&amp;lt;int,int&amp;gt;a[MAXN];bool v[MAXN],w[MAXN];int minn=1&amp;lt;&amp;lt;30;int read()&#123;    int x=0,f=1;char ch=getchar();    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;void add(int x,int y,int z)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    val[tot]=z;    Head[x]=tot;&#125;void find_root(int S,int x)&#123;    v[x]=1;    size[x]=1;    int max_part=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(v[y]||w[y])continue;        find_root(S,y);        size[x]+=size[y];        max_part=max(max_part,size[y]);    &#125;    max_part=max(max_part,S-size[x]);    if(max_part&amp;lt;now_part)&#123;        now_part=max_part;        root=x;    &#125;&#125;void dfs(int x,int vl,int step)&#123;    v[x]=1;    if(step&amp;gt;minn||vl&amp;gt;k)return;    a[++cnt]=make_pair(vl,step);    for(int i=Head[x];i;i=Nt[i])&#123;        if(v[to[i]]||w[to[i]])continue;        dfs(to[i],vl+val[i],step+1);    &#125;&#125;void work(int x)&#123;    w[x]=1;    set&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt;st;    st.insert(make_pair(0,0));    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i],z=val[i];        if(w[y])continue;        memset(v,0,sizeof(v));        cnt=0;        dfs(y,z,1);        set&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt;::iterator it;        for(int i=1;i&amp;lt;=cnt;i++)&#123;            it=st.lower_bound(make_pair(k-a[i].first,0));            if(it!=st.end()&amp;amp;&amp;amp;it-&amp;gt;first+a[i].first==k)minn=min(minn,it-&amp;gt;second+a[i].second);        &#125;        for(int i=1;i&amp;lt;=cnt;i++)st.insert(a[i]);    &#125;    st.clear();    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(w[y])continue;        memset(v,0,sizeof(v));        root=0,now_part=1&amp;lt;&amp;lt;30;        find_root(size[y],y);        work(root);    &#125;&#125;int main()&#123;    n=read(),k=read();    for(int i=1;i&amp;lt;n;i++)&#123;        int x=read(),y=read(),z=read();        add(x+1,y+1,z);add(y+1,x+1,z);    &#125;    now_part=1&amp;lt;&amp;lt;30;    find_root(n,1);    work(root);    if(minn==1&amp;lt;&amp;lt;30)printf(&amp;quot;-1\n&amp;quot;);    else printf(&amp;quot;%d\n&amp;quot;,minn);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P3674]小清新人渣的本愿</title>
    <link href="/2019/02/23/%5B%E6%B4%9B%E8%B0%B7P3674%5D%E5%B0%8F%E6%B8%85%E6%96%B0%E4%BA%BA%E6%B8%A3%E7%9A%84%E6%9C%AC%E6%84%BF/"/>
    <url>/2019/02/23/%5B%E6%B4%9B%E8%B0%B7P3674%5D%E5%B0%8F%E6%B8%85%E6%96%B0%E4%BA%BA%E6%B8%A3%E7%9A%84%E6%9C%AC%E6%84%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3674">题目链接</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>其实这题要不是当时在学莫队，真的没想过会用莫队解决（粗略估计一下复杂度会炸）</p><p>用bitset维护的这个想法很赞，不看题解想不出来</p><p>大概就是下面这样的一个思路</p><p>首先对于操作1，第一个bitset维护的是当前位出现与否，比如$bitset[3]==1$说明当前区间内，3出现过</p><p>如果说让bitset里面所有的数-x或者+x后，还有和原bitset有相同的元素的话，那么就说明有这样的数</p><p>然后对于操作2，有一个前提就是这里询问的x也是在维护的bitset的范围内</p><p>于是呢我们可以维护另一个bitset，这个bitset存的反的bitset，什么意思呢，就是如果$bitset[x]==1$那么说明区间内存在$N-x$这个数，N就是bitset维护的最大的数。</p><p>如果说让第二个bitset里的数全部+x-N后，还有和第一个bitset有相同的元素的话，那么就说明有这样的数</p><p>其实第二个bitset很巧妙，它真正要存的东西其实是相反数（请仔细理解下这是为什么），$a+b=x$那么$a=x-b$其中a由第一个bitset维护，x-b由第二个bitset维护（<strong>请仔细理解这里，这是这道题的难点</strong>）</p><p>至于操作3，枚举x的约数，$O(\sqrt{N})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=100000;int n,m;bitset&amp;lt;MAXN+5&amp;gt;s1;bitset&amp;lt;MAXN+5&amp;gt;s2;int c[MAXN+5],sum[MAXN+5];int ans[MAXN+5];int block;struct node&#123;    int l,r,op,id,num;&#125;q[MAXN+5];bool cmp(node a,node b)&#123;    return (a.r/block==b.r/block)?a.l&amp;lt;b.l:a.r&amp;lt;b.r;&#125; inline void add(int x)&#123;    sum[c[x]]++;    if(sum[c[x]]==1)&#123;//如果不写&amp;quot;==1&amp;quot;的话会被卡一个点，没搞懂为什么orz        s1[c[x]]=1;        s2[MAXN-c[x]]=1;    &#125;&#125;inline void del(int x)&#123;    sum[c[x]]--;    if(sum[c[x]]==0)&#123;        s1[c[x]]=0;        s2[MAXN-c[x]]=0;    &#125;&#125;    int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;c[i]);    &#125;    block=sqrt(n);    for(int i=1;i&amp;lt;=m;i++)&#123;        q[i].id=i;        scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;q[i].op,&amp;amp;q[i].l,&amp;amp;q[i].r,&amp;amp;q[i].num);    &#125;    sort(q+1,q+1+m,cmp);    int l=1,r=0;    for(int i=1;i&amp;lt;=m;i++)&#123;        int ql=q[i].l,qr=q[i].r;        while(l&amp;lt;ql)&#123;            del(l);            l++;        &#125;        while(l&amp;gt;ql)&#123;            l--;            add(l);        &#125;        while(r&amp;lt;qr)&#123;            r++;            add(r);        &#125;        while(r&amp;gt;qr)&#123;            del(r);            r--;        &#125;        if(q[i].op==1)&#123;            if(((s1&amp;lt;&amp;lt;q[i].num)&amp;amp;s1).any())&#123;                ans[q[i].id]=1;            &#125;        &#125;        else if(q[i].op==2)&#123;            if((s1&amp;amp;(s2&amp;gt;&amp;gt;(MAXN-q[i].num))).any())&#123;                ans[q[i].id]=1;            &#125;        &#125;        else &#123;            for(int j=1;j*j&amp;lt;=q[i].num;j++)                if(!(q[i].num%j))if(s1[j]&amp;amp;&amp;amp;s1[q[i].num/j])&#123;ans[q[i].id]=1;break;&#125;        &#125;    &#125;    for(int i=1;i&amp;lt;=m;i++)&#123;        if(ans[i])printf(&amp;quot;hana\n&amp;quot;);        else printf(&amp;quot;bi\n&amp;quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【问题征集】关于2月1号对于徐老师提问的问题征集</title>
    <link href="/2019/01/31/%E3%80%90%E9%97%AE%E9%A2%98%E5%BE%81%E9%9B%86%E3%80%91%E5%85%B3%E4%BA%8E2%E6%9C%881%E5%8F%B7%E5%AF%B9%E4%BA%8E%E5%BE%90%E8%80%81%E5%B8%88%E6%8F%90%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98%E5%BE%81%E9%9B%86/"/>
    <url>/2019/01/31/%E3%80%90%E9%97%AE%E9%A2%98%E5%BE%81%E9%9B%86%E3%80%91%E5%85%B3%E4%BA%8E2%E6%9C%881%E5%8F%B7%E5%AF%B9%E4%BA%8E%E5%BE%90%E8%80%81%E5%B8%88%E6%8F%90%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98%E5%BE%81%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>提问内容包括但不限于：<br>1.全国赛试题特点与应对策略分析报告<br>2.其他算法的巧妙应用<br>3.考场得分技巧</p><p>请勿机惨！！！</p><p>如果该你的设备加载该网站很慢，很有可能是该网站在加载“谷歌字体”，借助梯子能加速访问</p><p>另外这里是七天课程的题目，课件，题解：<a href="https://pan.baidu.com/s/1JJXcz-u_i0vbGaCtES2zFQ">链接</a><br>提取码是：pteq<br>密码是毕克的用户名!<del>wwwwodddd</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[Day6]B 君的第三题 (shenyang)</title>
    <link href="/2019/01/30/%5BDay6%5DB%20%E5%90%9B%E7%9A%84%E7%AC%AC%E4%B8%89%E9%A2%98%20(shenyang)/"/>
    <url>/2019/01/30/%5BDay6%5DB%20%E5%90%9B%E7%9A%84%E7%AC%AC%E4%B8%89%E9%A2%98%20(shenyang)/</url>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个长度为n的数组，你需要更改里面各项的值使得它们两两互质。<br>代价为改后数字与原始值的差值的绝对值。求最小代价。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>这个题解算是在分享做题的心路历程，比较磨叽，可以只看黑体字部分</p></blockquote><p>一开始都已经弃疗了（别一开始就放弃啊喂!）准备打一个暴力骗点分……<br>于是就打算枚举每一项，对于每一项枚举每一个可能值。<br>枚举值肯定有范围的，不能可在int范围内枚举吧。<br>于是就发现了：<br><strong>结论1：改后的数的范围在[1,59]之间</strong><br>下界是题目给的，我们只对上界进行讨论<br>证明：我们设数列为$A_1,A_2,\cdots A_n$，由于题目中$A_i\le30$，且1与任意自然数互质。因此$|A_i-1|\le|A_i-59|$且$|A_i-1|&lt;|A_i-59|$。因此改后的数的上界为59。</p><p>找到了范围就可以开心地枚举啦！！理论上$O(59^n)$n=4的时候过不了。但实际上可以很多情况下可以提前判断不互质而提前退出，因此30pt到手！</p><p>很自然地去想如何<strong>判断不互质——有相同的质因子</strong></p><p>每次都去算质因子好麻烦，而且数字很小，于是就可以开一个数组$zz[i]$存i的质因子，我们发现<strong>60以内的质数只有17个，可以直接用状态存</strong></p><p>都写到这了还写什么暴力orz，直接上状压啊！</p><p><strong>状态设计↓</strong><br>我们设计$d[i][j]$表示第i个数，在状态j（有多少个质因子）下，所耗费的最小费用。<br>初始化d数组为$\infty$，d[0][0]=0<br>现在需要枚举每个可以转移的合法状态，设初始时$fzz=((1&lt;&lt;17)-1)\ xor\ zz[j]$，该项原始值为a<br>状态转移方程为：<br>$d[i][fzz|zz[j]]=min(d[i-1][fzz]+abs(a-j))$<br>最后$min(d[n][i])$就是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=110;int d[MAXN][1&amp;lt;&amp;lt;17];int p[25]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97&#125;;int pre(int x)&#123;    int s=0;    for(int i=0;i&amp;lt;17;++i)        if(x%p[i]==0)            s|=(1&amp;lt;&amp;lt;i);    return s;&#125;int zz[60];int main()&#123;    memset(d,0x3f,sizeof(d));    d[0][0]=0;    int n;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=59;++i)&#123;//预处理出质因子        zz[i]=pre(i);    &#125;        for(int i=1;i&amp;lt;=n;++i)&#123;           int a;scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);        for(int j=1;j&amp;lt;=59;++j)&#123;            int fzz=((1&amp;lt;&amp;lt;17)-1)^zz[j];            for(int k=fzz;;(--k)&amp;amp;=fzz)&#123;//枚举每一个合法状态，也就是枚举该状态原本为1位置的变成0                d[i][k|zz[j]]=min(d[i][k|zz[j]],d[i-1][k]+abs(a-j));                if(k==0)                    break;            &#125;        &#125;    &#125;    int ans=1&amp;lt;&amp;lt;30;    for(int i=0;i&amp;lt;=(1&amp;lt;&amp;lt;17)-1;++i)        ans=min(ans,d[n][i]);    printf(&amp;quot;%d\n&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOI2012]随机数生成器</title>
    <link href="/2019/01/29/%5BNOI2012%5D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2019/01/29/%5BNOI2012%5D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2044">题目链接</a></p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（<strong>Linear Congruential Method</strong>）来生成一个随机数列，这种方法需要设置四个非负整数参数$m$,$a$,$c$,$X[0]$,按照下面的公式生成出一系列随机数${Xn}$：<br>                       $X[n+1]=(aX[n]+c)\ mod\ m$<br>其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。</p><p>用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的<kbd>C++</kbd>和<kbd>Pascal</kbd>的产生随机数的库函数使用的也是这种方法。</p><p>栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道$X[n]$是多少。由于栋栋需要的随机数是$0,1,…,g-1$之间的，他需要将$X[n]$除以$g$取余得到他想要的数，即$X[n] mod\ g$，你只需要告诉栋栋他想要的数$X[n] mod\ g$是多少就可以了。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含6个用空格分割的整数$m,a,c,X[0],n$和$g$，其中$a,c,X[0]$是非负整数，$m,n,g$是正整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个数，即$X[n] mod\ g$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>11 8 7 1 5 3</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>2</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>计算得$X[n]=X[5]=8$,故$(X[n] mod g) = (8 mod 3) = 2$</p><p>100%的数据中$n,m,a,c,X[0]&lt;=10^{18},g&lt;=10^8$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>其实挺简单的……B君讲的时候居然没听懂<br>在草稿纸上写一写<br>$x[1]=(ax[0]+c)(mod\ m)$<br>$x[2]=a((ax[0]+c)+c)=a^2x[0]+ac+c(mod\ m)$<br>$x[3]=a(a^2x[0]+ac+c)+c=a^3x[0]+a^2c+ac+c(mod\ m)$<br>蛮好，这样就可以推出：<br>$x[n]=a^nx[0]+a^{n-1}c+\cdots+ac+c$<br>第一项快速幂算出即可，后面n项为等比数列，递归求出即可，由于会爆long long，乘法用龟速乘代替即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef unsigned long long ull;ull mod,a,c,x,n,g,mod1,m;ull mul(ull a,ull b)&#123;    ull ans=0;    while(b)&#123;        if(b&amp;amp;1)ans=(ans+a)%mod;        a=(a+a)%mod;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;ull qpow(ull a,ull b)&#123;    ull ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=mul(ans,a)%mod;        a=mul(a,a)%mod;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;ull sum(ull n,ull t)&#123;    if(n==1)return t;    ull res=sum(n/2,t);    res=(res+mul(res,qpow(m,n/2)))%mod;    if(n&amp;amp;1)res=(res+mul(qpow(m,(n-1)),t))%mod;    return res;&#125;int main()&#123;    cin&amp;gt;&amp;gt;mod&amp;gt;&amp;gt;m&amp;gt;&amp;gt;c&amp;gt;&amp;gt;x&amp;gt;&amp;gt;n&amp;gt;&amp;gt;mod1;    ull ans=qpow(m,n);    ans=mul(ans,x);        ans=(ans+sum(n,c))%mod;    cout&amp;lt;&amp;lt;ans%mod1;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【NOI导刊】冲刺NOI2019被虐记</title>
    <link href="/2019/01/25/%E3%80%90NOI%E5%AF%BC%E5%88%8A%E3%80%91%E5%86%B2%E5%88%BANOI2019%E8%A2%AB%E8%99%90%E8%AE%B0/"/>
    <url>/2019/01/25/%E3%80%90NOI%E5%AF%BC%E5%88%8A%E3%80%91%E5%86%B2%E5%88%BANOI2019%E8%A2%AB%E8%99%90%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>想着明天就要出发了，在机房里有点颓，一个下午+晚上也只敲了两道网络流的题目；<br>明明只是个蒟蒻，在机房里也总是感慨，时间过的真快啊，剩下的时间不多了，这个培训过后，距离省选也就70多天了吧。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190120_163325.jpg"><br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190120_163341.jpg"></p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>早上7点17的车，尽管昨天已经提早睡了，可还是很困，唯一比较庆幸的一点就是高铁比较空吧<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190124_071805.jpg"><br>在车上看了会《利兹与青鸟》，很难懂（后来才知道要先看《京吹》第二季orz）<br>从火车站到学校这段路是最难过的，深深感受到了郑州空气污染的严重<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190124_143603.jpg"><br>学校还是很棒的，在这个广场上曾经跳过BDF的宅舞接力——《流星群》和《交织together》（视频可以自己去B站搜）<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190124_155041.jpg"><br>拿到了狗牌，座位离老师很近，蛮好。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190124_154651.jpg"><br>吃完晚饭后就回宾馆里颓了（实在是头晕，后面几天晚上还是有在认真学习的xd）<br>看了几集《摇曳露营Δ》我也要去露营！！！就有鬼了</p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早安，郑州，这里的高中还在上学啊<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190125_070659.jpg"><br>上午考试，垫底，被彩虹猫D飞，果然太弱啦（题解过一会写<br>T1来个什么まんふは函数，直接说是哈夫曼函数不好吗QAQ<br>T2想到了AC自动机，打完模板后就默默地上了暴力（正解居然要用AC自动机+dp）<br>T3居然是网络流，真的属于那种告诉你是网络流，都想不到是网络流的那种题目。<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190125_183305.jpg"><br>明明晚上睡眠更久，中午也好好休息了，但是不知到为什么下午彩虹猫讲课的时候特别想睡觉（北方的暖气tql）<br>后面逼着自己清醒，听完了，晚上赶紧买了杯咖啡喝；</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>上午考的是8年前国家队训练题……还是垫底orz<br>T1居然n^2的暴力能过，我以为n^2和n^3的分数差别不大，打了一个n^3的就去想正解，结果正解写挂，35垫底<br>正解是线段树+哈希（考场上没人用这种方法A的），还有几个大佬用bitset过了，还挺快<br>T2仙人掌，现场也有人A，tql<br>T3状压dp矩阵加速，很难</p><p>中午点外卖，郑州菜里的肉是真的多，赞（后面几天中午都吃外卖了）</p><p>下午开始飙车，树状数组+线段树+平衡树+树套树+可持久化数据结构+可并堆，3个多小时讲完，虽然有些知识是有基础，但是真的太快了……</p><p>本来晚上想逛下校园的，但吃饭等了蛮久。</p><p>涛哥讲课喜欢叫学生上来讲，虽然学生讲根本听不懂，但至少让课堂没有那么乏味了。<br>发现大佬还是挺多的，%%%%</p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>昨天考试发的大样例居然也放进评测里了，我机智地在最后一分钟特判输出来（结果CE了QAQ）<br>T1是0/1分数规划，了解一下<br>T2是AC自动机/KMP dp<br>T3就是一个恶心线段树</p><p>T1CE了，T2输了个大样例，时间全部花在T3上，调试了半天A了<br>有人用自动AC机拿了290，少给10分怕你骄傲orz</p><p>中午继续外卖，明天要想继续吃就要先去趟银行</p><p>下午好懵，点分治+边分治+树剖+LCT+Hash+AC自动机+后缀数组<br>如果说前面没听懂的可以回宾馆补补，那这个可能要花我一个寒假来消化。</p><p>晚上涛哥喊我上去讲T3，我感觉我在上面口胡，也不知道在讲什么，其实T3真的就是一个恶心一点的线段树，没啥好讲的……</p><p>睡前看了摇曳露营，吹爆！<br>这一集标题是两处露营，两个人眼中的风景<br>看了这一集真的很有感触<br>两处露营一处是一个人@<a href="https://www.luogu.org/space/show?uid=91499">Linz</a>，一处是一群人@<a href="https://www.luogu.org/space/show?uid=92770">March_H</a><br>@<a href="https://www.luogu.org/space/show?uid=112137">aowu</a> @<a href="https://www.luogu.org/space/show?uid=91985">Antione</a> @<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a><br>所看到的景象各不相同,交流着各自所看到的景象。<br>广州和郑州又相距多远呢？也就几米吧<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/yyly1.jpg"> <img src="http://bubbleioa.top/wp-content/uploads/2019/01/yyly2.jpg"> <img src="http://bubbleioa.top/wp-content/uploads/2019/01/yyly3.jpg"></p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>上午第一次做答案提交题，居然是这种套路！<br>T1线段树，但是要用到三角函数，我猜很多人会被卡（包括我），所以就用前缀和+差分打算拿部分分，结果出来的分数和大部分线段树的一样xd<br>T2是下午讲的二元关系的模型，题目很难读懂，反正我是看了几遍<br>T3是国家集训队的题，第一次接触提交答案题，随便写了6个点上去（居然有6分），后来才知道这种题目光一个程序是基本不可能A的（除非你把几个程序合在一起分情况使用），要观察发下来的数据的特点，真·面向数据编程</p><p>中午和@<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a>去银行存钱（要不然就没有外卖吃啦！）</p><p><strong>获得成就</strong><br><input checked="" disabled="" type="checkbox"> 在郑州活动范围超过500米</p><p>下午彩虹猫又回来讲课啦，讲的东西没有前面几天难。像是什么平面图最小割= 对偶图最短路、各种上下界流、二元关系、差分约束、最大权闭合子图<br>、最大密度子图……</p><p>发现这几天讲的例题基本都是各省省选和NOI真题，部分POJ和CF上的题……感觉每道题我都要消化至少3小时</p><p>外卖太好吃啦！晚上也在吃外卖（主要是发现了预定的功能）</p><p>晚上要到了彩虹猫的签名，nice！<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/sign.jpg"></p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>上午毕姥爷（B君）给我们带来了三道良心题（至少在网上都搜不到了），除了第三题不可做以外，前两题都还行</p><p>T1 二维树状数组，我也是这么写的，不过查询效率太低，挂掉了，后来才知道要一开始旋转下矩阵orz<br>T2 扫描线，用离散化水了40分，还行<br>T3 不可做题，不评价</p><p>毕姥爷还是带着和常州时一样的味道，<del>好怀念</del></p><p>中午继续吃外卖，郑州的食物已经俘获了我~</p><p>下午讲课全程懵逼，虽然毕姥爷课程准备一向用心（一天准备了95道例题），但我还是太弱了同不懂orz，果然如同涛哥说的，能坚持20分钟已经不错了<br>又挖了一边贾志鹏的坟，然而还是没听懂QAQ</p><p>吃晚饭的时候出去就感觉难受，空气污染太严重了，赶紧拿了外卖回机房吃</p><p>晚上毕姥爷基本给我们自习，切了道<a href="http://bubbleioa.top/archives/665">不是很难的题</a><br>从前天开始门卫就要查狗牌，还好这几天都带在身上，不过确实有几个人狗牌放在教室里被拦下来了，希望明天不要是我QAQ</p><p>安利一下<a href="http://wwwwodddd.com/">毕姥爷的博客</a>，<del>虽然没有什么内容</del></p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>上午的题目据说比昨天的容易？是严格的还是均摊的还是期望的？<br>感觉是严格的吧，确实更简单，但是T1打的暴力，剩下的时间全部花在T3上了。<br><a href="http://bubbleioa.top/archives/673">T3题解</a></p><p>没想到毕姥爷评测开O2，早知道写3道暴力交上去<br>今天又有自动AC机，每次都是不想太高调故意不AK</p><p>中午去@<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a>房间里吃饭，垃圾终于不用我来处理啦~</p><p>下午讲<strong>计 算 几 何</strong>，没有任何基础就讲了一下午例题，感觉整个人都不好了。所以也没有什么可以记下来的。<br>同样的，例题很多</p><p>晚上下了雪，没有吃外卖<br><img src="http://bubbleioa.top/wp-content/uploads/2019/01/IMG_20190130_182907.jpg"></p><h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><blockquote><p>这两天的内容是咕了很久才写的，有很多细节记不太清了</p></blockquote><p>今天xmk来讲课，吹爆<br>很腼腆，讲的也比较清晰。</p><h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><p>今天是最后一天，没有考试，上午就是xmk来给我们答疑，具体<a href="http://bubbleioa.top/archives/687">请看这里</a><br>然后就是带我们看去年noi的题目</p><ul><li>D1T1 xmk看了10分钟直接得出可持久化并查集+反向跑最短路的思路，就是正解%%%tql</li><li>D1T2 也看出是dp，设计了状态和转移方程%%%</li><li>D1T3 看出了是后缀自动机，没想到用线段树（应该是时间问题），直接82pt</li><li>D2T1 把题读了一遍，拓展中国剩余定理</li><li>D2T2和D2T3 虽然没想到正解，暴力还是有些许分的（然而网上要么就是没有题解，要么就是只有出题人的题解和std）</li></ul><p>后面由于火车的关系就提前溜了，好可惜QAQ，还想多膜一下xmk</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[UVA1660]电视网络Cable TV Network</title>
    <link href="/2019/01/22/%5BUVA1660%5D%E7%94%B5%E8%A7%86%E7%BD%91%E7%BB%9CCable%20TV%20Network/"/>
    <url>/2019/01/22/%5BUVA1660%5D%E7%94%B5%E8%A7%86%E7%BD%91%E7%BB%9CCable%20TV%20Network/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/UVA1660">题目链接</a></p></blockquote><p>不得不说，网络流的题目其实实现起来都是套模板，但是要想到就很困难。</p><p>很多人学了最小割之后就来切这道“裸题”，数据范围小，还没要求输出具体方案，太简单了！</p><p>但是最小割是适用于有向图，而且是边集，但是这道题是要我们找出点的个数，而且是无向图。</p><p><strong>在看这篇题解的时候默认你知道“<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86/3851799?fr=aladdin">最大流最小割定理</a>”</strong></p><p>我们先来着手解决第一个问题：无向图转化成有向图。</p><p>由于这道题是关于图的连通性的问题，因此转化出来的有向图和原图<strong>连通性不变</strong></p><p><img src="http://bubbleioa.top/wp-content/uploads/2019/01/%E7%82%B9%E8%BE%B9%E8%BD%AC%E5%8C%96.png"></p><p>如上图，我们可以将原来的图的每个点，拆成两个点x,x’（图中的点不包括源点和汇点），在它们之间连容量为1的有向边。对于原来的边(x,y)，我们可以转化成(x’,y)和(y’,x)这两条有向边，容量为[latex]\infty[/latex] </p><p>这样做显然连通性不变。</p><p>而且，我们发现，在原图中，如果删去y点，x与z就不连通了；</p><p>在转换图中，如果删去(y,y’)那么x与z也是不连通的；</p><p>于是我们可以将问题转化为：在转化后图中，至少删掉多少条权值为1的边才能使图不连通；</p><p>这就是一个典型的最小割问题，由于其他边权值都是$ \infty $,而图中最大流量为$N-2$，因此求最小割的时候贡献答案的一定是权值为1的边。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN =500;const int inf=1&amp;lt;&amp;lt;30;int Head[MAXN*10],Nt[MAXN*10],val[MAXN*10],to[MAXN*10],pre[MAXN],incf[MAXN],v[MAXN];int s,t,n,m,tot=1,maxflow;int a[MAXN],b[MAXN];void add(int x,int y,int z)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    val[tot]=z;    Head[x]=tot;    Nt[++tot]=Head[y];    to[tot]=x;    val[tot]=0;    Head[y]=tot;&#125;int read()&#123;    int x=0,f=1;char ch=&amp;#039;[&amp;#039;;    while(!isdigit(ch))&#123;ch=getchar();if(ch==&amp;#039;-&amp;#039;)f=-1;&#125;    while(isdigit(ch))&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;bool bfs()&#123;    memset(v,0,sizeof(v));    queue&amp;lt;int&amp;gt;q;    q.push(s);incf[s]=inf;v[s]=1;    while(q.size())&#123;        int x=q.front();q.pop();        for(int i=Head[x];i;i=Nt[i])&#123;            if(val[i])&#123;                int y=to[i];                if(v[y])continue;                incf[y]=min(incf[x],val[i]);                pre[y]=i;                if(y==t)return 1;                q.push(y);v[y]=1;            &#125;        &#125;    &#125;    return 0;&#125;void update()&#123;    int x=t;    while(x!=s)&#123;        int i=pre[x];        val[i]-=incf[t];        val[i^1]+=incf[t];        x=to[i^1];    &#125;    maxflow+=incf[t];&#125;int main()&#123;    while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)!=EOF)&#123;        for(int i=1;i&amp;lt;=m;i++)&#123;            a[i]=read()+1;            b[i]=read()+1;        &#125;        int ans=inf;        for(s=1;s&amp;lt;=2;s++)            for(t=1;t&amp;lt;=n;t++)&#123;                if(s!=t)&#123;                    memset(Head,0,sizeof(Head));                    tot=1;maxflow=0;                    for(int i=1;i&amp;lt;=n;i++)&#123;                        if(i==s||i==t)add(i,i+n,inf);                        else add(i,i+n,1);                    &#125;                    for(int i=1;i&amp;lt;=m;i++)&#123;                        add(a[i]+n,b[i],inf);                        add(b[i]+n,a[i],inf);                    &#125;                    while(bfs())update();                    ans=min(ans,maxflow);                &#125;            &#125;        if(n&amp;lt;=1||ans==inf)ans=n;        cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote><p>对于上面有些问题没弄懂的可以看这里</p></blockquote><p>Q1：为什么最大流量是$N-2$？</p><p>A：你可以想一下最大流量的情况，就是整个图分3层，第一层为源点，第三层为汇点，第二层有$N-2$个点，每个点流量都是1；</p><p>欢迎提问~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于最近连不上ssr服务器的问题</title>
    <link href="/2019/01/09/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E8%BF%9E%E4%B8%8D%E4%B8%8Assr%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2019/01/09/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E8%BF%9E%E4%B8%8D%E4%B8%8Assr%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>经测试，原因是手机端的ssr在断开连接时，服务器端会产生错误信息导致进入死循环而崩溃，致使cpu占用率激增至100%而死机。</p><p>首先，确保您的ssr安卓客户端是最新版本（目前是3.5.4，安装后应用名称叫做SSRR，<a href="http://bubbleioa.top/files/shadowsocksr-android-3.5.4.apk">点此下载</a>）</p><p>如果还有此问题，将考虑实施备用方案。</p><p>另外，如果你是其他平台的用户，请参考下面内容（转自<a href="https://ssr.tools/">ssr.tools</a>）：</p><h2 id="SSR-Windows客户端"><a href="#SSR-Windows客户端" class="headerlink" title="SSR Windows客户端"></a>SSR Windows客户端</h2><p>SSR Windows客户端主要用于电脑端，目前最新版本为 4.9.0</p><p><strong>下载地址：</strong><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases/download/4.9.0/ShadowsocksR-win-4.9.0.zip">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases/download/4.9.0/ShadowsocksR-win-4.9.0.zip</a></p><p><strong>使用教程：</strong> </p><p><a href="http://bubbleioa.top/wp-content/uploads/2019/05/ssr-windows.png">点击查看</a></p><h2 id="SSR-Android客户端"><a href="#SSR-Android客户端" class="headerlink" title="SSR Android客户端"></a>SSR Android客户端</h2><p>SSR 安卓客户端主要用于安卓手机、安卓平板平台，目前最新版本为3.5.4</p><p><strong>下载地址：</strong><a href="https://github.com/shadowsocksrr/shadowsocksr-android/releases/download/3.5.4/shadowsocksr-android-3.5.4.apk">https://github.com/shadowsocksrr/shadowsocksr-android/releases/download/3.5.4/shadowsocksr-android-3.5.4.apk</a></p><p><strong>使用教程：</strong><br><a href="http://bubbleioa.top/wp-content/uploads/2019/05/ssr-android.png">点击查看</a></p><h2 id="SSR-iOS客户端"><a href="#SSR-iOS客户端" class="headerlink" title="SSR iOS客户端"></a>SSR iOS客户端</h2><p>需要美版账号（其他国家的没试过），<a href="http://bubbleioa.top/wp-content/uploads/2019/05/ssr-get.png">点击查看获取方法</a></p><p>ssr应用推荐（参考），<a href="http://bubbleioa.top/wp-content/uploads/2019/05/ssr-ios.png">点击查看</a></p><p>配置方法其实和安卓，windows差不多，都是填那几个参数。</p><h2 id="SSR-MacOS客户端"><a href="#SSR-MacOS客户端" class="headerlink" title="SSR MacOS客户端"></a>SSR MacOS客户端</h2><p><strong>下载地址：</strong><a href="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases/download/1.4.3-R8-build3/ShadowsocksX-NG-R8.dmg">https://github.com/qinyuhang/ShadowsocksX-NG-R/releases/download/1.4.3-R8-build3/ShadowsocksX-NG-R8.dmg</a></p><p><strong>使用方法：</strong>和Windows几乎没区别</p><h2 id="SSR-Linux客户端"><a href="#SSR-Linux客户端" class="headerlink" title="SSR Linux客户端"></a>SSR Linux客户端</h2><p>这是一个有图形界面的Linux客户端，下载和安装请见：<br><a href="https://github.com/erguotou520/electron-ssr">https://github.com/erguotou520/electron-ssr</a></p><p>使用方法和上面的类似。</p><h2 id="SSR-路由器客户端"><a href="#SSR-路由器客户端" class="headerlink" title="SSR 路由器客户端"></a>SSR 路由器客户端</h2><p>如果想要所有局域网设备，无需一一设置，自动实现科学上网，那么有效的途径就是在路由器上安装SSR客户端，实现局域网所有设备科学上网。</p><h3 id="路由器科学上网所需条件"><a href="#路由器科学上网所需条件" class="headerlink" title="路由器科学上网所需条件"></a>路由器科学上网所需条件</h3><p>在路由器上安装SSR客户端的前提，是路由器可以安装第三方固件，然后在第三方固件中安装SSR客户端。</p><p><strong>1.不能是普通的TP-Link、迅捷、腾达等大众路由器。</strong><br>原因：这些大众品牌路由器，其官方固件功能比较简单，同时又无法刷入功能强大的第三方固件。</p><p><strong>2.有哪些品牌的路由器可以安装SSR？</strong><br>一般来说，新兴的互联网品牌路由器，一般都可以安装第三方固件，并且比较便宜。比如Newifi路由器、小米路由器、斐迅路由器、极路由等。<br>另外老牌的华硕路由器、网件路由器、Linksys路由器等，这些大牌路由，基本都可以安装第三方固件，不过价格相对比较高。</p><p><strong>3.有哪些第三方固件可供选择？</strong><br>目前比较主流的第三方固件有：openwrt、LEDE、PandoraBox、老毛子（Padavan）、梅林。其中LEDE是openwrt的最新版名称，PandoraBox是openwrt基础上的打包版本。这三者的本质都是openwrt，都可以自己在系统内安装SSR等功能。<br>老毛子和梅林则集成众多实用功能，自带SSR，固件相对比较封闭。<br>新手的话，推荐用老毛子固件或梅林固件，功能强大，自带功能也够用，免去自己安装的麻烦。</p><p><strong>4.上面提到的固件，分别对应哪些路由器？</strong><br>华硕、网件的路由器，大部分都可以适配第三方的梅林固件，梅林固件自带SSR。<br>Linksys的路由器，大部分都可适配第三方的openwrt或LEDE固件。<br>小米、Newifi、斐迅、极路由等品牌，则可以适配PandoraBox或老毛子固件，也自带SSR。</p><p>由于老毛子固件和梅林固件，自带SSR，无需另外安装，下面我们主要介绍下openwrt固件下，SSR的下载，安装和使用。</p><h3 id="openwrt固件-SSR安装教程"><a href="#openwrt固件-SSR安装教程" class="headerlink" title="openwrt固件 SSR安装教程"></a>openwrt固件 SSR安装教程</h3><p><strong>下载地址：</strong> <a href="https://github.com/ywb94/openwrt-ssr/releases/download/V1.2.1/luci-app-shadowsocksR_1.2.1.rar">https://github.com/ywb94/openwrt-ssr/releases/download/V1.2.1/luci-app-shadowsocksR_1.2.1.rar</a></p><ol><li>以上压缩包下载完成后解压，会得到6个文件夹，分别代表6种CPU架构，我们只需用到其中1个。</li><li>查询你的路由器是什么CPU、CPU是什么架构。查到后打开对应的文件夹。</li><li>文件夹内有两个SSR版本，一个带GFW字样、一个不带。推荐选择不带GFW的版本，因为GFW版本需要路由器其它模块的配合，比较麻烦。</li><li>在PC端用Winscp连接路由器，连接时协议选SCP，端口为22，用户名密码一般与你的路由登录密码一致。连接成功后，将luci-app-shadowsocksR_1.2.1_all.ipk上传至路由器的 /tmp目录。</li><li>打开Putty运行以下命令：<code>opkg install /tmp/luci-app-shadowsocksR_1.2.1_all.ipk</code></li><li>以上命令成功运行完成后，SSR就安装成功了。</li><li>打开路由器后台管理页面刷新，在菜单的服务一栏下，找到ShadowsocksR就代表安装成功了。<h3 id="openwrt固件-SSR使用教程"><a href="#openwrt固件-SSR使用教程" class="headerlink" title="openwrt固件 SSR使用教程"></a>openwrt固件 SSR使用教程</h3>打开路由器后台管理页面，依次打开 菜单——服务——ShadowsocksR</li></ol><p>在最上方的客户端、服务端、状态三项中，我们只需配置客户端，服务端一般用不到。</p><p><strong>客户端配置</strong></p><p>在默认的客户端界面中，从上到下分为以下几大项：</p><ul><li>服务器配置</li><li>全局设置</li><li>SOCKS 5代理</li><li>访问控制<br>下面我们依次介绍。<a href="http://bubbleioa.top/wp-content/uploads/2019/05/ssr-luyouqi.png">点击查看</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2018年10月新番个人总结</title>
    <link href="/2019/01/01/2018%E5%B9%B410%E6%9C%88%E6%96%B0%E7%95%AA%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2019/01/01/2018%E5%B9%B410%E6%9C%88%E6%96%B0%E7%95%AA%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2018年已经过去，咕到现在的10月新番总结现在也是时候填了（然而AC自动机还没填……）</p><p>这一个季度的新番真的是让人看得舒服，好久没有追过这么多番了（主要是停课有更多时间来追番？！）</p><p>下面就对我看过的/看完的新番做一个总结和主观评分吧。</p><p>绝大多数不含剧透或只有轻微剧透</p><hr><h1 id="中途弃坑的番"><a href="#中途弃坑的番" class="headerlink" title="中途弃坑的番"></a>中途弃坑的番</h1><p><kbd>只对没有弃坑的番打分，所以这一部分并不会打分</kbd></p><h2 id="只要贝尔哲布布大小姐喜欢就好"><a href="#只要贝尔哲布布大小姐喜欢就好" class="headerlink" title="只要贝尔哲布布大小姐喜欢就好"></a><a href="http://bangumi.bilibili.com/anime/25697">只要贝尔哲布布大小姐喜欢就好</a></h2><blockquote><p>观看集数：3集；</p><p>弃坑原因：太闲</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/468ebdb93491b6fa263cf5eb829a0ec65ed266ab.png@282w_375h.webp"></p><p>画风淡淡的甜甜的，很喜欢，为什么当初要看？因为这季没什么中意的萌豚番，随便找找看看有什么替代品，但是任然没找到……</p><p>很适合下午茶的时候看，如果有下午茶的话……</p><h2 id="邻家索菲"><a href="#邻家索菲" class="headerlink" title="邻家索菲"></a><a href="http://bangumi.bilibili.com/anime/25619">邻家索菲</a></h2><blockquote><p>观看集数：6集；</p><p>弃坑原因：有点闲</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/fa89d4ce62d87c6ff641c617c6bf62c8f19ceafd.jpg"></p><p>百合的感觉还是没有太强，作品就是围绕吸血鬼在现代社会的种种表现展开的，然而我并不关心吸血鬼在现在是干啥的。</p><p>作为一部百合向作品不是很优秀，不是很推荐观看。</p><h2 id="来自多彩世界的明天"><a href="#来自多彩世界的明天" class="headerlink" title="来自多彩世界的明天"></a><a href="https://www.iqiyi.com/lib/m_218768414.html">来自多彩世界的明天</a></h2><blockquote><p>观看集数：7集；</p><p>弃坑原因：胃疼</p></blockquote><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=ef1a4764bb003af359b7d4325443ad39/4a36acaf2edda3cca5101f4d0ce93901203f92e3.jpg"></p><p>画面很清新，叙事很文艺，分镜有内涵。但是就是胃疼。</p><p>其实这部作品相比起其他作品以及很好了，并不会真的那么胃疼。</p><p>但是这还是和我对这部作品的期望有关，追这部番主要是因为是P.A.WORKS制作的，我对它的印象很好，所以追了，看到第一话被这个设定和背景吸引到了，相比起恋爱题材，我还是更喜欢看P.A.WORKS的成长题材的作品（所以说如果这部作品的主人公是祖母的话我可能会一直追下去）</p><p>它只是不和我胃口罢了，口碑还是不错的，推荐看看！</p><p>如果有机会的话我还是会把它补完的。</p><h2 id="ANIMAYELL"><a href="#ANIMAYELL" class="headerlink" title="ANIMAYELL!"></a><a href="http://www.bilibili.com/bangumi/media/md139392/?from=search&seid=15396211842182696801">ANIMAYELL!</a></h2><blockquote><p>观看集数：1分钟</p><p>弃坑原因：叫声太鬼畜</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/c2f0210ea631cc5cf310aa3d9aabf3becb624ec0.png@282w_375h.webp"></p><p>芳文社+动画工房，我本来是没有理由不看的，但是发现这部番的时候确实很晚了，再加上鬼畜的叫声，想看下去真的很难。于是就错过了……</p><p>如果下一个季度没什么中意的萌豚番就回来看这个吧。</p><h2 id="书店里的骷髅店员本田"><a href="#书店里的骷髅店员本田" class="headerlink" title="书店里的骷髅店员本田"></a><a href="http://www.bilibili.com/bangumi/media/md134952/?from=search&seid=18426877219675571352">书店里的骷髅店员本田</a></h2><blockquote><p>观看集数：3集</p><p>弃坑原因：太过遥远</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/e8f69149d5cba4a333938e71b74c00cf90f0d99c.png@282w_375h.webp"></p><p>一开始感觉还挺有意思，都是自己不了解的文化以及工作方式。</p><p>后面就感觉离自己好遥远，没啥意思了。</p><h2 id="终将成为你"><a href="#终将成为你" class="headerlink" title="终将成为你"></a><a href="http://bangumi.bilibili.com/anime/25622">终将成为你</a></h2><blockquote><p>观看集数：2集</p><p>弃坑原因：硬核</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/9254b0bafd699c1a778c42658497948ba3038a77.png@282w_375h.webp"></p><p>看过柑橘味香气，以为自己能接受硬核百合，但是这一部不一样，它的情感表达有点含蓄。换句话说，看柑橘味香气和看点兔的时候里面的人物是很单纯的，就如百合花一样，但是这部番的硬核之处就在于情感表达含蓄。</p><p>所以说我喜欢看百合并不是喜欢看妹子们日常的嬉戏互动（当然也有这方面的原因orz），而是喜欢单纯美好的东西。</p><hr><h1 id="追完了的-正在追的番"><a href="#追完了的-正在追的番" class="headerlink" title="追完了的|正在追的番"></a>追完了的|正在追的番</h1><h2 id="三生三世古利特SSSS-古立特"><a href="#三生三世古利特SSSS-古立特" class="headerlink" title="三生三世古利特SSSS 古立特"></a><del>三生三世古利特</del><a href="http://v.qq.com/x/cover/o28lfr4elqppz6q.html">SSSS 古立特</a></h2><blockquote><p>主观评分：<strong>3.2</strong>/5</p></blockquote><p><img src="http://puui.qpic.cn/vcover_vt_pic/0/o28lfr4elqppz6q1538117489/0"></p><p>我从来不看特摄篇，包括它衍生的各类作品。但是由于宝多六花还是在第三集上线的时候追了。</p><p>但是真的让我十分失望，我给的3.2分中有2分是给六花的。</p><p>一个字就可以概括这部番给我的感受：迷</p><p>世界观全无，人物背景全无，人物动机全无，故事冲突由于缺乏动机很难让人接受，新条茜莫名洗白……</p><p>真的，还不如原版的特摄片。</p><p>扳机社也制作过让我感动的作品但这次的古利特是显然不合格的。</p><h2 id="刀剑神域-Alicization"><a href="#刀剑神域-Alicization" class="headerlink" title="刀剑神域 Alicization"></a><a href="http://bangumi.bilibili.com/anime/25510">刀剑神域 Alicization</a></h2><blockquote><p>主观评分：<strong>3.9</strong>/5</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/911c5a54441d614ac53b46574838d4721a80cf98.jpg@282w_375h.webp"></p><p>目前来讲是3.9分，总感觉剧情处理方面还是有点不太好，没有我看第一季的时候的那种感觉，具体来说就是成长的感觉（因为桐人已经很强了），既然已经很强了，那就装逼吧，但是总是准备一集，然后1分钟就没了。</p><p>对，就是感觉目前为止桐人的表现还不够活跃。</p><p>优点还是有的，就是世界观解说得非常详细，可以期待下后续的表现。</p><h2 id="关于我转生变成史莱姆这档事"><a href="#关于我转生变成史莱姆这档事" class="headerlink" title="关于我转生变成史莱姆这档事"></a><a href="http://bangumi.bilibili.com/anime/25739">关于我转生变成史莱姆这档事</a></h2><blockquote><p>主观评分：<strong>4.1</strong>/5</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/a4c0e0ccc44fe3949a734f546cf5bb07da925bad.png@282w_375h.webp"></p><p>先说下缺点吧，剧情很拖沓。都一个季度过去了，上面主视图的人物还没有全部出场。</p><p>优点也有很多，比如说让人看得很舒服，这类转生到异世界的题材有一个优势就是很容易让读者感受到主人公的成长（毕竟是白手起家）</p><p>前期其实伏笔埋得很多，期待下后面怎么用吧。</p><h2 id="月影特工（其实叫忍者阿卡林）"><a href="#月影特工（其实叫忍者阿卡林）" class="headerlink" title="月影特工（其实叫忍者阿卡林）"></a><a href="http://www.acfun.cn/bangumi/aa5022156">月影特工</a>（其实叫<del>忍者阿卡林</del>）</h2><blockquote><p>主观评分：<strong>4.2</strong>/5</p></blockquote><p><img src="http://imgs.aixifan.com/cms/2018_10_29/1540809854635.jpg?imageView2/1/w/225/h/300"></p><p>其实这部作品在国内外评价不是特别好，但是我还是特别喜欢这部作品，酷酷的音乐，酷酷的行动。</p><p>但是这些都不是最重要的，这部番最吸引我的就是它其中的师徒关系吧，现实中作为一名师傅，真的很羡慕这种关系QAQ</p><p>还有这部番还有点轻百合元素，也是我给它的加分项。</p><p>客观来说这部番并不优秀，但是还是安利给大家看下！！！</p><h2 id="佐贺偶像是传奇"><a href="#佐贺偶像是传奇" class="headerlink" title="佐贺偶像是传奇"></a><a href="http://www.acfun.cn/bangumi/aa5022161">佐贺偶像是传奇</a></h2><blockquote><p>主观评分：<strong>4.5</strong>/5</p></blockquote><p><img src="http://imgs.aixifan.com/cms/2018_10_29/1540809919451.jpg?imageView2/1/w/225/h/300"></p><p>“Fran Chou Chou 是超越了时代 为了互相支持各自的想法而存在的 胸怀昭和偶像的矜持 在这个时代展开活动的你的身影”</p><p>出了三集才追的这部番，我也不明白自己为什么这么喜欢这部番，但是如果把它和其他的偶像番对比下可能就会找到答案。</p><ol><li>角色不同时代，有多元的角色魅力</li><li>永恒的存在，不用考虑现实的可能性</li><li>加入了搞笑和无厘头的元素</li></ol><p>但是它的魅力还远不止于此，请务必去亲自体会，第二季是肯定有了。</p><h2 id="青春猪头少年不会梦到兔女郎学姐"><a href="#青春猪头少年不会梦到兔女郎学姐" class="headerlink" title="青春猪头少年不会梦到兔女郎学姐"></a><a href="http://bangumi.bilibili.com/anime/25733">青春猪头少年不会梦到兔女郎学姐</a></h2><blockquote><p>主观评分：<strong>4.8</strong>/5</p></blockquote><p><img src="https://i0.hdslb.com/bfs/bangumi/1cc333ff578e5ea9fded7e454953a4e2291440c2.png@282w_375h.webp"></p><p>我是从《樱花庄的宠物女孩》认识的鸭志田一，它笔下所描绘出来的青春，看上去是华丽的，飘渺的，但实际上又有几分现实。我至今还记得，初三看《樱花庄》最后一集的时候，空太一行人在烟火下的奔跑，他们都有自己想做的事，他们也有成功也有失败，他们有的人天赋异禀也有不那么擅长的……伴随着他们的奔跑，我也开始了奔跑。</p><p>我其实一直想看“青春猪头系列”的小说，奈何初三暑假在荒郊野岭，高一住宿，走读后又在学奥赛，一直没能抽空阅读。直到这次的动画化。</p><p>我不太想告诉大家这部作品有多好，因为我做不到，这样只会凸显出我的拙劣文笔，所以我只能说说其他方面。</p><p>“有多少个人，就有多少个可见的世界，一定如此。就像你看到的地平线，要比我所能看到的更远一样，这股海风也是一样，既有人觉得舒服，也有人因为这会让皮肤和头发黏糊糊，所以不喜欢。……我的人生中也绝没有什么远大的梦想或希望，但即便如此，我还是找到了机子的人生意义。我呢， 觉得人生是为了变得善良而存在的，一边思考‘今天的我哪怕能比昨天更善良一点就好了’一边去生活。既然你知道不被人理解的痛苦，一定会变得比别人更加善良，一定能成为别人的支撑。”——牧之原翔子</p><p>原先我看番的时候其实是经常审视自己的，但是最近却没有，这段话确实又唤起了我的这份记忆。而且看完最后一话，我突然有了想写日记的想法（也确实在这么做），并不是无脑模仿，而是发自真心地想让自己变得更好。</p><p>如果你都看到这里还不去看这部番的化就是不给我面子了QAQ</p><p>由于不能剧透所以并没有详细地介绍和总结这部番，等哪天我二刷的时候再填上吧。</p><p>剧场版也不远了</p><hr><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>这个总结写了我整整一年！！！！</p><p>这个季度是最让我看得开心的季度，今年希望也如此。</p><p>但是今年还是少追点番吧，毕竟压力更大了orz</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CQOI2017]小Q的棋盘</title>
    <link href="/2018/12/19/%5BCQOI2017%5D%E5%B0%8FQ%E7%9A%84%E6%A3%8B%E7%9B%98/"/>
    <url>/2018/12/19/%5BCQOI2017%5D%E5%B0%8FQ%E7%9A%84%E6%A3%8B%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3698">题目链接</a></p></blockquote><hr><p>首先这是一颗树。</p><p>这一题我们用贪心的方法来解决，首先来看看样例：</p><p><img src="http://bubbleioa.top/wp-content/uploads/2018/12/P3698-1.png"></p><p>样例1很不友好，不如不给，显然我们可以经过3个点。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2018/12/P3698-2.png"></p><p>我们可以从样例2发现我们的贪心策略。</p><p>为了实现经过的点最多的这一条件，我们希望每次走一步都多走一个点，如果我们选择最长链的话，在链上每走一步就多走了一个点，如果走不完最长链，那答案就是步数+1，而如果走完最长链还有剩余步数的话，每两步可以多访问一个节点。</p><p><strong>为什么剩余步数每两步可以多访问一个节点？</strong></p><p>对于没有全访问的情况（如果这种方法求出来的值大于总数，则输出总数），最长链上肯定存在一条边连着一个没有访问的节点 ，当走到这里的时候，可以花两步去访问再回来。</p><p><strong>为什么最长链是最优的？</strong></p><p><del>显然</del>，因为如果我们不走最长链的话，我们走任意其他的链对答案的贡献都没有最长链大，虽然剩下的剩余步数多，但是根据上面的推论，每两个剩余步数才有一个贡献，因此最长链是最优的。</p><p>讲得已经比较清楚了，有些细节没有提到，建议先自己写一遍再看代码！！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN = 103;int Nt[MAXN&amp;lt;&amp;lt;1],Head[MAXN&amp;lt;&amp;lt;1],to[MAXN&amp;lt;&amp;lt;1],tot;bool used[MAXN];int n,m;int mx=0;void add(int a,int b)&#123;    Nt[++tot]=Head[a];    to[tot]=b;    Head[a]=tot;&#125;    void dfs(int pos,int dep)&#123;//最长链可以用深搜跑最大深度得到    used[pos]=1;    mx=max(mx,dep);    for(int i=Head[pos];i;i=Nt[i])&#123;        int y=to[i];        if(used[y])continue;        dfs(y,dep+1);    &#125;&#125;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=1;i&amp;lt;n;i++)&#123;        int a,b;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);        add(a,b);add(b,a);    &#125;    dfs(0,1);    if(m&amp;lt;=mx-1)printf(&amp;quot;%d\n&amp;quot;,m+1);//如果走不完最长链，那答案就是步数+1    else printf(&amp;quot;%d\n&amp;quot;,min(n,mx+(m-mx+1)/2));    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[UVA11105] Semi-prime H-numbers</title>
    <link href="/2018/12/08/%5BUVA11105%5D%20Semi-prime%20H-numbers/"/>
    <url>/2018/12/08/%5BUVA11105%5D%20Semi-prime%20H-numbers/</url>
    
    <content type="html"><![CDATA[<h1>题面</h1><blockquote>  <a href="https://www.luogu.org/problemnew/show/UVA11105">题面链接</a></blockquote><h1>题目大意</h1><p>形如4n+1的数被称为“H数”，乘法在“H数”组成的集合内是封闭的。在这个集合中只能被1和本身整除的数叫做“H素数”（不包括1），其余的数被称为“H合数”。一个“H合成数”是一个能且只能分解成两个“H素数”乘积的“H合数”（可能由多种分解方案）。比如441=21<em>21=9</em>49，所以411是“H合成数”，125=5<em>5</em>5，所以125不是“H合成数”。<br>求0~h范围内“H合成数”的个数。</p><h1>题解</h1><p>思路其实很简单，既然只有两个“H素数”的乘积是一个“H合成数”的话，那么我们把所有的“H素数”筛出来再来组合不就是“H合成数”了吗？</p><p>筛法我们可以直接在埃式筛法上改一下，也就是标记合数的方法。</p><p>也就是我们要标记的数其实是满足：</p><ol>    <li>是4n+1的倍数</li>    <li>mod4余1</li></ol><p>于是我们可以得到下面的式子：</p><center>[latex]k(4n+1)\%4=1[/latex]<p>[latex]4kn%4+k%4=1[/latex]</p><p>[latex]k%4=1[/latex]</p></center>就可以得到k其实是下面这组数：<center>[latex]\{k|k\in 4i+1,i\ge1\}[/latex]</center>筛出H素数后枚举两两相乘（超过了1000001就break啦，不要再作没意义的事），开个桶s（0和1，顺便起到去重的作用），然后算桶的前缀和，s[i]就是0~i范围内的H合成数```cpp#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000004;bool p[MAXN];int prime[MAXN],cnt;int s[MAXN];int n;<p>void primes(int n){<br>    for(int i=5;i&lt;=n;i+=4){<br>        if(p[i])continue;<br>        prime[++cnt]=i;<br>        for(int k=1;k<em>i&lt;=n;k+=4){<br>            p[k</em>i]=1;<br>        }<br>    }<br>}</p><p>int main(){<br>    primes(1000001);<br>    for(int i=1;i&lt;=cnt;i++){<br>        for(int j=1;j&lt;=i&amp;&amp;prime[i]*prime[j]&lt;MAXN;j++){<br>            s[prime[i]*prime[j]]=1;<br>        }<br>    }<br>    for(int i=1;i&lt;=1000001;i++)s[i]+=s[i-1];<br>    while(scanf(&quot;%d&quot;,&amp;n)){<br>        if(n==0)break;<br>        printf(&quot;%d %d\n&quot;,n,s[n]);<br>    }<br>    return 0;<br>}<br>```</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[POJ1061]青蛙的约会</title>
    <link href="/2018/12/08/%5BPOJ1061%5D%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/"/>
    <url>/2018/12/08/%5BPOJ1061%5D%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h2>Description</h2><p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。</p><p>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。</p><h2>Input</h2><p>输入只包括一行5个整数x，y，m，n，L，其中0 &lt; m、n &lt; 2000000000 ,0 &lt; L &lt; 2100000000。</p><h2>Output</h2><p>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”</p><h2>Sample Input</h2><pre><code class="line-numbers">1 2 3 4 5</code></pre><h2>Sample Output</h2><pre><code class="line-numbers">4</code></pre><h2>Source</h2><p>浙江</p><hr><p>其实这一题洛谷的数据更毒一点。<br>虽然在洛谷上是一道绿题，不过数学这方面我是真的不擅长，以至于这一题我觉得比树剖的题目还难。</p><h2>代码</h2><pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long x,y,m,n,l; long long exgcd(long long a,long long b,long long &amp;x,long long &amp;y)&#123;    if(b==0)&#123;        x=1,y=0;        return a;    &#125;    long long g=exgcd(b,a%b,x,y);    long long t=x;    x=y;    y=t-a/b*y;    return g;&#125;int main()&#123;    scanf("%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;m,&amp;n,&amp;l);    long long d=x-y,a=n-m;    if(a&lt;0)a=-a,d=-d;    long long t,p;//a*t+l*p=d    long long g=exgcd(a,l,t,p);    long long ans=d/g*t;l/=g;ans%=l;if(ans&lt;=0) ans+=l;    if(d%g!=0)printf("Impossible\n");    else printf("%lld\n",ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2018复盘（终于不咕咕啦！）</title>
    <link href="/2018/11/11/NOIP2018%E5%A4%8D%E7%9B%98%EF%BC%88%E7%BB%88%E4%BA%8E%E4%B8%8D%E5%92%95%E5%92%95%E5%95%A6%EF%BC%81%EF%BC%89/"/>
    <url>/2018/11/11/NOIP2018%E5%A4%8D%E7%9B%98%EF%BC%88%E7%BB%88%E4%BA%8E%E4%B8%8D%E5%92%95%E5%92%95%E5%95%A6%EF%BC%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>先占个坑，<del>突然发现可以把发布时间调早一点</del></p><h1 id="D1T1-铺设道路"><a href="#D1T1-铺设道路" class="headerlink" title="D1T1 铺设道路"></a>D1T1 铺设道路</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P5019">题面</a></p></blockquote><p>虽然很多人在喊是原题，但是还是写下放下三种写法吧。<br>很容易想到解法，就是维护区间最小值，达到[latex]O(nlogn)[/latex]的复杂度。<br>但是这样子的写法无论是时间上还是代码复杂度上都比不过正解。</p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#define lt p&amp;lt;&amp;lt;1#define rt (p&amp;lt;&amp;lt;1)|1using namespace std;const int MAXN =100000;int n,cnt,ans;struct segT&#123;    int r,l,num,id;&#125;tree[MAXN*4];void build(int p,int l,int r)&#123;    tree[p].r=r,tree[p].l=l;    if(l==r)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;tree[p].num);        tree[p].id=++cnt;        return;    &#125;    int mid=(l+r)&amp;gt;&amp;gt;1;    build(lt,l,mid);    build(rt,mid+1,r);    if(tree[lt].num&amp;gt;tree[rt].num)&#123;        tree[p].num=tree[rt].num;        tree[p].id=tree[rt].id;    &#125;    else &#123;        tree[p].num=tree[lt].num;        tree[p].id=tree[lt].id;    &#125;&#125;int ask(int p,int ql,int qr)&#123;    if(tree[p].l&amp;gt;=ql&amp;amp;&amp;amp;tree[p].r&amp;lt;=qr)&#123;        return p;    &#125;    int mid=(tree[p].l+tree[p].r)/2;    if(mid&amp;gt;=qr)return ask(lt,ql,qr);    if(mid&amp;lt;ql)return ask(rt,ql,qr);    int o1=ask(lt,ql,qr),o2=ask(rt,ql,qr);    if(tree[o1].num&amp;lt;tree[o2].num) return o1;    else return o2;&#125;void dfs(int l,int r,int sum)&#123;    if(l&amp;gt;r)return;    int tmp=ask(1,l,r);    ans+=(tree[tmp].num-sum);    dfs(l,tree[tmp].id-1,tree[tmp].num);    dfs(tree[tmp].id+1,r,tree[tmp].num);&#125;int main()&#123;    cin&amp;gt;&amp;gt;n;    build(1,1,n);    dfs(1,n,0);    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre><p>考场上炸了（具体看我的退役记orz）写了一个[latex]O(nm)[/latex]的复杂度的算法，m是数字的种类。（其实这个复杂度我也不是很确定）<br>然后测了4组数据，学军的和牛客的只有70，另外两组是100<del>跑的还挺快</del>，希望官方数据不要把我卡掉啊QAQ  </p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=100003;int a[MAXN];int n;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);    long long ans=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        while(a[i]!=0)&#123;            int l=i,r=i;            int mi=a[i];            while(l-1&amp;gt;=1&amp;amp;&amp;amp;a[l-1]!=0)mi=min(a[--l],mi);            while(r+1&amp;lt;=n&amp;amp;&amp;amp;a[r+1]!=0)mi=min(a[++r],mi);            for(int j=l;j&amp;lt;=r;j++)a[j]-=mi;            ans+=mi;        &#125;    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre><p>正解只有12行，很容易想到，前面的如果比后面的高，肯定需要额外的操作来消除，记录入cnt即可</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,d[100005],cnt;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;d[i]);        if(d[i]&amp;gt;d[i-1]) cnt+=d[i]-d[i-1];    &#125;    cout&amp;lt;&amp;lt;cnt;    return 0;&#125;</code></pre><p>还是想说下ccf这种恶劣的行为，又不是没有更好的题目，这样子真的是没意思……</p><h1 id="D1T2-货币系统"><a href="#D1T2-货币系统" class="headerlink" title="D1T2 货币系统"></a>D1T2 货币系统</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P5020">题面</a></p></blockquote><p><strong>居然没有看出是完全背包！！！</strong>，一开始还用着自己智障的数学推论，结果最后还是打的深搜，60pt到85pt左右  </p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n;int a[112];int flag;void dfs(int now,int lim,int tar)&#123;    if(now&amp;gt;tar||flag)return;    if(now==tar)&#123;flag=1;return;&#125;    for(int i=1;i&amp;lt;=lim;i++)&#123;        if(a[i]==-1)continue;        dfs(now+a[i],lim,tar);        if(flag)return;    &#125;&#125;int main()&#123;    int t;scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);    while(t--)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        int ans=n;        for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);        sort(a+1,a+1+n);        for(int i=1;i&amp;lt;=n;i++)&#123;            flag=0;            dfs(0,i-1,a[i]);            if(flag==1)&#123;                ans--;a[i]=-1;            &#125;        &#125;        cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre><p>正解其实有点像数论里面的筛法</p><p>考虑 $f[i]$ 表示价格 $i$ 能被出示， $f[0]=1$</p><p>由于大面值的钱不能表示小面值的，但小面值可能可以表示大面值的钱<br>我们对面值进行升序排序，对于每一个面值 $a[i]$ 它能表示的钱为 $x\times a[i] , x\in N $<br>于是我们遇到一个数 $a[i]$ 先判断 $a[i]$ 是否能被表示（即 $f[a[i]]$ 是否为1 ），如果能被表示，则答案减一，否则更新 $f$</p><p><del>这么简单没拿100真的很后悔</del></p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n;int a[112];bool f[25005];int main()&#123;    int t;scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);    while(t--)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        int ans=n;        for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);        sort(a+1,a+1+n);memset(f,0,sizeof(f));        f[0]=1;        for(int i=1;i&amp;lt;=n;i++)&#123;            if(f[a[i]])&#123;                ans--;continue;            &#125;            for(int j=a[i];j&amp;lt;=25000;j++)f[j]=f[j]|f[j-a[i]];        &#125;        cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre><h1 id="D1T3-赛道修建"><a href="#D1T3-赛道修建" class="headerlink" title="D1T3 赛道修建"></a>D1T3 赛道修建</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P5021">题面</a></p></blockquote><p>考场40pt，实际上有55pt的部分分是很好拿的，这里只介绍AC做法，<del>我被卡常了！！</del></p><p>看到最小的最大值，马上想到二分答案，但是如何判断这个答案是否可行呢？</p><p>虽然它图画的是方方正正的，但是它任然是一棵树，我们可以考虑自下向上的统计答案</p><p>显然一个子节点到父节点的道路只有一条，为了最优，我们希望子节点拿一条最长的路贡献给父节点</p><p>假设子节点能给父节点提供的长度为 $val_i$ （其中已经包含子节点到父节点路径长度）</p><p>该父节点首先要考虑能否选出满足二分答案k的赛道。</p><ol><li>$k\leq val_i$ 这时这条赛道符合</li><li>$k\leq val_a+val_b $ 这时这两条路径组合成的道路符合</li></ol><p>对于第一种情况我们很容易就能判断出，但是对于第二种情况，我们如果希望答案最优，就要从最小的 $val_a$ 考虑，为此，我们需要找到一个最小的 $val_b$ 使得 $k\leq val_a+val_b $</p><p>这个可以用 $multiset$ 来处理。</p><p>注意被选中的路径不能再贡献给当前节点的父节点了。</p><p>可以考虑找出树的直径优化二分上界。</p><p>在loj上最慢的点也才200ms，但是洛谷上T了两个点（怕不是要手写平衡树）</p><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN = 50005;int Head[MAXN], Nt[MAXN &amp;lt;&amp;lt; 1], to[MAXN &amp;lt;&amp;lt; 1], w[MAXN &amp;lt;&amp;lt; 1], tot = 1;int n, m, sum;int d[MAXN];bool v[MAXN &amp;lt;&amp;lt; 1];int flag = 0;int mx, mxid, res;multiset&amp;lt;int&amp;gt; s[MAXN];multiset&amp;lt;int&amp;gt;::iterator it;void add(int a, int b, int c) &#123;    Nt[++tot] = Head[a];    to[tot] = b;    w[tot] = c;    Head[a] = tot;&#125;int dfs(int x, int fa, int k) &#123;    s[x].clear();    int val;    for (int i = Head[x]; i; i = Nt[i]) &#123;        int y = to[i];        if (y == fa)            continue;        val = dfs(y, x, k) + w[i];        if (val &amp;gt;= k)//已经满足条件，条数+1            res++;        else            s[x].insert(val);    &#125;    int maxx = 0;    while (s[x].size()) &#123;        if (s[x].size() == 1) &#123;//如果只有一个子节点（子树），直接返回            return max(maxx, *s[x].begin());        &#125;        it = s[x].lower_bound(k - *s[x].begin());//找到最小的x,使得x+最小值&amp;gt;=k        if (it == s[x].begin() &amp;amp;&amp;amp; s[x].count(*it) == 1)//如果找到的是最小值自己(即最小值两倍&amp;gt;=k)，但是最小值是唯一的，找下一个            it++;        if (it == s[x].end()) &#123;//如果没找到            maxx = max(maxx, *s[x].begin());//说明当前的最小值不行，请离场            s[x].erase(s[x].find(*s[x].begin()));        &#125; else &#123;            res++;//如果找到了，条数+1            s[x].erase(s[x].find(*it));//女嘉宾离场            s[x].erase(s[x].find(*s[x].begin()));//男嘉宾离场        &#125;    &#125;    return maxx;&#125;void dfs1(int x) &#123;    for (int i = Head[x]; i; i = Nt[i]) &#123;        int y = to[i];        if (v[y])            continue;        v[y] = 1;        d[y] = d[x] + w[i];        if (d[y] &amp;gt; mx) &#123;            mx = d[y];            mxid = y;        &#125;        dfs1(y);    &#125;&#125;bool check(int k) &#123;    res = 0;    dfs(1, 0, k);    if (res &amp;gt;= m)        return 1;    return 0;&#125;int main() &#123;    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);    for (int i = 1; i &amp;lt; n; i++) &#123;        int a, b, c;        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);        add(a, b, c);        add(b, a, c);        sum += c;    &#125;    dfs1(1);    int y = mxid;    mx = 0;    memset(v, 0, sizeof(v));    memset(d, 0, sizeof(d));    dfs1(y);    int ans = 0;    int l = 1;    int r = mx;    while (l &amp;lt;= r) &#123;        int mid = (l + r) &amp;gt;&amp;gt; 1;        if (check(mid)) &#123;            ans = mid;            l = mid + 1;        &#125; else            r = mid - 1;    &#125;    printf(&amp;quot;%d\n&amp;quot;, ans);    return 0;&#125;</code></pre><h1 id="D2T1-旅行"><a href="#D2T1-旅行" class="headerlink" title="D2T1 旅行"></a>D2T1 <a href="https://www.luogu.org/problemnew/show/P5022">旅行</a></h1><p>又是一道本该拿满分的题，考场上打开题目-&gt;一眼看出基环树-&gt;只听过名字不会写-&gt;拿60pt愉快走人吧~</p><p>结果我完全忽视了8700k和n&lt;=5000的存在，明显有一种平方的做法啊，就是暴力删边，然后就是一棵树了……mdzz</p><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN = 5004;vector&amp;lt;int&amp;gt; g[MAXN];int n, m;int num[MAXN], tmp[MAXN], cnt, dep;bool v[MAXN];struct edge&#123;    int from, to;&#125; e[MAXN &amp;lt;&amp;lt; 1];int tot;int k, z;void add(int x, int y)&#123;    e[++tot].from = x;    e[tot].to = y;&#125;void dfs1(int x)&#123;    for (int i = 0; i &amp;lt; (int)g[x].size(); i++)    &#123;        int y = g[x][i];        if (v[y])            continue;        v[y] = 1;        num[++cnt] = y;        dfs1(y);    &#125;&#125;void dfs(int x)&#123;    v[x] = 1;    tmp[++dep] = x;    for (int i = 0; i &amp;lt; g[x].size(); i++)    &#123;        int to = g[x][i];        if (v[to] || (to == k &amp;amp;&amp;amp; x == z) || (to == z &amp;amp;&amp;amp; x == k))            continue;        dfs(to);    &#125;&#125;bool check()&#123;    for (int i = 1; i &amp;lt;= n; i++)    &#123;        if (tmp[i] == num[i])            continue;        if (tmp[i] &amp;gt; num[i])            return false;        else            return true;    &#125;&#125;int read()&#123;    int x = 0, f = 1;    char ch = getchar();    while (!isdigit(ch))    &#123;        if (ch == &amp;#039;-&amp;#039;)            f = -1;        ch = getchar();    &#125;    while (isdigit(ch))    &#123;        x = x * 10 + ch - &amp;#039;0&amp;#039;;        ch = getchar();    &#125;    return f * x;&#125;int main()&#123;    n = read();    m = read();    for (int i = 1; i &amp;lt;= m; i++)    &#123;        int x, y;        x = read();        y = read();        add(x, y);        add(y, x);        g[x].push_back(y);        g[y].push_back(x);    &#125;    for (int i = 1; i &amp;lt;= n; i++)        sort(g[i].begin(), g[i].end());    if (m == n - 1)    &#123;        v[1] = 1;        num[++cnt] = 1;        dfs1(1);        for (int i = 1; i &amp;lt;= cnt; i++)        &#123;            printf(&amp;quot;%d &amp;quot;, num[i]);        &#125;    &#125;    else    &#123;        for (int i = 1; i &amp;lt; tot; i += 2)        &#123;            dep = 0;            k = e[i].from, z = e[i].to;            memset(v, 0, sizeof(v));            dfs(1);            if (dep &amp;lt; n)                continue;            if (num[1] == 0)                for (int i = 1; i &amp;lt;= n; i++)                    num[i] = tmp[i];            else if (check())                for (int i = 1; i &amp;lt;= n; i++)                    num[i] = tmp[i];        &#125;        for (int i = 1; i &amp;lt;= n; i++)        &#123;            printf(&amp;quot;%d &amp;quot;, num[i]);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2018退役记</title>
    <link href="/2018/11/10/NOIP2018%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <url>/2018/11/10/NOIP2018%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>上午敲了些板子，树剖还是没能一遍过orz</p><p>中午第二次到教工食堂吃饭，真香！</p><p>坐高铁去南昌，很快就到了。</p><p>做公交车到南大，下车的时候手机和身份证一起落在车上，打了19个电话后终于接了，又回了一遍南昌西，还好什么都没丢，差点提前退役QAQ，一个下午就过去了。</p><p>傍晚去看机房，晚餐在南大的九食堂吃的，一餐8元，特别好吃（比起我们学校），在南昌的每餐都是在这里吃的。</p><p>遇到了JK大佬@<a href="https://rye-catcher.github.io/">Rye_Catcher</a>，意外的很聊得来，祝进队！</p><p>前湖迎宾馆性价比是真的低，没办法，只有这里还有房间了<del>大堂香味还挺好闻</del>。</p><p>晚上和@<a href="https://www.luogu.org/space/show?uid=92770">March_H</a>颓了一下，后来意识到自己并没有March_H大佬的实力，就去敲了一下板子，补了下数学<del>虽然后面并没有用到</del></p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>ccf的老爷机终于换了，现在是i7-8700k,32GB RAM<del>这跨度也太大了吧</del>，于是很高兴的没有加任何的常数优化。</p><p>不知道怎么排座位的，反正我是把考场遍历了一边才找到座位。</p><p>考试刚开始没进入状态，就是每看到一道题，就想先敲正解，而且非常着急（T2想到了一个智障的结论，想都没想就写了60行，还调试了蛮久）</p><p>10点上了个厕所，感觉前面1个多小时在浪费时间。</p><p>T1敲了暴力，应该是[latex]O(n^2)[/latex]复杂度，结果给的样例二n=100,000都过了，不管了，i7莽过去</p><p>T2敲了暴力，应该是[latex]O(n!)[/latex]的复杂度，加了点玄学优化，变成了[latex]O(k!)[/latex]的复杂度，其中k是答案。结果给的样例二k有20多，还是过了，不管，i7冲呀(实际时间复杂度上和a[i]的大小有关)<br>打了搜索都没发现这是道完全背包题，我还是太弱了。</p><p>T3骗了20分<del>其实还有20分没骗到</del>，就是求了个树的直径。</p><p>听说有两道POI的原题，果然NOIP就是POI*N吗（逃ε=ε=ε=┏(゜ロ゜;)┛</p><p>先提前祝贺@<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a>省一，T1本来写的线段树，嫌慢还换成了ST表，tql，也要感谢他的水，要不是喝了他的水，我就不会上厕所，D1就要爆0了。</p><p>又和@<a href="https://www.luogu.org/space/show?uid=92770">March_H</a>颓了一下，后面发现还是看番有趣。</p><p>“魔法什么的，最讨厌了”——总重复这句话，根据真香定理应该……</p><p>晚上看了下番+板子+数学，明天应该是考模拟，数学之类的东西吧。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>昨天湿了的鞋子还没干，穿着宾馆里的拖鞋去的考场，贼累。<br>键盘还是没换，还好我掌握了右shift的使用方法  </p><p>T1贪心乱搞，骗了60之后就想着先做后面的题，然后回来填坑……然后就再也没看过T1了<br>听说就是找环删边，还有大佬随机删边%%%<br>T2毒瘤，算了一下状压dp会T，然而还是用的状压，结果3*3的数据过不了，写了发暴力，跑出来和外婆状压是一样的orz  死活算不到它给的答案。<br>T3没时间了，想枚举拿20分，结果写完发现理解错了题目意思，完蛋。  </p><p>退役是肯定了的，如果今年分数线比去年高的话省一都不好说，果然还是太弱了。</p><p>下午就直接去车站，准备回去补文化课。</p><hr><p>感觉这次NOIP好迷，第一天就是NOIP=NOI*p，第二天就是NOIP=NOI Pro(雾)</p><p>没有数学，没有模拟，很多原题，很多图论……</p><p>敲过的板子，复习过的内容没有一个用到了orz</p><p>虽然之前考虑过很多次，但真的到退役的时候还真的有些舍不得，毕竟OI陪伴了自己11个月15天</p><p>这只是个退役记并不是总结，所以就写到这吧<del>感觉退役总结又要咕好久</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day6】OI STILE</title>
    <link href="/2018/11/08/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay6%E3%80%91OI%20STILE/"/>
    <url>/2018/11/08/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay6%E3%80%91OI%20STILE/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-引子（水箱）"><a href="#T1-引子（水箱）" class="headerlink" title="T1 引子（水箱）"></a>T1 引子（水箱）</h1><p>非常简单的模拟题目，错误点有两处：</p><ol><li>没有读入多位数字</li><li>出现顺序和编号无关</li></ol><p>然就是从1号水箱，开始递归，优先从箱底的水管递归下去，然后输出自身的编号。</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=1003;char mp[MAXN][MAXN];int n,m;int draw[MAXN][MAXN];int numx1[200003],numy1[200003];int numx2[200003],numy2[200003];  void paint(int col,int i,int j)&#123;    int x=i,y=j;    while(mp[x][y]!=&amp;#039;|&amp;#039;)y++;    while(mp[x][y]!=&amp;#039;+&amp;#039;)x++;    while(mp[i][j]!=&amp;#039;|&amp;#039;)j--;    while(mp[i][j]!=&amp;#039;+&amp;#039;)i--;    for(int k=i;k&amp;lt;=x;k++)&#123;        for(int z=j;z&amp;lt;=y;z++)&#123;            draw[k][z]=col;        &#125;    &#125;    numx1[col]=i;numy1[col]=j;    numx2[col]=x;numy2[col]=y;&#125;  int go(int x,int y,int lasty)&#123;    int flag=1;    while(1)&#123;        if(flag==1)&#123;            int r=y,l=y;            if(y&amp;gt;lasty)&#123;                while(mp[x][r]!=&amp;#039;+&amp;#039;&amp;amp;&amp;amp;mp[x][r]==&amp;#039;-&amp;#039;)r++;            &#125;            else &#123;                while(mp[x][l]!=&amp;#039;+&amp;#039;&amp;amp;&amp;amp;mp[x][l]==&amp;#039;-&amp;#039;)l--;            &#125;            if(y&amp;gt;lasty)&#123;                if(mp[x][r]==&amp;#039;+&amp;#039;)y=r;            &#125;            else &#123;                if(mp[x][l]==&amp;#039;+&amp;#039;)y=l;            &#125;            x++;            flag=2;        &#125;        else &#123;            while(mp[x][y]!=&amp;#039;+&amp;#039;&amp;amp;&amp;amp;mp[x][y]==&amp;#039;|&amp;#039;)x++;            if(draw[x][y]!=0)return draw[x][y];            if(mp[x][y]==&amp;#039;+&amp;#039;)&#123;lasty=y;flag=1;if(mp[x][y+1]==&amp;#039;-&amp;#039;)y++;else y--;&#125;        &#125;    &#125;&#125;        void dfs(int id)&#123;    for(int i=numx2[id]-1;i&amp;gt;=numx1[id]+1;i--)&#123;        if(mp[i][numy1[id]-1]==&amp;#039;-&amp;#039;)&#123;            dfs(go(i,numy1[id]-1,numy1[id]));        &#125;        if(mp[i][numy2[id]+1]==&amp;#039;-&amp;#039;)&#123;            dfs(go(i,numy2[id]+1,numy2[id]));        &#125;    &#125;    printf(&amp;quot;%d\n&amp;quot;,id);&#125;  int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%s&amp;quot;,mp[i]+1);    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=m;j++)&#123;            int num=0;            while(isdigit(mp[i][j]))&#123;                num=num*10+mp[i][j]-&amp;#039;0&amp;#039;;                j++;            &#125;            if(num!=0)paint(num,i,j-1);        &#125;    &#125;    dfs(1);    return 0;&#125;</code></pre><h1 id="T2-可爱精灵宝贝"><a href="#T2-可爱精灵宝贝" class="headerlink" title="T2 可爱精灵宝贝"></a>T2 可爱精灵宝贝</h1><p>一道区间dp题，考场上写挂了，最后10分钟乱搞居然也有60分，考试完调了一下，有90分<del>实际上是数据太水了</del>。</p><p>90分代码：</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=1005;struct node&#123;    int a,b,t;&#125;go[MAXN];int n,k,m;int maxt; int main()&#123;    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;m);    for(int i=1;i&amp;lt;=m;i++)&#123;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;go[i].a,&amp;amp;go[i].b,&amp;amp;go[i].t);        maxt=max(maxt,go[i].t);    &#125;    int mx=0;    for(int i=1;i&amp;lt;=k-1;i++)&#123;        int now=0;        int x=k;int ans=0;        while(x!=i-1&amp;amp;&amp;amp;now&amp;lt;=maxt)&#123;            now++;            for(int j=1;j&amp;lt;=m;j++)&#123;                if(go[j].a==x&amp;amp;&amp;amp;go[j].t&amp;gt;=now)ans+=go[j].b;            &#125;            x--;        &#125;        if(now)&#123;            now--;            now*=2;            &#125;        x=k;        while(now&amp;lt;=maxt&amp;amp;&amp;amp;x&amp;lt;=n)&#123;            for(int j=1;j&amp;lt;=m;j++)&#123;                if(go[j].a==x&amp;amp;&amp;amp;go[j].t&amp;gt;=now)ans+=go[j].b;            &#125;            now++;            x++;        &#125;        mx=max(mx,ans);    &#125;    for(int i=n;i&amp;gt;=k;i--)&#123;        int now=0;        int x=k;int ans=0;        while(x!=i+1&amp;amp;&amp;amp;now&amp;lt;=maxt)&#123;            now++;            for(int j=1;j&amp;lt;=m;j++)&#123;                if(go[j].a==x&amp;amp;&amp;amp;go[j].t&amp;gt;=now)ans+=go[j].b;            &#125;            x++;        &#125;        if(now)&#123;            now--;            now*=2;            &#125;        x=k;        while(now&amp;lt;=maxt&amp;amp;&amp;amp;x&amp;gt;=1)&#123;            for(int j=1;j&amp;lt;=m;j++)&#123;                if(go[j].a==x&amp;amp;&amp;amp;go[j].t&amp;gt;=now)ans+=go[j].b;            &#125;            now++;            x--;        &#125;        mx=max(mx,ans);    &#125;    cout&amp;lt;&amp;lt;mx&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre><p>这里区间dp用的是记忆化搜索实现的，dfs中的参数含义如下：</p><table><thead><tr><th align="center">参数名</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">s</td><td align="center">第s个精灵</td></tr><tr><td align="center">cur</td><td align="center">当前时间</td></tr><tr><td align="center">sum</td><td align="center">当前状态的分数</td></tr><tr><td align="center">l</td><td align="center">当前状态的左端点</td></tr><tr><td align="center">r</td><td align="center">当前状态的右端点</td></tr></tbody></table><p>其中，l和r指的是按位置排序后精灵序号的左右端点，相当于离散化了坐标</p><p>对于状态，我们都有以下选择：</p><ol><li>向右走去捕获右边精灵</li><li>向右走，虽然捕获不到</li><li>向左走去捕获左边精灵</li><li>向左走，虽然捕获不到</li></ol><p>对于每种状态的遍历，我们就可以算出f[i][j]—选择第i到第j个精灵的最大得分（不一定捕获到了）<br>答案就是其中最大的</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=1003;int n,k,m;int f[1003][1003];int ans;struct node&#123;    int pos;    int val;    int t;&#125;a[MAXN];bool book[MAXN];bool cmp(node a,node b)&#123;    return a.pos&amp;lt;b.pos;&#125;void dfs(int s,int cur,int sum,int l,int r)&#123;    if(f[l][r]&amp;gt;=sum)return;    f[l][r]=sum;    if(sum&amp;gt;ans)ans=sum;    book[s]=1;    if(!book[r]&amp;amp;&amp;amp;r&amp;lt;=m)&#123;        if(cur+abs(a[r].pos-a[s].pos)&amp;lt;=a[r].t)&#123;            dfs(r,cur+abs(a[r].pos-a[s].pos),sum+a[r].val,l,r+1);        &#125;        else &#123;            dfs(r,cur+abs(a[r].pos-a[s].pos),sum,l,r+1);        &#125;    &#125;    if(!book[l]&amp;amp;&amp;amp;l)&#123;        if(cur+abs(a[s].pos-a[l].pos)&amp;lt;=a[l].t)&#123;            dfs(l,cur+abs(a[l].pos-a[s].pos),sum+a[l].val,l-1,r);        &#125;        else &#123;            dfs(l,cur+abs(a[l].pos-a[s].pos),sum,l-1,r);        &#125;    &#125;    book[s]=0;//注意回溯&#125;int main()&#123;    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;m);    for(int i=1;i&amp;lt;=m;i++)&#123;        int d,b,c;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;d,&amp;amp;b,&amp;amp;c);        a[i]=(node)&#123;d,b,c&#125;;    &#125;    a[++m]=(node)&#123;k,0,1&#125;;//从k位置开始    sort(a+1,a+1+m,cmp);    memset(f,-1,sizeof(f));    for(int i=1;i&amp;lt;=m;i++)&#123;        if(a[i].pos==k&amp;amp;&amp;amp;a[i].val==0&amp;amp;&amp;amp;a[i].t==1)&#123;            dfs(i,1,0,i-1,i+1);            break;        &#125;    &#125;    printf(&amp;quot;%d&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day5】考试时完全没有思路怎么办？可以暴力吗？可以乱搞吗？</title>
    <link href="/2018/11/07/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay5%E3%80%91%E8%80%83%E8%AF%95%E6%97%B6%E5%AE%8C%E5%85%A8%E6%B2%A1%E6%9C%89%E6%80%9D%E8%B7%AF%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9A%B4%E5%8A%9B%E5%90%97%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B9%B1%E6%90%9E%E5%90%97%EF%BC%9F/"/>
    <url>/2018/11/07/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay5%E3%80%91%E8%80%83%E8%AF%95%E6%97%B6%E5%AE%8C%E5%85%A8%E6%B2%A1%E6%9C%89%E6%80%9D%E8%B7%AF%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9A%B4%E5%8A%9B%E5%90%97%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B9%B1%E6%90%9E%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-改造二叉树"><a href="#T1-改造二叉树" class="headerlink" title="T1 改造二叉树"></a>T1 改造二叉树</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P3365">题面</a></p></blockquote><p>洛谷上的数据有水，过了不代表正确；</p><p>这题还是比较难想的（至少我是这么认为的）  </p><p>首先如果我们对一颗平衡树进行中序遍历，得到的一个遍历的序列是单调上升的。<br>于是我们这道题就转化成一个这样的问题：<br><strong>给一棵二叉树，让它的中序遍历序列变为严格单调上升序列，最少需要多少次修改</strong>  </p><p>《算法竞赛进阶指南（第二版）》的263面提过一个思考题：  </p><blockquote><p>把一个序列A变成非严格单调递增的（单调不下降的），至少需要修改多少个数？</p></blockquote><p>比如2 3 1 4 它变成单调不降的就是2 3 3 4，修改一个数，可以发现，A的最长不降子序列是不需要被修改的，而其他的值需要增加或减小来和原来的最长不下降子序列构成一个新的最长不下降子序列，答案就是A的长度减去A的最长不下降子序列的长度。</p><blockquote><p>把一个序列A变成严格单调递增的，至少需要修改多少个数？</p></blockquote><p>如果2 3 1 4 它变成单调递增的就是2 3 4 5，修改两个数，这是因为3和4之间（从自然数的意义上）有0个自然数，而3和4之间（在数列上）有1个自然数，显然，你无法找到一个自然数它既大于3又小于4，我们定义两个数的差值-1为<strong>容量</strong>，而下标的差值-1我们定义为<strong>装载量</strong>。</p><p>显然如果两个数之间能存在严格单调上升的序列仅当<strong>容量&gt;=装载量</strong>成立，即<strong>容量-装载量&gt;=0</strong></p><p>设序列[latex]a[/latex]，<br>容量&gt;=装载量即为[latex]a_i-a_j\ge i-j[/latex]<br>移项得[latex]a_i-i\ge a_j-j[/latex]<br>由于对于任意项都要成立，所以我们只要用每一项的值减去下标，答案就是长度-最长不降子序列的长度</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int MAXN=100005;int ch[MAXN][2],a[MAXN],n,now,key[MAXN];int f[MAXN],d[MAXN],len=1;void dfs(int x)&#123;    if(ch[x][0]) dfs(ch[x][0]);    a[++now]=key[x];    if(ch[x][1]) dfs(ch[x][1]);&#125;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;key[i]);    int x,fa;    for(int i=2;i&amp;lt;=n;i++)&#123;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;fa,&amp;amp;x);ch[fa][x]=i;&#125;    dfs(1);    for(int i=1;i&amp;lt;=n;i++)a[i]-=i;    d[1]=a[1];    for(int i=2;i&amp;lt;=n;i++)&#123;//nlogn        if(a[i]&amp;gt;=d[len])d[++len]=a[i];        else &#123;            int j=upper_bound(d+1,d+len+1,a[i])-d;            d[j]=a[i];        &#125;    &#125;    printf(&amp;quot;%d\n&amp;quot;,n-len);    return 0;&#125;</code></pre><h1 id="T2-数字对"><a href="#T2-数字对" class="headerlink" title="T2 数字对"></a>T2 数字对</h1><p>这题真的就是乱搞也能过，数据是全随机的，然而考试的时候还是写的是暴力，虽然优化成了[latex]O(n^3logn)[/latex]但是和[latex]O(n^4)[/latex]的分数一样．<br>有两种乱搞方法，一种是枚举每个点向两边拓展，另一种是枚举两个端点（这种方法等下会放代码），前者意外跑的很快．．．　　<br>第二种乱搞方法是上届学长留下来的：　　　</p><hr><pre><code class="cpp">/*@author:dpj*/#include&amp;lt;set&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;const int MAXN=500001;int n,a[MAXN];struct Node&#123;    int l,r;&#125;ans[MAXN];int main()&#123;    freopen(&amp;quot;pair.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);    freopen(&amp;quot;pair.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);    int Max=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=i;j&amp;gt;=1;j--)&#123;            if(a[j]%a[i]) break;            ans[i].l=j;        &#125;        for(int j=i;j&amp;lt;=n;j++)&#123;            if(a[j]%a[i]) break;            ans[i].r=j;        &#125;        Max=max(Max,ans[i].r-ans[i].l);    &#125;    int tot=0;    multiset&amp;lt;int&amp;gt;s;    int last=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(ans[i].r-ans[i].l==Max)&#123;            if(ans[i].l==last) continue;            last=ans[i].l;            tot++;            s.insert(ans[i].l);        &#125;    &#125;    printf(&amp;quot;%d %dn&amp;quot;,tot,Max);    multiset&amp;lt;int&amp;gt;::iterator it;    for(it=s.begin();it!=s.end();it++)        printf(&amp;quot;%d &amp;quot;,(*it));    fclose(stdin);    fclose(stdout);    return 0;&#125;</code></pre><p>对于每一个特殊区间，它的特殊点一定满足的条件是ＧＣＤ＝最小值<br>于是我们可以维护区间的GCD和最小值，<br>区间长度我们也可以不用暴力枚举，直接二分即可．<br>此时我们只二分出来了最大的长度，要想知道具体的答案，还得根据算出来的长度扫一遍数组，合法性的判定和上面是一样的　　</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=500003,M=21;int n,m;int a[MAXN],f[MAXN][M],g[MAXN][M],p[M];int gcd(int a,int b)&#123;    return b?gcd(b,a%b):a;&#125;inline char nc()&#123;    static char buf[MAXN],*p1=buf,*p2=buf;    return p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123;    char ch=&amp;#039;[&amp;#039;;int x=0,f=1;    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=nc();&#125;    while(isdigit(ch))&#123;x=(x&amp;lt;&amp;lt;3)+(x&amp;lt;&amp;lt;1)+(ch^48);ch=nc();&#125;    return x*f;&#125;bool check(int len)&#123;    int q=log2(len),k=n+1-p[q];    for(int i=1;i&amp;lt;=k;i++)&#123;        int j=i+len-1;        if(min(f[i][q],f[j-p[q]+1][q])==gcd(g[i][q],g[j-p[q]+1][q]))return true;//如果区间最小值=区间gcd,合法    &#125;    return 0;&#125;int main()&#123;    freopen(&amp;quot;pair.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);    freopen(&amp;quot;pair.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);    n=read();m=log2(n);    for(int i=1;i&amp;lt;=n;i++)&#123;        int tmp=read();        f[i][0]=g[i][0]=tmp;    &#125;    for(int i=0;i&amp;lt;=m;i++)p[i]=1&amp;lt;&amp;lt;i;    for(int j=1;j&amp;lt;=m;j++)&#123;//预处理ST表        int k=n+1-p[j];        for(int i=1;i&amp;lt;=k;i++)&#123;            f[i][j]=min(f[i][j-1],f[i+p[j-1]][j-1]);            g[i][j]=gcd(g[i][j-1],g[i+p[j-1]][j-1]);        &#125;    &#125;    int l=1,r=n,ans=0;    while(l&amp;lt;=r)&#123;//二分最大区间长度        int mid=(l+r)&amp;gt;&amp;gt;1;        if(check(mid))&#123;l=mid+1;&#125;        else &#123;r=mid-1;&#125;    &#125;    ans=r;    if(ans==1)&#123;//最大长度为1,全部为单独的数字        printf(&amp;quot;%d %dn&amp;quot;, n, 0);        for(int i=1;i&amp;lt;n;++i)printf(&amp;quot;%d &amp;quot;,i);        printf(&amp;quot;%dn&amp;quot;, n);    &#125;    else &#123;        int q=log2(ans),k=n+1-p[q],tot=0;        for(int i=1;i&amp;lt;=k;++i)&#123;//枚举最大长度的所有区间,统计个数，记录答案            int j=i+ans-1;            if(min(f[i][q],f[j-p[q]+1][q])==gcd(g[i][q],g[j-p[q]+1][q]))a[++tot]=i;        &#125;        printf(&amp;quot;%d %dn&amp;quot;,tot,ans-1);        for (int i=1;i&amp;lt;tot;++i)printf(&amp;quot;%d &amp;quot;,a[i]);        printf(&amp;quot;%dn&amp;quot;,a[tot]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人生第一次Pull Request被采纳了！！</title>
    <link href="/2018/11/07/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1Pull%20Request%E8%A2%AB%E9%87%87%E7%BA%B3%E4%BA%86%EF%BC%81%EF%BC%81/"/>
    <url>/2018/11/07/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1Pull%20Request%E8%A2%AB%E9%87%87%E7%BA%B3%E4%BA%86%EF%BC%81%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h2 id="人生第一次Pull-Request被采纳了！！"><a href="#人生第一次Pull-Request被采纳了！！" class="headerlink" title="人生第一次Pull Request被采纳了！！"></a>人生第一次Pull Request被采纳了！！</h2><p>记录下这个时刻！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[sdut1808]安全网络问题</title>
    <link href="/2018/11/06/%5Bsdut1808%5D%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2018/11/06/%5Bsdut1808%5D%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1808.html">题面</a></p></blockquote><p>只能看看题面，数据是错的。</p><p>就是求一张图的所有点双连通分量，将它们内部排序再外部排序数出来，关于点双连通分量没什么好讲的，网上各种博客都写烂了。还是直接上代码吧。</p><hr><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt; #include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAXN=600000;int n;int Nt[MAXN&amp;lt;&amp;lt;1],to[MAXN&amp;lt;&amp;lt;1],Head[MAXN],tot;int root;int dfn[MAXN],low[MAXN],cut[MAXN];vector&amp;lt;int&amp;gt;dcc[MAXN];int num,cnt;int st[MAXN],top; void add(int a,int b)&#123;    Nt[++tot]=Head[a];    to[tot]=b;    Head[a]=tot;&#125; void tarjan(int x)&#123;    dfn[x]=low[x]=++num;    st[++top]=x;    if(x==root&amp;amp;&amp;amp;Head[x]==0)&#123;        dcc[++cnt].push_back(x);        return;    &#125;    int flag=0;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(!dfn[y])&#123;            tarjan(y);            low[x]=min(low[x],low[y]);            if(low[y]&amp;gt;=dfn[x])&#123;                flag++;                if(x!=root||flag&amp;gt;1)cut[x]=1;                cnt++;                int z;                do&#123;                    z=st[top--];                    dcc[cnt].push_back(z);                &#125;while(z!=y);                dcc[cnt].push_back(x);            &#125;        &#125;        else low[x]=min(low[x],dfn[y]);    &#125;&#125; bool cmp(vector&amp;lt;int&amp;gt;a,vector&amp;lt;int&amp;gt;b)&#123;    int lim=min(a.size(),b.size());    for(int i=0;i&amp;lt;lim;i++)&#123;        if(a[i]==b[i])continue;        return a[i]&amp;lt;b[i];    &#125;    return a.size()&amp;lt;b.size();&#125; int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        int x;scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);x++;        char str[7];scanf(&amp;quot;%s&amp;quot;,str);        int num=0;        for(int j=1;j&amp;lt;strlen(str);j++)&#123;            if(str[j]==&amp;#039;)&amp;#039;)break;            num=num*10+str[j]^48;        &#125;        for(int j=1;j&amp;lt;=num;j++)&#123;            int y;scanf(&amp;quot;%d&amp;quot;,&amp;amp;y);y++;            add(x,y);add(y,x);        &#125;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(!dfn[i])root=i,tarjan(i);    &#125;    for(int i=1;i&amp;lt;=cnt;i++)sort(dcc[i].begin(),dcc[i].end());    sort(dcc+1,dcc+1+cnt,cmp);    cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl;    for(int i=1;i&amp;lt;=cnt;i++)&#123;        for(int j=0;j&amp;lt;dcc[i].size();j++)&#123;            printf(&amp;quot;%d &amp;quot;,dcc[i][j]-1);        &#125;        printf(&amp;quot;\n&amp;quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day4】关于我不开long long见祖宗这桩事</title>
    <link href="/2018/11/06/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay4%E3%80%91%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%8D%E5%BC%80long%20long%E8%A7%81%E7%A5%96%E5%AE%97%E8%BF%99%E6%A1%A9%E4%BA%8B/"/>
    <url>/2018/11/06/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay4%E3%80%91%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%8D%E5%BC%80long%20long%E8%A7%81%E7%A5%96%E5%AE%97%E8%BF%99%E6%A1%A9%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-增援前线"><a href="#T1-增援前线" class="headerlink" title="T1 增援前线"></a>T1 增援前线</h1><p>实锤乱搞题，考试的时候写了一个错误的dp，只拿了一半的分。<br>实际上这一题应该属于贪心吧<br>我们用f[i]表示i号点能站多少人。<br>显然，前l个点的f[i]=a[i]；<br>对于其他情况，f[i]应由i-l到i-1这段区间内的点更新而来。<br>具体来说，就是“能跳则跳，满员为止”<br>我们优先选择距离当前点较远的点来更新，下面将证明这一结论。  </p><p>我们每次只能在[latex]i-l[/latex]到[latex]i-1[/latex]这段区间内选择点来更新答案，每次我们可选的状态空间都会变动（整体右移），如果我们优先选择左边的点来更新的话，右边的点的可选方案数不会改变，而左边的点的可选方案显然是比右边的少的（因为左边的点会先退出可行方案），根据决策包容性我们可知该贪心方案正确。</p><p>代码中的3个if是优化枚举（可行性），否则时间复杂度将达到[latex]O((N-L)\times L)[/latex] <del>然而数据太水不加也能过</del></p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=100004;int f[MAXN],a[MAXN];int n,l;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;l);    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);    for(int i=0;i&amp;lt;=l;i++)f[i]=a[i];    a[n]=0x7fffffff;    for(int i=l+1;i&amp;lt;=n;i++)&#123;        if(a[i]==0)continue;        for(int j=i-l;j&amp;lt;i;j++)&#123;            if(f[j]==0)continue;            if(a[i]==0)break;            int tmp=min(a[i],f[j]);            a[i]-=tmp;f[j]-=tmp;f[i]+=tmp;        &#125;    &#125;    printf(&amp;quot;%d&amp;quot;,f[n]);    return 0;&#125;</code></pre><h1 id="T2-进化序列"><a href="#T2-进化序列" class="headerlink" title="T2 进化序列"></a>T2 进化序列</h1><p>QAQ QAQ QAQ QAQ，就是这一题！！！！<del>我可不是什么邪恶的史莱姆</del><br>考场上先写了一个暴力，然后写了线段树+二分（Binary Segment Tree简称<del>BST</del>），对拍发现答案不一样，最后发现是暴力写错了orz<br>然后自己造了好多大数据，都是暴力跑得快（但是暴力还是被卡了）<br>然后没开long long 或运算起来可能会爆int，见祖宗了<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E9%80%89%E6%89%8B%E8%A1%A8%E6%BC%94.jpg"></p><hr><p>为什么用线段树？我们要查询的区间或值是满足区间可加性的。<br>为什么二分？可以发现越多的数或起来不会变小。</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;#define lt p&amp;lt;&amp;lt;1#define rt p&amp;lt;&amp;lt;1|1using namespace std;const int MAXN=100003;struct segTree&#123;    long long data;    int l,r;&#125;t[MAXN&amp;lt;&amp;lt;2];long long n,m;long long cnt=0; void build(int p,int l,int r)&#123;    t[p].l=l,t[p].r=r;    if(r==l)&#123;        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;t[p].data);        return;    &#125;    int mid=(l+r)&amp;gt;&amp;gt;1;    build(lt,l,mid);    build(rt,mid+1,r);    t[p].data=t[lt].data|t[rt].data;&#125;  int ask(int p,int l,int r)&#123;    if(t[p].r&amp;lt;=r&amp;amp;&amp;amp;t[p].l&amp;gt;=l)&#123;        return t[p].data;    &#125;    int mid=(t[p].l+t[p].r)&amp;gt;&amp;gt;1;    int ans=0;    if(l&amp;lt;=mid)ans|=ask(lt,l,r);    if(r&amp;gt;mid)ans|=ask(rt,l,r);    return ans;&#125; int main()&#123;    scanf(&amp;quot;%lld%lld&amp;quot;,&amp;amp;n,&amp;amp;m);    build(1,1,n);    for(int i=1;i&amp;lt;=n;i++)&#123;        int l=i,r=n;long long ans=0;        while(l&amp;lt;=r)&#123;            int mid=(l+r)&amp;gt;&amp;gt;1;            if(ask(1,i,mid)&amp;lt;m)&#123;                ans=mid-i;l=mid+1;            &#125;            else r=mid-1;        &#125;        cnt+=ans;    &#125;    cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day３】青春期猪头少年不会取＂膜＂</title>
    <link href="/2018/11/05/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay%EF%BC%93%E3%80%91%E9%9D%92%E6%98%A5%E6%9C%9F%E7%8C%AA%E5%A4%B4%E5%B0%91%E5%B9%B4%E4%B8%8D%E4%BC%9A%E5%8F%96%EF%BC%82%E8%86%9C%EF%BC%82/"/>
    <url>/2018/11/05/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay%EF%BC%93%E3%80%91%E9%9D%92%E6%98%A5%E6%9C%9F%E7%8C%AA%E5%A4%B4%E5%B0%91%E5%B9%B4%E4%B8%8D%E4%BC%9A%E5%8F%96%EF%BC%82%E8%86%9C%EF%BC%82/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-海龟"><a href="#T1-海龟" class="headerlink" title="T1 海龟"></a>T1 海龟</h1><blockquote><p>题目大意：给你ｎ个点，依次连接形成一条折线，问这条折线经过了多少个整点<del>真的不是刀剑里的那个海龟</del></p></blockquote><p>考试的时候写了两个程序，一个是枚举矩阵里的点带进函数，一个是枚举ｘ算出ｙ，后者写挂了，但是对拍的时候考试用的电脑没法用ｆｃ，人工对比耗费了不少时间而且还没对比出来，于是把两个程序混合起来只有６０分</p><p>想法很简单，每次枚举一条线段覆盖的最小矩阵的所有点，带进直线方程看看在不在直线上，用ｂｏｏｌ数组标记就好了．</p><p>正解好像是用ｇｃｄ模拟</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int x=0,y=0;int n;bool vis[1003][1003];int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        int now_x,now_y;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;now_x,&amp;amp;now_y);        vis[now_x][now_y]=1;        if(now_x==x&amp;amp;&amp;amp;now_y==y)continue;        int s_x,b_x,s_y,b_y;        s_x=min(x,now_x);b_x=max(x,now_x);        s_y=min(y,now_y);b_y=max(y,now_y);        if(now_x==x)&#123;            for(int j=s_y;j&amp;lt;=b_y;j++)&#123;                vis[x][j]=1;            &#125;        &#125;        else if(now_y==y)&#123;            for(int j=s_x;j&amp;lt;=b_x;j++)&#123;                vis[j][y]=1;            &#125;        &#125;        else if(n&amp;lt;=1000)&#123;            double k=abs(now_y-y)*1.0/abs(now_x-x)*1.0;            if((x&amp;lt;now_x&amp;amp;&amp;amp;y&amp;gt;now_y)||(now_x&amp;lt;x&amp;amp;&amp;amp;now_y&amp;gt;y))k=-k;            double b=y-k*x;            for(int j=s_x;j&amp;lt;=b_x;j++)&#123;                for(int z=s_y;z&amp;lt;=b_y;z++)&#123;                    if(fabs(z-k*j-b)&amp;lt;1e-5)&#123;                        vis[j][z]=1;                    &#125;                &#125;            &#125;        &#125;        x=now_x,y=now_y;    &#125;    int cnt=0;    for(int i=0;i&amp;lt;=1000;i++)&#123;        for(int j=0;j&amp;lt;=1000;j++)&#123;            if(vis[i][j]==1)&#123;                cnt++;                &#125;        &#125;    &#125;    cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre><h1 id="T2-子集"><a href="#T2-子集" class="headerlink" title="T2 子集"></a>T2 子集</h1><blockquote><p>题目大意：求有ｎ个元素的集合里有多少个元素数目不超过ｋ的子集数目，对ｍ取＂膜＂，不保证ｍ是质数</p></blockquote><p>骗我写一发逆元组合数，然而只过了暴力的分．．<br>前４０分是杨辉三角递推<br>后４０分是逆元（但是要有技巧的统计答案）<br>先上８０分代码：</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long  ll;const int MAXN=200005;int n,k;ll mod,ans;ll dat[MAXN],inv[MAXN],fac[MAXN],f[2003][2003];ll qpow(ll a,ll b)&#123;    ll ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=ans*a%mod;        a=a*a%mod;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;void prework()&#123;    for(int i=1;i&amp;lt;=2000;i++)f[i][0]=f[i][i]=1;    for(int i=2;i&amp;lt;=2000;i++)for(int j=1;j&amp;lt;=i;j++)f[i][j]=(f[i-1][j-1]+f[i-1][j])%mod;&#125;int main()&#123;    scanf(&amp;quot;%d%d%lld&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;mod);    if(n&amp;lt;=2000)&#123;        prework();        ans=1;        for(int i=1;i&amp;lt;=k;i++)ans=(ans+f[n][i])%mod;        printf(&amp;quot;%lld\n&amp;quot;,ans);    &#125;    else &#123;        ans=1;        fac[0]=dat[0]=1;        for(int i=1;i&amp;lt;=k;i++)&#123;            fac[i]=fac[i-1]*i%mod;            dat[i]=dat[i-1]*(n-i+1)%mod;            inv[i]=qpow(fac[i],mod-2);            ans=(ans+dat[i]*inv[i]%mod)%mod;        &#125;        printf(&amp;quot;%lld\n&amp;quot;,ans);    &#125;    return 0;&#125;</code></pre><p>我们首先来抽象化一下这道题到底要求什么，显然，其实它就是求一个式子：</p><center>[latex]\displaystyle \sum_{i\in[0,k]} C^i_n mod m[/latex]</center>我们之前用费马小定理为什么会失败呢？没错，就是ｍ不保证是质数！　　于是我们要用到费马小定理的一般情况的定理－<font size="68"><strong>欧拉定理</strong></font>对于一般的组合式公式我们可以进行以下化简:[latex]C_n^m=\frac{n!}{m!(n-m)!}=\frac{n(n-1)\cdots (n-m+1)}{m!}[/latex]由于我们要求的式子ｎ是不变的，所以分子每次可以用上次的分子递推（上面８０分的程序也用了这种方法）  而对于我们的正解，我们甚至用ａｎｓ来保存上一项的答案（可以直接用到当前项）对于每一个分子，我们将ｍｏｄ的质因子提取出来并计数（加法），剩下来的一定与ｍｏｄ互质，与ａｎｓ相乘．对于每一个分母，我们将ｍｏｄ的质因子提取出来并计数（减法），剩下来的一定与ｍｏｄ互质，与ａｎｓ相除（乘上逆元）．这里的逆元用的是欧拉定理，即[latex]a^{\varphi(n)}\equiv 1(mod\ n)[/latex]，其中ａ，ｎ互质我们不能直接将ａｎｓ统和计入答案，我们还必须讲每个用ａｎｓ乘上每个质因子才能计入答案统和<hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long  ll;const int MAXN=200005;int n,k;ll mod,ans=1;ll p[MAXN],c[MAXN],cnt;int phi;void divide(int n)&#123;    cnt=0;phi=n;    for(int i=2;i&amp;lt;=sqrt(n);i++)&#123;        if(n%i==0)&#123;            phi=phi/i*(i-1);            p[++cnt]=i;            while(n%i==0)n/=i;        &#125;    &#125;    if(n&amp;gt;1)&#123;phi=phi/n*(n-1);p[++cnt]=n;&#125;&#125;ll qpow(ll a,ll b)&#123;    ll ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=ans*a%mod;        a=a*a%mod;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;void cheng(int x) &#123;    for(int i=1;i&amp;lt;=cnt;i++) &#123;        while(x%p[i]==0) &#123;            c[i]++;            x/=p[i];        &#125;    &#125;    ans=1ll*ans*x%mod;&#125;void chu(int x) &#123;    for(int i=1;i&amp;lt;=cnt;i++) &#123;        while(x%p[i]==0) &#123;            c[i]--;            x/=p[i];        &#125;    &#125;    ans=1ll*ans*qpow(x,phi-1)%mod;&#125;int main()&#123;    scanf(&amp;quot;%d%d%lld&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;mod);    ll su=0;    divide(mod);    for(int i=0;i&amp;lt;=k;i++)&#123;//从0开始,因为有空集        if(i&amp;gt;=1)&#123;cheng(n-i+1);chu(i);&#125;        int t=ans;        for(int j=1;j&amp;lt;=cnt;j++)&#123;            t=1ll*t*qpow(p[j],c[j])%mod;        &#125;        su=(su+t)%mod;    &#125;    printf(&amp;quot;%lld\n&amp;quot;,su);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day2】骗分之旅</title>
    <link href="/2018/11/04/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay2%E3%80%91%E9%AA%97%E5%88%86%E4%B9%8B%E6%97%85/"/>
    <url>/2018/11/04/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay2%E3%80%91%E9%AA%97%E5%88%86%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-x"><a href="#T1-x" class="headerlink" title="T1 x"></a>T1 x</h1><p>今天唯一一道没有用骗分方法的题目,然而还是由于一个小细节写挂了orz</p><p>显然的是,如果两个数不互质,显然他们必须在一个集合里,于是我们可以将不互质的数连边,最后看有多少个联通块,答案就是[latex]2^{s}-2[/latex]其中s就是联通块的个数.如果用暴力的方法来实现的话,时间复杂度是[latex]O(n^2)[/latex]的.</p><p>我们可以只枚举每个数的质因子,来降低这一复杂度.</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=1e5+10,MAXA=1e6+10,mod=1e9+7;int prime[MAXA],p[MAXA],cnt,minp[MAXA],las[MAXA];vector&amp;lt;int&amp;gt;g[MAXN];bool v[MAXN];void prework()&#123;    for(int i=2;i&amp;lt;MAXA;i++)&#123;        if(!p[i])&#123;            prime[++cnt]=i;            minp[i]=i;        &#125;        for(int j=1;j&amp;lt;=cnt&amp;amp;&amp;amp;i*prime[j]&amp;lt;MAXA;j++)&#123;            p[i*prime[j]]=1;            minp[i*prime[j]]=prime[j];//考试的时候我这里写成了i            if(i%prime[j]==0)break;        &#125;    &#125;&#125;void dfs(int x)&#123;    v[x]=1;    for(int i=0;i&amp;lt;(int)g[x].size();i++)&#123;        if(v[g[x][i]])continue;        dfs(g[x][i]);    &#125;&#125;int main()&#123;    prework();    int t;scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);    while(t--)&#123;        int n;scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        memset(las,0,sizeof(las));        memset(v,0,sizeof(v));        for(int i=1;i&amp;lt;=n;i++)g[i].clear();        for(int i=1;i&amp;lt;=n;i++)&#123;            int x;scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);            while(x&amp;gt;1)&#123;                int fac=minp[x];                while(x%fac==0)x/=fac;                if(las[fac])&#123;                    g[las[fac]].push_back(i);                    g[i].push_back(las[fac]);                &#125;                las[fac]=i;            &#125;        &#125;        int ans=1;        for(int i=1;i&amp;lt;=n;i++)&#123;            if(!v[i])&#123;                ans=ans*2%mod;dfs(i);            &#125;        &#125;        printf(&amp;quot;%d\n&amp;quot;,(ans+mod-2)%mod);    &#125;    return 0;&#125;</code></pre><h1 id="T2-y"><a href="#T2-y" class="headerlink" title="T2 y"></a>T2 y</h1><p>考试的时候用的是dfs枚举,骗了30分,可以不枚举状态转而判断状态的存在性,可以骗到90分,然而还是过不了.</p><p>正解是动态规划,</p><blockquote><p>出题人说:f[i][j][mask] 表示从 i 出发，j 结束，是否存在一条表示为 mask 的路径。</p></blockquote><p>然而这样会T,得分甚至不如dfs,于是出题人又说</p><blockquote><p>meet in the middle，对于每种可能的路径，枚举中间的那个位置判断。时间复杂度为[latex]O(2^\frac{d}{2} \times n \times (n + m) + 2^d \times n)[/latex]</p></blockquote><p>用了bitset,先放个表格方便理解代码:</p><table><thead><tr><th align="center">变量名</th><th align="center">变量类型</th><th align="center">变量作用</th></tr></thead><tbody><tr><td align="center">g0[i]</td><td align="center">bitset</td><td align="center">表示i点与哪些节点连权值为0的边</td></tr><tr><td align="center">g1[i]</td><td align="center">bitset</td><td align="center">表示i点与哪些节点连权值为1的边</td></tr><tr><td align="center">dp[i]</td><td align="center">bitset</td><td align="center">表示i<strong>状态</strong>可以以哪些点为终点</td></tr><tr><td align="center">f[i]</td><td align="center">bitset</td><td align="center">表示i<strong>状态</strong>可以以哪些点为起点</td></tr></tbody></table><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int N=105;const int MAXN=2048;//2的20/2+1次方int n,m,d;bitset&amp;lt;N&amp;gt;g0[N],g1[N],dp[MAXN],f[MAXN];int main()&#123;    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;d);    for(int i=1,u,v,c;i&amp;lt;=m;i++)&#123;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;u,&amp;amp;v,&amp;amp;c);        if(c)&#123;g1[u][v]=g1[v][u]=1;&#125;        else &#123;g0[u][v]=g0[v][u]=1;&#125;    &#125;    int d2=d/2,d1=d-d2;    for(int u=n;u&amp;gt;=1;u--)&#123;//倒序枚举每一个点        for(int i=0;i&amp;lt;MAXN;i++)dp[i].reset();//清空        dp[1][u]=1;//以u为结尾状态是否存在，最开始的1是为了避免前导0         for(int x=1;x&amp;lt;(1&amp;lt;&amp;lt;d1);x++)&#123;//枚举状态            for(int y=1;y&amp;lt;=n;y++)&#123;//枚举点                if(dp[x][y])&#123;//如果当前状态可以以枚举的点为终点                    dp[x&amp;lt;&amp;lt;1]|=g0[y];//拓展出新的状态并且边权为0,用g0[y]去更新                    dp[x&amp;lt;&amp;lt;1|1]|=g1[y];//拓展出新的状态并且边权为1,用g1[y]去更新                &#125;            &#125;        &#125;        for(int x=0;x&amp;lt;(1&amp;lt;&amp;lt;d1);x++)&#123;//一个由u拓展的状态以任何一个结尾都说明以u开头的这个状态是存在的             f[x][u]=dp[1&amp;lt;&amp;lt;d1|x].any();//f数组是以u为开头的状态是否存在         &#125;    &#125;    int ans=0;    for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;d1);i++)&#123;        for(int j=0;j&amp;lt;(1&amp;lt;&amp;lt;d2);j++)&#123;//最后的dp数组状态都是由1为开头拓展而来的            if((dp[1&amp;lt;&amp;lt;d2|j]&amp;amp;f[i]).any())ans++;//有任意一个接上就可以累计答案         &#125;    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day1】黑红树</title>
    <link href="/2018/11/03/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay1%E3%80%91%E9%BB%91%E7%BA%A2%E6%A0%91/"/>
    <url>/2018/11/03/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay1%E3%80%91%E9%BB%91%E7%BA%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/zhber/p/4064897.html">题面</a></p></blockquote><blockquote><p><strong>题解转自<a href="http://www.cnblogs.com/zhber/p/4036010.html">zhber的这篇文章</a>,本人对部分公式做了LaTex处理,如需转载请注明原作者</strong></p></blockquote><p>zhb原创出品，改编自高一暑假数学作业必修三那章最后一题</p><p>这是这套题唯一会比较防ak的题了</p><p>首先题目我写了一大堆，就是要把你搞晕的</p><p>题意是有两个人进行游戏，其中第一个人在每局中获胜的概率是[latex]\frac{p}{q}[/latex]，如果有一个人比另一个人多赢两局，则游戏结束。现在给出T个询问，每个询问Q表示求游戏刚好在第Q轮结束的精确概率[latex]\frac{a}{b}[/latex]的a%k和b%k。要求[latex]\frac{a}{b}[/latex]是这个概率的最简分数。</p><p>解法是这样的：</p><p>我们把每两局压成一轮，只有三种可能：第一个人赢了，第二个人赢了，两人各赢一局。这样如果有人赢了游戏结束，平局时两人分数相同，相当于又开始一局</p><p>这样我们注意到一个显然的事实：游戏不可能在奇数局结束。因为由上面的推论+自己yy可知，要结束一定是在一轮以后，就是偶数局之后。这样不合法情况删掉一半了</p><p>第一个人一轮赢必须连赢两局，就是<a href="%5Cfrac%7Bp%7D%7Bq%7D">latex</a>^2[/latex]，即[latex]\frac{p^2}{q^2}[/latex]</p><p>第二个人一轮赢也是连赢两局，就是<a href="1-p/q">latex</a>^2[/latex]，通分完[latex]\frac{(p-q)^2}{q^2}[/latex]<br>那么一局能结束的概率就是上面两个加起来，即[latex]\frac{p^2+(p-q)^2}{q^2}[/latex]</p><p>一局不能结束的概率就是1-“上面那式子”</p><p>为简化条件，我们令一轮能结束的概率是A/B，一轮不能结束的概率是C/D。计算方法见上</p><p>那么对于有意义的询问，即偶数Q，令t=Q/2</p><p>那么比赛在第t轮即第Q局结束的充要条件是：在1到t-1轮两人都是平局，并且在第t轮比赛刚好结束</p><p>那么对于询问Q，<a href="%5Cfrac%7BC%7D%7BD%7D">latex</a>^{t-1} \times \frac{A}{B}[/latex] 即是所求</p><p>到这里应该都还能理解吧</p><p>然后比较难搞的是取模。因为p、q是100级别，那么[latex]p^2[/latex]、[latex]q^2[/latex]是1w级别，就是说ABCD这些数都是10000级别</p><p>要求的分数分子是[latex]C^{t-1}\times A[/latex]，分母是[latex]D^{t-1}\times B[/latex]，还要进行约分完取模。我们可以直接预处理使得A和B、C和D分别互质，但是我们没法保证A和D、B和C分别互质。这样约分就有困难了。比如A分解质因数有2^十几次方吧，D只有2^1，那么在接下来的十几次操作中都要用D的2去约掉A的2。但是ABCD的数据规模还算小，所以我们暴力搞出前20轮的答案，然后这样一来改约的也就约干净了，然后每次分子只乘C分母只乘D，又没有约分，可以直接递推。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;cstdio&amp;gt;#define MX 10000     //ABCD的规模是10000#define primeMX 1230     //10000以内1229个质数#define LL long longint prime[primeMX];struct fenjie&#123;    int rep[primeMX];&#125;aa,bb,cc,dd;int p,q,T,k,a,b,c,d;int ss[primeMX];     //用于暴力，分解质因数之后直接加/减在上面，如果是正的表示分子的分解质因数有ss[i]个prime[i]，反之分母亦然LL Q,last;LL ansa[1000010],ansb[1000010];     //保存第i局结束的概率的分子分母inline void shai()     //筛法&#123;    bool mrk[10010]=&#123;0&#125;;    int leng=0;    for (int i=2;i&amp;lt;=MX;i++)      if (!mrk[i])      &#123;        for (int j=2*i;j&amp;lt;=MX;j+=i)mrk[j]=1;        prime[++leng]=i;      &#125;&#125;inline int gcd(int a,int b)     //gcd用于A和B、C和D先约分&#123;if (!b)return a;else return gcd(b,a%b);&#125; inline void divide(fenjie &amp;amp;a,int b)     //分解质因数，用于前20轮暴力用&#123;    for (int i=1;i&amp;lt;primeMX;i++)      &#123;        if (b==1)break;        while (b%prime[i]==0)&#123;b/=prime[i];a.rep[i]++;&#125;      &#125;&#125;inline LL read()     //快速读入，100w的询问不加肯定TLE&#123;    LL x=0,f=1;char ch=getchar();    while(ch&amp;lt;&amp;#039;0&amp;#039;||ch&amp;gt;&amp;#039;9&amp;#039;)&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(ch&amp;gt;=&amp;#039;0&amp;#039;&amp;amp;&amp;amp;ch&amp;lt;=&amp;#039;9&amp;#039;)&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125;int main()&#123;    freopen(&amp;quot;mynameisczy.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);    freopen(&amp;quot;mynameisczy.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);    shai();    p=read();q=read();T=read();k=read();    if (p==1&amp;amp;&amp;amp;q==1||p==0&amp;amp;&amp;amp;q==0)ansa[2]=ansb[2]=1;  //如果必胜或必败，那一定在第2局就结束。其余概率都是0    else    &#123;        c=p*p+(q-p)*(q-p);        b=q*q;        a=b-c;        d=b;        //这里我AB和CD的意义反过来了        int div1=gcd(a,b);a/=div1;b/=div1;        int div2=gcd(c,d);c/=div2;d/=div2;        divide(aa,a);        divide(bb,b);        divide(cc,c);        divide(dd,d);        ansa[2]=c%k;ansb[2]=d%k;        for (int i=1;i&amp;lt;primeMX;i++)          ss[i]+=cc.rep[i]-dd.rep[i];        for(int i=4;i&amp;lt;=40;i+=2)        &#123;            long long sum1=1,sum2=1;            for (int j=1;j&amp;lt;primeMX;j++)              ss[j]+=aa.rep[j]-bb.rep[j];            for (int j=1;j&amp;lt;primeMX;j++)              if (ss[j]&amp;gt;0) for (int l=1;l&amp;lt;=ss[j];l++)sum1=(sum1*prime[j])%k;              else if (ss[j]&amp;lt;0)for (int l=1;l&amp;lt;=-ss[j];l++)sum2=(sum2*prime[j])%k;            ansa[i]=sum1;ansb[i]=sum2;        &#125;        for (int i=42;i&amp;lt;=1000000;i+=2)        &#123;            ansa[i]=(ansa[i-2]*a)%k;            ansb[i]=(ansb[i-2]*b)%k;        &#125;    &#125;    for(int i=1;i&amp;lt;=T;i++)      &#123;        Q=read()-last;     //last是处理加密的问题        last=ansa[Q];        printf(&amp;quot;%I64d %I64d\n&amp;quot;,ansa[Q],ansb[Q]);      &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【考前冲刺Day1】天神下凡</title>
    <link href="/2018/11/03/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay1%E3%80%91%E5%A4%A9%E7%A5%9E%E4%B8%8B%E5%87%A1/"/>
    <url>/2018/11/03/%E3%80%90%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BADay1%E3%80%91%E5%A4%A9%E7%A5%9E%E4%B8%8B%E5%87%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/zhber/p/4064922.html">题面</a></p></blockquote><p>我们先来看看样例：<br><img src="http://bubbleioa.top/wp-content/uploads/2018/11/god.jpg"><br>首先一开始就有一个区域；<br>一般来说，一个圆对答案的贡献为1，无论它是在外面还是在其他圆的里面。<br>但是，如果一个圆它的一条直径上所有的点都被覆盖了的话，它对答案的贡献就为2了<br>由于只能在x轴上安放，覆盖的情况我们也只要考虑x轴上的，所以就可以把这个问题抽象为一个线段覆盖问题。<br>首先将所有的线段离散化一下，再根据长度排序，对于每条线段，先查询它是不是被全部覆盖了，再用它来更新覆盖的区域，可以用线段树来维护。  </p><p>考试的时候思路完全一致，就是线段树空间没有开够<strong>一定要开八倍空间！！！！</strong>，建树的时候也要<strong>从1到2*n</strong></p><p>这种想法虽然很自然，但是代码又长，空间又大，时间又长，还容易写挂，先膜一波考试时A的大佬@<a href="https://www.luogu.org/space/show?uid=89044">Enstein</a>用的是神奇的栈，@<a href="https://www.luogu.org/space/show?uid=92125">千柰</a>用的是搜索……代码比我短，空间比我小，还更快，tql</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt; #define lt p&amp;lt;&amp;lt;1#define rt p&amp;lt;&amp;lt;1|1using namespace std;const int MAXN =300005;struct seg&#123;    int l,r;    int len;&#125;s[MAXN];int n,cnt,ans=1;struct node&#123;    int pos,id;&#125;point[MAXN&amp;lt;&amp;lt;1]; struct segtree&#123;    int l,r;    int data,tag;&#125;t[MAXN&amp;lt;&amp;lt;3];//8倍空间！！！ bool cmp(node a,node b)&#123;    return a.pos&amp;lt;b.pos;&#125; bool cmp2(node a,node b)&#123;    if(a.id==b.id)return a.pos&amp;lt;b.pos;    return a.id&amp;lt;b.id;&#125; bool cmp3(seg a,seg b)&#123;    if(a.len==b.len)return a.l&amp;lt;b.l;    return a.len&amp;lt;b.len;&#125; void build(int p,int l,int r)&#123;    t[p].l=l,t[p].r=r;    if(l==r)&#123;        return;    &#125;    int mid=(l+r)&amp;gt;&amp;gt;1;    build(lt,l,mid);    build(rt,mid+1,r);&#125; void spread(int p)&#123;//加了并不会快多少    if(t[p].tag)&#123;        t[lt].data=t[lt].r-t[lt].l+1;        t[rt].data=t[rt].r-t[rt].l+1;        t[lt].tag=1;        t[rt].tag=1;        t[p].tag=0;    &#125;&#125; void change(int p,int l,int r)&#123;    if(t[p].l&amp;gt;=l&amp;amp;&amp;amp;t[p].r&amp;lt;=r)&#123;        t[p].data=t[p].r-t[p].l+1;        t[p].tag=1;        return;    &#125;    spread(p);    int mid=(t[p].l+t[p].r)&amp;gt;&amp;gt;1;    if(mid&amp;gt;=l)change(lt,l,r);    if(mid&amp;lt;r)change(rt,l,r);    t[p].data=t[lt].data+t[rt].data;&#125; int ask(int p,int l,int r)&#123;    if(t[p].l&amp;gt;=l&amp;amp;&amp;amp;t[p].r&amp;lt;=r)&#123;        return t[p].data;    &#125;    spread(p);    int mid=(t[p].l+t[p].r)&amp;gt;&amp;gt;1;    int sum=0;    if(mid&amp;gt;=l)sum+=ask(lt,l,r);    if(mid&amp;lt;r)sum+=ask(rt,l,r);    return sum;&#125; int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        int x,r;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;r);        point[++cnt].pos=x-r;point[cnt].id=cnt;        point[++cnt].pos=x+r;point[cnt].id=cnt;    &#125;    sort(point+1,point+1+cnt,cmp);    for(int i=1,j=1,last=-1;i&amp;lt;=cnt;i++)&#123;        if(i!=1&amp;amp;&amp;amp;point[i].pos!=last)j++;        last=point[i].pos;        point[i].pos=j;    &#125;    sort(point+1,point+1+cnt,cmp2);    cnt=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        s[i].l=point[++cnt].pos;        s[i].r=point[++cnt].pos;        s[i].len=s[i].r-s[i].l+1;    &#125;    sort(s+1,s+1+n,cmp3);    build(1,1,n*2); //从1到2n    for(int i=1;i&amp;lt;=n;i++)&#123;        ans++;        if(ask(1,s[i].l,s[i].r)==s[i].len)ans++;        change(1,s[i].l,s[i].r);    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11.2 DP专题——和DP打成一片题解</title>
    <link href="/2018/11/02/11.2%20DP%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%92%8CDP%E6%89%93%E6%88%90%E4%B8%80%E7%89%87%E9%A2%98%E8%A7%A3/"/>
    <url>/2018/11/02/11.2%20DP%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E5%92%8CDP%E6%89%93%E6%88%90%E4%B8%80%E7%89%87%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-求三角形的最大面积"><a href="#T1-求三角形的最大面积" class="headerlink" title="T1 求三角形的最大面积"></a>T1 求三角形的最大面积</h1><blockquote><p>题目大意：给你一个由多个三角形组成的大三角形，其中有些三角形缺失了，求出剩下部分最大的三角形。</p></blockquote><p>毒瘤题，dp很好想，被特殊情况坑了。<br>首先上三角和下三角都要算一遍（其实就是反过来再找一遍）<br>就拿上三角来说，我们很容易就知道它的高度就是min(左，右)+1，但是实际上还要考虑一些特殊情况</p><p>比如下面这种情况：<br><img src="http://bubbleioa.top/wp-content/uploads/2018/11/%E4%B8%89%E8%A7%92%E5%BD%A2.png"><br>输入的时候是这样的</p><pre><code>3#---# #-#  #0</code></pre><p>所以在更新f[i][j]的时候要注意判断j的奇偶性就行了  </p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n;int tri[300][300];//发现这东西是多余的int f1[300][300],f2[300][300];//下三角和上三角int main()&#123;    while(233)&#123;        memset(tri,0,sizeof(0));        memset(f1,0,sizeof(f1));        memset(f2,0,sizeof(0));        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        if(n==0)break;        for(int i=1;i&amp;lt;=n;i++)&#123;            char str[400];            scanf(&amp;quot;%s&amp;quot;,str+1);int len=strlen(str+1);            for(int j=1;j&amp;lt;=len;j++)&#123;                tri[i][j+i-1]=(str[j]==&amp;#039;-&amp;#039;?1:0);                f1[i][j+i-1]=f2[i][j+i-1]=tri[i][j+i-1];//可以放就初始化为1            &#125;        &#125;        for(int i=2;i&amp;lt;=n;i++)&#123;            int cnt=1;            for(int j=i;j&amp;lt;=2*n-i;j++,cnt++)&#123;                if(f1[i][j]==0||cnt%2==0)continue;//偶数不能更新                f1[i][j]=f1[i][j]+min(f1[i-1][j+1],min(f1[i-1][j]==0?0:0x3f3f3f3f,f1[i-1][j-1]));//虽然讨论了左右的情况，但是中间不能为不能放的格子            &#125;        &#125;        for(int i=n-1;i&amp;gt;=1;i--)&#123;            for(int j=i;j&amp;lt;=2*n-i;j++)&#123;                if(f2[i][j]==0)continue;                f2[i][j]=f2[i][j]+min(f2[i+1][j+1],min(f2[i+1][j],f2[i+1][j-1]));            &#125;        &#125;        int ans=0;        for(int i=1;i&amp;lt;=n;i++)&#123;            for(int j=i;j&amp;lt;=2*n-1;j++)&#123;                ans=max(ans,max(f1[i][j],f2[i][j]));            &#125;        &#125;        cout&amp;lt;&amp;lt;ans*ans&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre><h1 id="T2-下楼问题"><a href="#T2-下楼问题" class="headerlink" title="T2 下楼问题"></a>T2 下楼问题</h1><blockquote><p>题目大意：有一个n层楼的建筑，现在有一只猫在楼顶，每层楼有三个门，现给出距离，求猫到1楼的最长距离（不能上楼也不走回头路）</p></blockquote><p>由于每层楼之间是独立的，而且下了楼就不能往上，所以每层楼的状态具有无后效性，即我们不必关心当前状态是怎么来的。<br>我们考虑如何更新当前状态<br><img src="http://bubbleioa.top/wp-content/uploads/2018/11/down-e1541140786226.png"><br>假设我们要更新4这个点，我们发现其余5个点都有到它的合法路径，如果我们用5更新4的话，会发现5状态也会需要4来更新，<strong>我更新我自己</strong>是不可以的。<br>于是我们可以只考虑上一层的来更新下一层的  </p><p>先解释下变量吧，我觉得还是比较形象的  </p><table><thead><tr><th align="center">变量名</th><th align="center">变量含义</th></tr></thead><tbody><tr><td align="center">_path[i]</td><td align="center">第i层楼左边的路径长度</td></tr><tr><td align="center">path_[i]</td><td align="center">第i层楼右边的路径长度</td></tr><tr><td align="center">down[i]</td><td align="center">第i层楼中间门往下的路径长度</td></tr><tr><td align="center">down_[i]</td><td align="center">第i层楼左边门往右下的路径长度</td></tr><tr><td align="center">_down[i]</td><td align="center">第i层楼右边门往左下的路径长度</td></tr><tr><td align="center">f[i][j]</td><td align="center">走到第i层楼第j扇门的最长路</td></tr></tbody></table><p>于是状态可以这样更新：<br>[latex]f[i][2]=max(f[i+1][2]+down[i+1],max(f[i+1][1]+down_[i+1]+path_[i],f[i+1][3]+_down[i+1]+_path[i]))[/latex]<br>[latex]f[i][1]=max(f[i+1][3]+_down[i+1],max(f[i+1][1]+down_[i+1]+_path[i]+path_[i],f[i+1][2]+down[i+1]+_path[i]))[/latex]<br>[latex]f[i][3]=max(f[i+1][1]+down_[i+1],max(f[i+1][3]+_down[i+1]+_path[i]+path_[i],f[i+1][2]+down[i+1]+path_[i]))[/latex]</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=500003;int f[MAXN][4];//1-left 2-middle 3-rightint _path[MAXN],path_[MAXN];int down[MAXN],down_[MAXN],_down[MAXN];int n; int main()&#123;    // freopen(&amp;quot;test.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);    int t,T;scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);T=t;    while(t--)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        for(int i=1;i&amp;lt;=n;i++)&#123;            scanf(&amp;quot;%d%d%d%d%d&amp;quot;,&amp;amp;_path[i],&amp;amp;path_[i],&amp;amp;down_[i],&amp;amp;down[i],&amp;amp;_down[i]);        &#125;        f[n][2]=_path[n];f[n][1]=0;f[n][3]=path_[n]+_path[n];        for(int i=n-1;i&amp;gt;=1;i--)&#123;            f[i][2]=max(f[i+1][2]+down[i+1],max(f[i+1][1]+down_[i+1]+path_[i],f[i+1][3]+_down[i+1]+_path[i]));            f[i][1]=max(f[i+1][3]+_down[i+1],max(f[i+1][1]+down_[i+1]+_path[i]+path_[i],f[i+1][2]+down[i+1]+_path[i]));            f[i][3]=max(f[i+1][1]+down_[i+1],max(f[i+1][3]+_down[i+1]+_path[i]+path_[i],f[i+1][2]+down[i+1]+path_[i]));        &#125;        int ans=max(f[1][1],max(f[1][3],f[1][2]));        printf(&amp;quot;Case %d: &amp;quot;,T-t);        cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre><h1 id="T3-瞬移"><a href="#T3-瞬移" class="headerlink" title="T3 瞬移"></a>T3 瞬移</h1><blockquote><p>题目大意:有两个人在一个0-1矩阵上进行移动，其中是不可走的位置。他们每次只能从当前行移动到下一行，而且两个人的位置x,y必须满足限制：[latex]x+m_i\le y\le x+m_a[/latex] . 一个人移动到下一行的代价为其横坐标变化值的绝对值。问两个人都到达底端需要的最小消耗.</p></blockquote><p>做惯了大数据的题目,做一些比较小的数据的题目都不敢大胆去想了,这题目n只有1000而m只有10,对于师傅和徒弟两个人,我们可以五重循环分别枚举<strong>层数 当前徒弟位置 当前师傅位置 上一层徒弟位置 上一层师傅位置</strong> 这样的时间复杂度达到了惊人的[latex]O(NM^4)[/latex]然而由于数据范围较小,所以并不会超时.</p><p>我们可以用f[dep][i][j]表示dep层师傅在i徒弟在j时所需要耗费的最小值,枚举上一层的状态即可更新.</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,m,l,r,x,y;int ma[1003][12];int f[1003][13][13];int main()&#123;    int t;scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);    while(t--)&#123;        memset(f,0x3f,sizeof(f));        scanf(&amp;quot;%d%d%d%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;l,&amp;amp;r,&amp;amp;x,&amp;amp;y);        x++,y++;        for(int i=1;i&amp;lt;=n;i++)&#123;            char tmp[20];            scanf(&amp;quot;%s&amp;quot;,tmp+1);            for(int j=1;j&amp;lt;=m;j++)if(tmp[j]==&amp;#039;*&amp;#039;)ma[i][j]=1;else ma[i][j]=0;        &#125;        for(int i=1;i&amp;lt;=m;i++)ma[1][i]=0;//第一层就把师傅徒弟的初始位置标记为合法,其他为不合法        ma[1][x]=ma[1][y]=1;        f[1][x][y]=0;        for(int dep=2;dep&amp;lt;=n;dep++)&#123;//层数            for(int j=2;j&amp;lt;=m;j++)&#123;//徒弟                if(!ma[dep][j])continue;                for(int i=1;i&amp;lt;j;i++)&#123;//师傅                     if((!ma[dep][i])||j&amp;lt;i+l||j&amp;gt;i+r)continue;                    for(int k=2;k&amp;lt;=m;k++)&#123;//上层徒弟                        if(!ma[dep-1][k])continue;                        for(int z=1;z&amp;lt;k;z++)&#123;//上层师傅                            if((!ma[dep-1][z])||k&amp;lt;z+l||k&amp;gt;z+r)continue;                            f[dep][i][j]=min(f[dep][i][j],f[dep-1][z][k]+abs(z-i)+abs(k-j));                        &#125;                    &#125;                &#125;            &#125;        &#125;        int mi=1&amp;lt;&amp;lt;30;        for(int i=2;i&amp;lt;=m;i++)&#123;            if(!ma[n][i])continue;            for(int j=1;j&amp;lt;i;j++)&#123;                if((!ma[n][j])||i&amp;lt;j+l||i&amp;gt;j+r)continue;                mi=min(mi,f[n][j][i]);            &#125;        &#125;        cout&amp;lt;&amp;lt;mi&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre><h1 id="T4-数字游戏"><a href="#T4-数字游戏" class="headerlink" title="T4 数字游戏"></a>T4 数字游戏</h1><blockquote><p>题目大意：给你n个数，每个数有一个衰减值，m个回合，每个回合你可以选一个数（选完消失并计入答案），选完后剩余的数衰减。求能选到的最大的总和是多少。</p></blockquote><p>可以比较容易地发现一个结论：如果n=m，就是所有数都会被选到的话，要根据bi的大小来选，先去掉那些每回合损耗多的，再去掉损耗少的，这样显然就是最优的。<br>但如果m&lt;n呢？设想：假如己经选定了m个数，只去掉这m个数，那么与m=n的情况一样，我们一定是按照bi的大小来去掉的。因为显然对于选定的个数，这样做最优。<br>到这里，我们就会想到采用动态规划的方法。把n个数按照bi从大到小排序，然后问题就转化为对于一个n个数的序列，从中选择m个数，第i个选择的数权值为A-B*i，(A,B分别为此数在原来a,b数组里对应的值)，使得所有权值的和最大。<br>不难写出下面的动态规划状态转移方程：</p><p>$$f(i,j)=max(f(k,j-1)+a_i-b_i \times(j-1)$$<br>$$f(0,0)=0$$</p><p>其中，$$1\le i\le n ,1\le j\le m,0\le k&lt;j$$，ai,bi为排序后第i个数相应的值。这样的复杂度是$$O(n^3)$$</p><p>再进一步分析，很容易地把上述动态規划方程改变为下面的形式：<br>令F(i,j)前i个数当中取了j个数的最优解，则</p><p>$$F(i,j)=max(F(i-1,j),F(i-1,j-1)+a_i-b_i\times(j-1)$$<br>$$F(0,0)=0$$</p><p>这样，时间复杂度就降到了$$O(n^2)$$</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,m;struct node&#123;    int a,b;&#125;num[203];int f[203][203];bool cmp(node a,node b)&#123;    return a.b&amp;gt;b.b;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;num[i].a);    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;num[i].b);    sort(num+1,num+1+n,cmp);    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=m;j++)&#123;            f[i][j]=max(f[i][j],max(f[i-1][j],f[i-1][j-1]+num[i].a-num[i].b*(j-1)));        &#125;    &#125;    cout&amp;lt;&amp;lt;f[n][m]&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11.1不能与DP好好相处题解</title>
    <link href="/2018/11/01/11.1%E4%B8%8D%E8%83%BD%E4%B8%8EDP%E5%A5%BD%E5%A5%BD%E7%9B%B8%E5%A4%84%E9%A2%98%E8%A7%A3/"/>
    <url>/2018/11/01/11.1%E4%B8%8D%E8%83%BD%E4%B8%8EDP%E5%A5%BD%E5%A5%BD%E7%9B%B8%E5%A4%84%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="T1-不老的传说"><a href="#T1-不老的传说" class="headerlink" title="T1 不老的传说"></a>T1 不老的传说</h1><blockquote><p>题目大意：有n个石头环成一圈，每次染色能染1-k个连续石头，问多最少多少次能染成目标状态</p></blockquote><p>这道题真的是各种既视感，环的话直接变成两倍的链就OK了，之后就是区间dp<br>[latex]f[i][j][/latex]表示(i,j)对i,j一段染色的最少次数</p><p>初始化就是[latex]f[i][j]=\begin{cases}1&amp;i=j\ 0&amp;i&gt;j\ \infty&amp;else\end{cases}[/latex]</p><p>状态转移方程也很有既视感：[latex]f[i][j]=\begin{cases}min(f[i+1][j],f[i][j-1])&amp;c[i]=c[j]\min(f[i][z]+f[z+1][j]),z\in [i,j)&amp;else\end{cases}[/latex]</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int c[402];int f[402][402];int n,m,k; int main()&#123;    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);    memset(f,0x3f,sizeof(f));    for(int i=1;i&amp;lt;=n;i++)&#123;scanf(&amp;quot;%d&amp;quot;,&amp;amp;c[i]);c[i+n]=c[i];&#125;    for(int i=1;i&amp;lt;=n*2;i++)&#123;        for(int j=1;j&amp;lt;=n*2;j++)&#123;            if(i==j)f[i][j]=1;            if(i&amp;gt;j)f[i][j]=0;        &#125;    &#125;    for(int len=2;len&amp;lt;=n;len++)&#123;        for(int i=1;i+len-1&amp;lt;=n*2;i++)&#123;            int j=i+len-1;            if(c[i]==c[j]&amp;amp;&amp;amp;len&amp;lt;=k)f[i][j]=min(f[i+1][j],f[i][j-1]);            else &#123;                for(int z=i;z&amp;lt;j;z++)&#123;                    f[i][j]=min(f[i][z]+f[z+1][j],f[i][j]);                &#125;            &#125;        &#125;    &#125;    int mi=1&amp;lt;&amp;lt;30;    for(int i=1;i&amp;lt;=n;i++)&#123;        mi=min(mi,f[i][i+n-1]);    &#125;    cout&amp;lt;&amp;lt;mi&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre><h1 id="T2-多米诺骨牌"><a href="#T2-多米诺骨牌" class="headerlink" title="T2 多米诺骨牌"></a>T2 多米诺骨牌</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1282">题目地址</a></p></blockquote><p>题目要求的是上下翻转次数，首先要解决的是如何使得差值最小。很容易就这样想到，因为n块骨牌都可以任意翻转，那么肯定有一种摆放的方式顶行和底行之间的差值是最小的，找到这样的摆放方式就可以通过对比找到最小的翻转次数了,但是这样一个问题也不容易解决，因为总共有2n种摆放方式，不可能用计算机逐一检验对比。而且差值最小的摆放方式也不惟一，因此这样的方法是不可行的。</p><p>这个问题只能换一种方式来解决了。我们可以尝试一下动态规划的思想。之所以往这个方向去思考是因为我们发现，上面的方法行不通的主要原因是因为骨牌之间相互独立的，这个性质导致了摆放方式有很多，但是相互独立这个很重要的性质，如果能够加以利用，也许会为问题的解决带来很大的便利。</p><p>经过分析可以发現，如果做到了用最少的翻转次数达到差值是最小的摆放方式，此时任意一段骨牌都不可能用更少的方式得到同样的上下差值。更具体地说，前k块骨牌如果要达到某个差值（不一定最小），它将取决于前1块的翻转情况和第k块的翻转情况。如果确定了第k块的状态，那么前k-1块就必须要用最少的次数得到指定的差值了。据此，可以列出下面的递推公式：<br>假设gap[i][j]表示前i块骨牌要达到差值为j，需要的最少翻转次数。如果不能达到j的差值，那么令等于一个很大的数。</p><center>[latex]gap[i][j]=\begin{cases}min(gap[i-1][j-c[i]],gap[i-1][j+c[i]]+1),i\in [1,n] \\ \infty & else\end{cases}[/latex]</center>其中c[i]为第i个骨牌上面-下面的值<p>初始条件是：</p><center>[latex]\begin{cases}g[0][0]=0\\g[0][j]=\infty\end{cases}[/latex]</center>由于最多只有1000个骨牌，所以上下骨牌点数差值的总和的绝对值最大就是5000。所以，我们可以逐个骨牌来处理，把所有可以达到的值都计算出来，并记下是用了多少步而达到的，最后找出可以达到的最小值，并直接得到需要多少步达到。这样可以在规定时间内求得答案。<p>由于上下的差值在[latex][-5000,5000][/latex]之间，所以我们gap的第二维要开两倍空间，再往右偏移一倍空间</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int gap[1003][12012];int c[1003];int n;int main()&#123;    cin&amp;gt;&amp;gt;n;    for(int i=1;i&amp;lt;=n;i++)&#123;        int a,b;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);        c[i]=a-b;    &#125;    memset(gap,0x3f,sizeof(gap));    gap[0][6005]=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=0;j&amp;lt;12100;j++)&#123;            if(j-(c[i])&amp;gt;=0 &amp;amp;&amp;amp; j-(c[i])&amp;lt;12100) gap[i][j]=min(gap[i][j], gap[i-1][j+c[i]]);//虽然我们上面把它们写到了一起，            if(j+c[i]&amp;gt;=0 &amp;amp;&amp;amp; j+c[i]&amp;lt;12100) gap[i][j]=min(gap[i][j], gap[i-1][j-c[i]]+1);//但实际上它们两个更新的条件是不一样的，所以要分开来写        &#125;    &#125;    int minn=0x3f3f3f3f,ans=0x3f3f3f3f;    for(int i=0;i&amp;lt;12100;i++) &#123;        if(gap[n][i]!=0x3f3f3f3f) &#123;            if(abs(i-6005)&amp;lt;minn) minn=abs(i-6005), ans=gap[n][i];            else if(abs(i-6005)==minn) ans=min(ans, gap[n][i]);        &#125;    &#125;    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre><h1 id="T3-文本压缩"><a href="#T3-文本压缩" class="headerlink" title="T3 文本压缩"></a>T3 文本压缩</h1><blockquote><p>题目大意：给你一个字符串和若干编码方式，输出编码后的最小长度</p></blockquote><p>题目中的编码有个特点，就是无后效性，如abcdefgh前面的abcd如何编码跟后面的编码方法无关。<br>设函数[latex]F(s)[/latex]表示文本s的压缩方式的编码长度，如题目例子：<br>[latex]F(a)=length(“01”)=2[/latex]  </p><hr><p>[latex]F(abc)=length(“0”)=1[/latex]  </p><hr><p>[latex]F(abcd)=4[/latex]  </p><hr><p>[latex]F(bcd)=1[/latex]  </p><hr><p>[latex]F(def)=2[/latex]  </p><hr><p>[latex]F(ef)=2[/latex]  </p><hr><p>设函数[latex]G(s)[/latex]表示文本s的最短编码长度，有<br>[latex]G(a)=2[/latex]  </p><hr><p>[latex]G(ab)=max[/latex]  </p><hr><p>[latex]G(abc)=1[/latex]  </p><hr><p>[latex]G(abcd)=4[/latex]  </p><hr><p>[latex]G(abcde)=max[/latex]  </p><hr><p>max表示不能编码<br>求[latex]G(abcdef)[/latex]时，考虑其最后一个编码可能是def或ef，即abcdef=abc+def或abcd+ef</p><p>转移方程为：<br>[latex]G(s)=min(G(s_{11})+F(s_{12}),G(s_{21})+F(s_{22}),\cdots ,G(s_{n1})+F(s_{n2}))[/latex]</p><p>其中[latex]s=s_{i1}+s_{i2},i\in[1,n][/latex]</p><p>@<a href="https://www.luogu.org/space/show?uid=92125">千柰</a>dalao只开了1维数组，代码也比我的简洁</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;string s;string v[502];//好像没什么用，根本不用开数组map&amp;lt;string,int&amp;gt;len;//就是上面的f数组int f[503][503];int get(int l,int r)&#123;    string tmp;    for(int i=l;i&amp;lt;=r;i++)&#123;        tmp+=s[i];    &#125;    if(len[tmp])&#123;return len[tmp];&#125;    else return 0x3f3f3f3f;&#125;int main()&#123;    int t;cin&amp;gt;&amp;gt;t;    while(t--)&#123;        s.clear();len.clear();        memset(f,0x3f,sizeof(f));        int tot=0;        cin&amp;gt;&amp;gt;s;scanf(&amp;quot;\n&amp;quot;);        while(cin.peek()==&amp;#039;(&amp;#039;)&#123;//毒瘤读入，不要学我            cin&amp;gt;&amp;gt;v[++tot];int p=1,cnt=0;            string tmp2;            while(v[tot][p]!=&amp;#039;,&amp;#039;)tmp2+=v[tot][p++];            p++;            while(v[tot][p]!=&amp;#039;)&amp;#039;)&#123;cnt++;v[tot][p++];&#125;            len[tmp2]=cnt;            if(cin.peek()==EOF)break;            scanf(&amp;quot;\n&amp;quot;);        &#125;        for(int i=0;i&amp;lt;s.length();i++)&#123;//先处理出给出了编码的            for(int j=i;j&amp;lt;s.length();j++)&#123;                f[i][j]=get(i,j);            &#125;        &#125;        for(int l=2;l&amp;lt;=s.length();l++)&#123;//区间dp            for(int i=0;i+l-1&amp;lt;s.length();i++)&#123;                int j=i+l-1;                for(int k=i;k&amp;lt;j;k++)&#123;                    f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);                &#125;            &#125;        &#125;        if(f[0][s.length()-1]==0x3f3f3f3f)printf(&amp;quot;0\n&amp;quot;);        else printf(&amp;quot;%d\n&amp;quot;,f[0][s.length()-1]);    &#125;    return 0;&#125;</code></pre><h1 id="T4-瑞士轮"><a href="#T4-瑞士轮" class="headerlink" title="T4 瑞士轮"></a>T4 瑞士轮</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1309">题目地址</a></p></blockquote><p>dp专题出现排序算法真的是<del>一点也不</del>意外呢，当时还在努力想怎么dp，还好最后打了个暴力，没有被坑惨。<br>先上一个暴力：  </p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,r,q;struct per&#123;    int s,w,id;&#125;p[200003]; bool cmp(per a,per b)&#123;    if(a.s==b.s)return a.id&amp;lt;b.id;    return a.s&amp;gt;b.s;&#125; int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;r&amp;gt;&amp;gt;q;    for(int i=1;i&amp;lt;=(n&amp;lt;&amp;lt;1);i++)&#123;scanf(&amp;quot;%d&amp;quot;,&amp;amp;p[i].s);p[i].id=i;&#125;    for(int i=1;i&amp;lt;=(n&amp;lt;&amp;lt;1);i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;p[i].w);    sort(p+1,p+1+(n&amp;lt;&amp;lt;1),cmp);    while(r--)&#123;        for(int i=1;i&amp;lt;=(n&amp;lt;&amp;lt;1);i+=2)&#123;            if(p[i].w&amp;gt;p[i+1].w)p[i].s++;            if(p[i].w&amp;lt;p[i+1].w)p[i+1].s++;        &#125;        sort(p+1,p+1+(n&amp;lt;&amp;lt;1),cmp);    &#125;    cout&amp;lt;&amp;lt;p[q].id;    return 0;&#125;</code></pre><p>STL受害者，用快排时间复杂度极高[latex]O(R(NlogN+N))[/latex]<br>快排的快是针对随机数列来讲的（大部分情况下是这样），而这道题不同，每一轮过后，所有的胜利者的顺序不会变，所有的失败者的顺序也不会变，所以这个时候就要用归并排序了！！</p><p>归并排序和快排的区别（懒得打字了你们自己看图片吧）<br><img src="http://bubbleioa.top/wp-content/uploads/2018/11/mergesort.gif"><br>归并排序<br><img src="http://bubbleioa.top/wp-content/uploads/2018/11/quicksort.gif"><br>快排   </p><p>看出来了吧，大家可以发现，归并排序每次的操作只针对相邻区间，或者说合并时是对相邻几个区间的操作，所以这符合只需要修改相邻几个分数的排布状况的题意。  </p><p>然后就过了……<br>所以以后就算我用插入排序，用冒泡排序，我也不会用快排！！  </p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN=200003;int n,r,q;int id[MAXN],win[MAXN],lose[MAXN];int s[MAXN],w[MAXN];bool cmp(int a,int b)&#123;    if(s[a]==s[b])return a&amp;lt;b;    return s[a]&amp;gt;s[b];&#125;void Merge()&#123;    int i,j;        i=j=1,id[0]=0;        while(i&amp;lt;=win[0] &amp;amp;&amp;amp; j&amp;lt;=lose[0])          if(cmp(win[i],lose[j]))                id[++id[0]]=win[i++];          else                 id[++id[0]]=lose[j++];        while(i&amp;lt;=win[0])id[++id[0]]=win[i++];        while(j&amp;lt;=lose[0])id[++id[0]]=lose[j++];          &#125;  int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;r&amp;gt;&amp;gt;q;n*=2;    for(int i=1;i&amp;lt;=n;i++)id[i]=i;    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i]);    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;w[i]);    sort(id+1,id+1+n,cmp);//真香    while(r--)&#123;        win[0]=lose[0]=0;        for(int i=1;i&amp;lt;=n;i+=2)&#123;            if(w[id[i]]&amp;gt;w[id[i+1]])&#123;                s[id[i]]++;                  win[++win[0]]=id[i];                  lose[++lose[0]]=id[i+1];              &#125;            else &#123;                s[id[i+1]]++;                win[++win[0]]=id[i+1];                lose[++lose[0]]=id[i];            &#125;        &#125;        Merge();    &#125;    cout&amp;lt;&amp;lt;id[q];    return 0;&#125;</code></pre><h1 id="T5-传球游戏"><a href="#T5-传球游戏" class="headerlink" title="T5 传球游戏"></a>T5 传球游戏</h1><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1057">题目地址</a></p></blockquote><p>其实这应该算是昨天的题目，在后面来一道水题</p><hr><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,m,f[31][31];int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    memset(f,0,sizeof(f));    f[1][0]=1;    for(int k=1;k&amp;lt;=m;k++)&#123;        f[1][k]=f[2][k-1]+f[n][k-1];        for(int i=2;i&amp;lt;=n;i++)f[i][k]=f[i-1][k-1]+f[i+1][k-1];        f[n][k]=f[n-1][k-1]+f[1][k-1];    &#125;    cout&amp;lt;&amp;lt;f[1][m]&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[hdu5207]Greatest Greatest Common Divisor</title>
    <link href="/2018/11/01/%5Bhdu5207%5DGreatest%20Greatest%20Common%20Divisor/"/>
    <url>/2018/11/01/%5Bhdu5207%5DGreatest%20Greatest%20Common%20Divisor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目大意：给你n个数，从里面选2个，使得它们的最大公约数最大，输出这个最大公约数</p></blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5207">题目链接</a></p><p>原本前一天在想一个相似的题目，但是是选k个，所以数据范围变小了，还是能用选k个的想法做。<br>思路很简单，首先由于这n个数不超过1e5，所以可以开个桶来存出现次数。<br>然后再从其中最大的数倒序枚举每一个自然数，再枚举自然数的倍数，如果这个自然数的倍数在桶里面出现不少于2次，这个自然数就是答案。</p><p>代码用了fread快读，所以目前在hdu这份代码是<a href="http://acm.hdu.edu.cn/statistic.php?pid=5207">rank1</a> (78ms中提交时间最早的那一个)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int maxa;int a[100005];int n,k;inline char nc()&#123;    static char buf[100005],*p1=buf,*p2=buf;    return p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100005,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123;    int num=0;char ch=&amp;#039;a&amp;#039;;int f=1;    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=nc();&#125;    while(isdigit(ch))&#123;num=(num&amp;lt;&amp;lt;3)+(num&amp;lt;&amp;lt;1)+(ch^48);ch=nc();&#125;    return f*num;&#125;int main()&#123;    int t=read();    int T=t;    while(t--)&#123;        memset(a,0,sizeof(a));maxa=0;        printf(&amp;quot;Case #%d: &amp;quot;,T-t);        n=read();k=2;//这里让k=2，如果是选k个的话，就输入k就行了        for(int i=1;i&amp;lt;=n;i++)&#123;            int tmp=read();            maxa=max(maxa,tmp);            a[tmp]++;        &#125;        for(int i=maxa;i&amp;gt;=1;i--)&#123;            int cnt=0,flag=0;            for(int j=i;j&amp;lt;=maxa;j+=i)&#123;                cnt+=a[j];                if(cnt&amp;gt;=k)&#123;                    flag=1;                    printf(&amp;quot;%d\n&amp;quot;,i);                    break;//由于是倒序枚举，找到的答案肯定是最优的                &#125;            &#125;            if(flag)break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOIP2008]立体图</title>
    <link href="/2018/10/31/%5BNOIP2008%5D%E7%AB%8B%E4%BD%93%E5%9B%BE/"/>
    <url>/2018/10/31/%5BNOIP2008%5D%E7%AB%8B%E4%BD%93%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>一道好好的模拟题，Ajsoabk大佬在公堂之上竟然展示奇淫技巧（输出过程），由于windows的种种问题，输出的时候闪得机房dalao不爽，于是机房dalao找到冒泡ioa，希望他能解决这个问题。</p><p>蒟蒻冒泡ioa一开始想是不是机子配置不行，计算不够快才导致了空白，奈何用不到<kbd>神威太湖之光</kbd>，蒟蒻冒泡ioa一筹莫展。</p><p>冒泡ioa在他机房的电脑上无奈地敲着这一题，他想重构代码使得跑的比Ajsoabk更快，然而这是不可能的。<br>冒泡ioa打开了那深紫色的终端——他是机房里面唯一使用Linux的蒟蒻，他无奈地敲下了回车……冒泡ioa不敢相信自己的眼睛！屏幕居然没有闪烁！</p><p>[video width=”1600” height=”900” mp4=”<a href="http://bubbleioa.top/wp-content/uploads/2018/10/%E7%AB%8B%E4%BD%93%E5%9B%BE.mp4&quot;]">http://bubbleioa.top/wp-content/uploads/2018/10/立体图.mp4&quot;]</a></p><p><strong>冒泡ioa现在和他的电脑过的很好。</strong></p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n,m,maxx,maxy;int mana[1000][1000];int pic[1000][1000];void print()&#123;    for(register int i=maxx;i&amp;gt;=0;--i)&#123;        for(register int j=0;j&amp;lt;=maxy;++j)&#123;            putchar(pic[i][j]?pic[i][j]:&amp;#039; &amp;#039;);        &#125;        putchar(&amp;#039;\n&amp;#039;);    &#125;&#125;inline void paint(const int y,const int x,const int ch)&#123;    int i=0;    if(x&amp;gt;maxx)maxx=x;    if(y&amp;gt;maxy)maxy=y;    if(pic[x][y])return ;    else &#123;        system(&amp;quot;clear&amp;quot;);//就是这里，windows要换成cls        // while(i&amp;lt;=10000)i++;        print();        pic[x][y]=ch;    &#125;&#125;inline void draw(const int x,const int y)&#123;    paint(x,y,&amp;#039;+&amp;#039;);    paint(x+4,y,&amp;#039;+&amp;#039;);    paint(x,y+3,&amp;#039;+&amp;#039;);    paint(x+4,y+3,&amp;#039;+&amp;#039;);    paint(x+6,y+2,&amp;#039;+&amp;#039;);    paint(x+6,y+5,&amp;#039;+&amp;#039;);    paint(x+2,y+5,&amp;#039;+&amp;#039;);    paint(x+5,y+1,&amp;#039;/&amp;#039;);    paint(x+5,y+4,&amp;#039;/&amp;#039;);    paint(x+1,y+4,&amp;#039;/&amp;#039;);    for(int i=1;i&amp;lt;=3;++i)&#123;        paint(x+i,y,&amp;#039;-&amp;#039;);        paint(x+i,y+3,&amp;#039;-&amp;#039;);        paint(x+i+2,y+5,&amp;#039;-&amp;#039;);        paint(x+i,y+1,&amp;#039; &amp;#039;);        paint(x+i,y+2,&amp;#039; &amp;#039;);        paint(x+i+1,y+4,&amp;#039; &amp;#039;);    &#125;    for(int i=1;i&amp;lt;=2;++i)&#123;        paint(x,y+i,&amp;#039;|&amp;#039;);        paint(x+4,y+i,&amp;#039;|&amp;#039;);        paint(x+6,y+2+i,&amp;#039;|&amp;#039;);        paint(x+5,y+1+i,&amp;#039; &amp;#039;);    &#125;&#125;void draw(int x,int y,int z)&#123;    draw(2*(x-1)+4*(y-1),2*(x-1)+3*(z-1));&#125;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=n;i;--i)&#123;        for(int j=1;j&amp;lt;=m;j++)&#123;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;mana[i][j]);            mana[i][0]=max(mana[i][0],mana[i][j]);        &#125;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int k=mana[i][0];k;k--)&#123;            for(int j=m;j;--j)&#123;                if(mana[i][j]&amp;gt;=k)draw(i,j,k);            &#125;        &#125;    &#125;    print();    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[水题]终极简单问题</title>
    <link href="/2018/10/30/%5B%E6%B0%B4%E9%A2%98%5D%E7%BB%88%E6%9E%81%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/30/%5B%E6%B0%B4%E9%A2%98%5D%E7%BB%88%E6%9E%81%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目大意：两个人玩牌，他们各有m(&lt;=100)张牌，输入牌上的数字(&lt;=50)，有n(&lt;=50)轮回合，每回合他们从自己牌中随机选1张，牌上的数字加入答案后放回牌组中。问n回合后第一个人赢的概率是多少（保留6位小数）？</p></blockquote><p>我当时居然还想随机模拟最后输出答案（显然精度不够），然而随机数生成我用的是rand*rand()，搞得分布都不均了（降智打击）</p><p>别的不管，这肯定是一道dp题，考虑到数据范围，我们可以这样设计状态。</p><p>[latex]A[i][j][/latex]表示第一个人在第i轮选到的牌的总和是j的概率，[latex]B[i][j][/latex]是第二个人的。</p><p>由于每轮我们抽到每张牌的概率是均等的，所以我们可以用 (上一轮的状态+每张卡的值)/m 来更新当前状态。</p><p>然后我们用[latex]sb[i][/latex]来表示第二个人总和小于i的概率，[latex]sb[i]=sb[i-1]+B[n][i-1][/latex]，最后枚举i，将[latex]A[n][i]\times sb[i][/latex]累加进答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;cstdio&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int m,n,a[100],b[100],mxa,mxb;double A[51][2501],B[51][2501];double sb[2501];double ans;int main()&#123;    int t;    cin&amp;gt;&amp;gt;t;    while(t--)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;m);        mxa=mxb=0;//纪录最大值，缩小枚举范围        for(int i=0;i&amp;lt;m;i++)&#123;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);            mxa=max(mxa,a[i]);        &#125;        for(int i=0;i&amp;lt;m;i++)&#123;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;b[i]);            mxb=max(mxb,b[i]);        &#125;        cin&amp;gt;&amp;gt;n;        memset(A,0,sizeof(A));        memset(B,0,sizeof(B));        A[0][0]=B[0][0]=1.0;//第0轮总和为0的概率肯定是1        for(int i=1;i&amp;lt;=n;i++)&#123;            for(int j=0;j&amp;lt;=mxa*(i-1);j++)&#123;                for(int k=0;k&amp;lt;m;k++)&#123;                    A[i][j+a[k]]+=A[i-1][j]/m;                &#125;            &#125;            for(int j=0;j&amp;lt;=mxb*(i-1);j++)&#123;                for(int k=0;k&amp;lt;m;k++)&#123;                    B[i][j+b[k]]+=B[i-1][j]/m;                &#125;            &#125;        &#125;        sb[0]=0;        for(int i=1;i&amp;lt;=max(mxa,mxb)*n;i++)sb[i]=sb[i-1]+B[n][i-1];        ans=0.0;        for(int i=0;i&amp;lt;=mxa*n;i++)&#123;            ans+=A[n][i]*sb[i];        &#125;        printf(&amp;quot;%.6lf\n&amp;quot;,ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[水题]w</title>
    <link href="/2018/10/29/%5B%E6%B0%B4%E9%A2%98%5Dw/"/>
    <url>/2018/10/29/%5B%E6%B0%B4%E9%A2%98%5Dw/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目大意：有一棵 n 个节点的树，每条边长度为 1，颜色为黑或白。<br>可以执行若干次如下操作：选择一条简单路径，反转路径上所有边的颜色。<br>对于某些边，要求在操作结束时为某一种颜色。<br>给定每条边的初始颜色，求最小操作数，以及满足操作数最小时，最小的操作路径长度和。</p></blockquote><p>没想到还有人Day3能考285分 orz %%%</p><p>这道题看了题解也有点迷（主要是太短了）<br>感谢@<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a>的指点，感觉懂了很多。</p><p>首先我们给出以下定义：</p><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">奇度数点-</td><td align="center">-拥有奇数度数的翻转边的点</td></tr><tr><td align="center"><font color="0000ff">边类型0</font>–</td><td align="center">初始状态和目标状态相同</td></tr><tr><td align="center"><font color="ff0000">边类型1</font>–</td><td align="center">初始状态和目标状态不同</td></tr><tr><td align="center"><strong>边类型2</strong>–</td><td align="center">没有要求</td></tr></tbody></table><p>我们考虑一颗简单树<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/simple.jpg"><br>先不考虑父节点，我们可以将边分为3类，分类的标准为 初始颜色xor目标颜色，蓝色粗线（右侧）为0，即初始状态和目标状态相同，红色线（左侧）为1，即初始状态和目标状态不同，黑色虚线（中）为2，即没有要求。</p><p>我们可以维护一个二元组，[latex]dp[i][/latex]存储i为根的子树内最少的奇度数点数、此时最小总长度。<br>而我们可以知道的是，无论是哪一条简单路径，都会在两侧端点产生两个奇度数点，而且不会重叠（因为重叠了就可以合并成一步）<br>于是我们最终的答案就是[latex]\frac{dp[1].first}{2},dp[1].second[/latex]。</p><p>但是如何更新状态呢？<br>我们可以从叶子节点开始考虑，我们发现如果要更新父节点，就和当前节点与父节点的边的类型有关，如果是类型0，则我们不能翻转它（翻转偶数次也可以满足状态不变，但不是最优解），如果是类型1，我们必须翻转它，如果是类型0，我们可以翻转，也可以不翻转。<br>因此我们可以在dp数组中加上一维0/1，[latex]dp[i][0/1][/latex]储存i与父节点是否翻转的情况下，i为根的子树内最少的奇度数点数、此时最小总长度。</p><p>为了更新我们的状态，我们需要额外开两个变量。<br>|变量名|作用|<br>|:-:|:-:|<br>|tmp0|储存根节点与所有子节点<strong>之间</strong>有<strong>偶数</strong>条边被翻转的情况下，奇度数点的个数和路径长度|<br>|tmp1|储存根节点与所有子节点<strong>之间</strong>有<strong>奇数</strong>条边被翻转的情况下，奇度数点的个数和路径长度|</p><p>为什么分奇偶？我们把刚刚的树拓展一下：<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/simple2.jpg"><br>我们现在只考虑叶子节点上一层的节点怎么更新父节点  </p><ol><li>如果是蓝边或者虚线边，能更新[latex]dp[i][0][/latex]，由于没有取这条边，所以i节点的tmp0将被继承到父节点，而tmp1由于是有奇数条边，所以i节点自己就是一个奇度数点，继承到父节点的时候，奇度数点个数要加一。</li><li>如果是红边或者虚线边，能更新[latex]dp[i][1][/latex]，由于取了这条边，所以i节点的tmp0被继承到父节点时，i节点变为奇度数点，奇度数点+1，路径+1，而tmp1变为偶度数点，奇度数点个数直接继承，路径+1。</li><li>没有更新到的状态就为inf</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int maxn=1e5+10;const pair&amp;lt;int,int&amp;gt;inf=make_pair(1e9,1e9);int n;vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt;g[maxn];pair&amp;lt;int,int&amp;gt; dp[maxn][2];inline pair&amp;lt;int,int&amp;gt; operator+ (pair&amp;lt;int,int&amp;gt; a,pair&amp;lt;int,int&amp;gt; b)&#123;return make_pair(a.first+b.first,a.second+b.second);&#125;void dfs(int pos,int fa,int type)&#123;    pair&amp;lt;int,int&amp;gt; tmp0(0,0),tmp1(inf);//一开始的时候，叶子节点视为偶度数点，不能用tmp1更新     for(int i=0,v;i&amp;lt;g[pos].size();++i)        if((v=g[pos][i].first)!=fa)&#123;            dfs(v,pos,g[pos][i].second);            pair&amp;lt;int,int&amp;gt; nxt0,nxt1;            nxt0=min(tmp0+dp[v][0],tmp1+dp[v][1]);            nxt1=min(tmp1+dp[v][0],tmp0+dp[v][1]);            tmp0=nxt0;tmp1=nxt1;        &#125;    if(type==0||type==2)        dp[pos][0]=min(tmp0,make_pair(tmp1.first+1,tmp1.second));    else        dp[pos][0]=inf;    if(type==1||type==2)        dp[pos][1]=min(make_pair(tmp0.first+1,tmp0.second+1),make_pair(tmp1.first,tmp1.second+1));    else        dp[pos][1]=inf;&#125;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1,a,b,c,d;i&amp;lt;n;++i)&#123;        scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c,&amp;amp;d);        if(d!=2)d=(c^d);//按照上述意思获取边的类型         g[a].push_back(make_pair(b,d));        g[b].push_back(make_pair(a,d));    &#125;    dfs(1,0,0);    printf(&amp;quot;%d %d\n&amp;quot;,dp[1][0].first/2,dp[1][0].second);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2018倒计时</title>
    <link href="/2018/10/26/NOIP2018%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <url>/2018/10/26/NOIP2018%E5%80%92%E8%AE%A1%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<p>最近教练安排得比较紧，没时间更新博客了，最后10多天好好努力吧！不要让自己后悔！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=850 height=86 src="//music.163.com/outchain/player?type=2&id=551339691&auto=1&height=66"></iframe><blockquote><p>「同じ世界に、立っていたんだ」と<br>“在同一个世界 站起来了”<br>「同じ未来に、立っているんだ」と<br>“也会站在同一个未来”</p></blockquote><h1 id="距离NOIP2018还剩"><a href="#距离NOIP2018还剩" class="headerlink" title="距离NOIP2018还剩"></a>距离NOIP2018还剩</h1><p>[wpcdt-countdown id=”415”]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[水题]大众比萨</title>
    <link href="/2018/10/25/%5B%E6%B0%B4%E9%A2%98%5D%E5%A4%A7%E4%BC%97%E6%AF%94%E8%90%A8/"/>
    <url>/2018/10/25/%5B%E6%B0%B4%E9%A2%98%5D%E5%A4%A7%E4%BC%97%E6%AF%94%E8%90%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.yzoj.fun/upload/image/20181025/20181025000212_29745.jpg"><br><img src="http://www.yzoj.fun/upload/image/20181025/20181025000212_23882.jpg"><br><img src="http://www.yzoj.fun/upload/image/20181025/20181025000213_93820.jpg"></p><hr><p>一道水题，觉得用了点小技巧就放上来了。</p><p>首先是读入，前些天看了本省rank1的NOIP2017时间复杂度的代码，%%%全省最短（100分里面），读入用的是自定义的快读。说实话，以后字符串读入都用这种方式就好了，挺方便的。</p><p>还有就是用二进制表示状态，前几天考试也是靠这个骗了80分，最近还学了“位图”这种神奇的东西，感觉整个人都二进制了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int inf=0x3f3f3f3f;bool jud[1&lt;&lt;17];struct person&#123;    int a,b;&#125;p[25];int t;int f;inline int read()&#123;    char ch=&#39;+&#39;;f=1;    while(!isalpha(ch))&#123;if(ch==&#39;-&#39;)f=-1;if(ch==&#39;;&#39;)return inf;if(ch==&#39;.&#39;)return -inf;ch=getchar();&#125;    return (ch-&#39;A&#39;);&#125;bool judge(int sta)&#123;    for(int i=1;i&lt;t;i++)&#123;        if((sta&amp;p[i].a)||(~sta)&amp;p[i].b)continue;        return 0;    &#125;    return 1;&#125;void out(int sta)&#123;    printf(&quot;Toppings: &quot;);    int k=0;    while(sta)&#123;        if(sta&amp;1)printf(&quot;%c&quot;,k+&#39;A&#39;);        k++;        sta&gt;&gt;=1;    &#125;&#125;int main()&#123;    t=1;    while(1)&#123;        int tmp=read();        if(tmp==inf)&#123;t++;continue;&#125;        if(tmp==-inf)break;        if(f==-1)p[t].b|=(1&lt;&lt;(tmp));        else p[t].a|=(1&lt;&lt;tmp);    &#125;    for(int i=0;i&lt;=(1&lt;&lt;16);i++)&#123;        if(judge(i))&#123;            out(i);            return 0;        &#125;    &#125;    printf(&quot;No pizza can satisfy these requests.&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[APIO2010]巡逻</title>
    <link href="/2018/10/25/%5BAPIO2010%5D%E5%B7%A1%E9%80%BB/"/>
    <url>/2018/10/25/%5BAPIO2010%5D%E5%B7%A1%E9%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个地区中有 n 个村庄，编号为 1, 2, …, n。有 n – 1 条道路连接着这些村 庄，每条道路刚好连接两个村庄，从任何一个村庄，都可以通过这些道路到达其 他任一个村庄。每条道路的长度均为 1 个单位。 为保证该地区的安全，巡警车每天要到所有的道路上巡逻。警察局设在编号 为 1 的村庄里，每天巡警车总是从警察局出发，最终又回到警察局。 下图表示一个有 8 个村庄的地区，其中村庄用圆表示（其中村庄 1 用黑色的 圆表示），道路是连接这些圆的线段。为了遍历所有的道路，巡警车需要走的距 离为 14 个单位，每条道路都需要经过两次。</p><p><img src="http://bubbleioa.top/wp-content/uploads/2018/10/xl.gif"></p><p>为了减少总的巡逻距离，该地区准备在这些村庄之间建立 K 条新的道路， 每条新道路可以连接任意两个村庄。两条新道路可以在同一个村庄会合或结束 （见下面的图例（c））。 一条新道路甚至可以是一个环，即，其两端连接到同一 个村庄。 由于资金有限，K 只能是 1 或 2。同时，为了不浪费资金，每天巡警车必须 经过新建的道路正好一次。 下图给出了一些建立新道路的例子：<br> <img src="http://bubbleioa.top/wp-content/uploads/2018/10/xl2.gif"></p><p>在(a)中，新建了一条道路，总的距离是 11。在(b)中，新建了两条道路，总 的巡逻距离是 10。在(c)中，新建了两条道路，但由于巡警车要经过每条新道路 正好一次，总的距离变为了 15。 试编写一个程序，读取村庄间道路的信息和需要新建的道路数，计算出最佳 的新建道路的方案使得总的巡逻距离最小，并输出这个最小的巡逻距离。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行包含两个整数 n, K(1 ≤ K ≤ 2)。接下来 n – 1 行，每行两个整数 a, b， 表示村庄 a 与 b 之间有一条道路(1 ≤ a, b ≤ n)。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出一个整数，表示新建了 K 条道路后能达到的最小巡逻距离。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><pre><code>8 1 1 2 3 1 3 4 5 3 7 5 8 5 5 6</code></pre><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>11</code></pre><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><pre><code>8 2 1 2 3 1 3 4 5 3 7 5 8 5 5 6 </code></pre><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><pre><code>10</code></pre><h3 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h3><pre><code>5 2 1 2 2 3 3 4 4 5</code></pre><h3 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h3><pre><code>6</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>10%的数据中，n ≤ 1000, K = 1；</p><p>30%的数据中，K = 1；</p><p>80%的数据中，每个村庄相邻的村庄数不超过 25；</p><p>90%的数据中，每个村庄相邻的村庄数不超过 150； 100%的数据中，3 ≤ n ≤ 100,000, 1 ≤ K ≤ 2。</p><hr><p>如果不建边的话，每一条边都要被经过两边，所以答案就是[latex]2(n-1)[/latex]。<br>建立一条新的道路后，根据题目意思，新的道路要被经过一次，所以在沿着<a href="x,y">latex</a>[/latex]巡逻之后，要返回[latex]x[/latex]，就必须沿着树上从[latex]y[/latex]到[latex]x[/latex]的路径巡逻一遍，最终形成一个环。这个环上的树边对答案的贡献就减一，显然，在树的直径的两端点建边最优。若树的直径为[latex]L[/latex]答案就是[latex]2(n-1)-L+1[/latex]。</p><p>建两条边，有两个环，如果不重叠，答案继续减小，如果重叠，重叠部分的树边对答案的贡献又会变为2.<br>我们可以这样来解决这个问题：</p><ol><li>在最初的树上求直径，设直径为L1，然后把直径上的边权取反。</li><li>在直径边权取反之后的树上再次求直径，设直径为L2.<br>答案就是[latex]2(n-1)-(L_1-1)-(L_2-1)=2n-L_1-L_2[/latex]</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN = 100005;int Nt[MAXN&amp;lt;&amp;lt;1],Head[MAXN],to[MAXN&amp;lt;&amp;lt;1],tot=1,w[MAXN&amp;lt;&amp;lt;1];int d[MAXN];int k,p;int pre[MAXN];bool v[MAXN];int n,maxx;inline void add(int a,int b)&#123;    Nt[++tot]=Head[a];    to[tot]=b;    w[tot]=1;    Head[a]=tot;&#125;inline char nc()&#123;    static char buf[MAXN],*p1=buf,*p2=buf;    return p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123;    int x=0,f=1;char ch=&amp;#039;a&amp;#039;;    while(!isdigit(ch))&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=nc();&#125;    while(isdigit(ch))&#123;x=(x&amp;lt;&amp;lt;3)+(x&amp;lt;&amp;lt;1)+(ch^48);ch=nc();&#125;    return x*f;&#125;queue&amp;lt;int&amp;gt; q;int bfs(int s)&#123;    int i,x,y;    memset(d,0x3f,sizeof(d));    q.push(s); d[s]=pre[s]=0;    while(q.size())    &#123;        x=q.front(); q.pop();        for(i=Head[x];i;i=Nt[i])            if(d[to[i]]==0x3f3f3f3f)                d[to[i]]=d[x]+w[i],pre[to[i]]=i,q.push(to[i]);    &#125;    for(x=y=1;x&amp;lt;=n;x++) if(d[x]&amp;gt;d[y]) y=x;    return y;&#125;int get()&#123;    p=bfs(1);//两边bfs求直径    p=bfs(p);    return d[p];&#125;void change()&#123;    for(;pre[p];p=to[pre[p]^1]) w[pre[p]]=w[pre[p]^1]=-1;//成对变换&#125;void dp(int x)&#123;//树形dp求直径    v[x]=1;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(v[y])continue;        dp(y);        maxx=max(maxx,d[x]+d[y]+w[i]);        d[x]=max(d[x],d[y]+w[i]);    &#125;&#125;int main()&#123;    n=read();k=read();    for(int i=1;i&amp;lt;n;i++)&#123;        int a=read(),b=read();        add(a,b);add(b,a);    &#125;    int x=get(),z=1;    memset(d,0,sizeof(d));    if(k==2)change(),dp(1),z=2;    cout&amp;lt;&amp;lt;2*(n-1)-maxx-x+z&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10.24日考试反思</title>
    <link href="/2018/10/25/10.24%E6%97%A5%E8%80%83%E8%AF%95%E5%8F%8D%E6%80%9D/"/>
    <url>/2018/10/25/10.24%E6%97%A5%E8%80%83%E8%AF%95%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="T1：音量调节"><a href="#T1：音量调节" class="headerlink" title="T1：音量调节"></a>T1：音量调节</h2><p>做过的最简单的省选题目，考场上首先想到了用bool数组来实现“<strong>可达性dp</strong>”，然后抽象出一个类似背包问题的模型，然而由于做题量太少（太弱了），没遇到过这种题目，不敢用这种想法，于是就用了一个[latex]f[51][2][/latex]数组骗了个40分。</p><h2 id="T2：旅行"><a href="#T2：旅行" class="headerlink" title="T2：旅行"></a>T2：旅行</h2><p>当时脑子抽了，连骗50分的程序都没想到（曼哈顿距离），结果写了一个随机暴力求期望，本来是想卡在0.9s的时候退出的，结果精度差距较大，玄学WA。</p><h2 id="T3：舞蹈课"><a href="#T3：舞蹈课" class="headerlink" title="T3：舞蹈课"></a>T3：舞蹈课</h2><p>想到了堆，想到了链表，先打了一个暴力，后面标称写挂了。结果本地编译器版本太高，默认是C++17没加<kbd>#include<cstdib&gt;#include<cmath&gt;</kbd> 调用abs没报错，结果暴力也挂了orz。</p><h2 id="T4：幸运数字"><a href="#T4：幸运数字" class="headerlink" title="T4：幸运数字"></a>T4：幸运数字</h2><p>知道是dp，推不出。看到最少要多少个括号就用了广搜，二进制记录状态，80分，T了两个点。后来看题解发现他说的几个优化根本不能用在广搜上，别人的迭代加深dfs又好写又快，%%%%。</p><h2 id="T5：运输"><a href="#T5：运输" class="headerlink" title="T5：运输"></a>T5：运输</h2><p>貌似是题目有问题，如果有多条路径它也没说怎么处理，也没有spj。反正我的做法是<strong>dijkstra</strong>求一遍最短路，dfs一遍求路径，应该是没有问题的……吧。</p><h2 id="T6：最长上升（不降）公共子序列"><a href="#T6：最长上升（不降）公共子序列" class="headerlink" title="T6：最长上升（不降）公共子序列"></a>T6：最长上升（不降）公共子序列</h2><p>这个写挂了真的是我自己的锅，直接写得最长上升公共子序列的程序（后来发现也是错的），结果题目意思是不降…………</p><hr><p>就快NOIP了，要赶快调整好状态，要不然就要退役了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOIP2014]寻找道路</title>
    <link href="/2018/10/22/%5BNOIP2014%5D%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF/"/>
    <url>/2018/10/22/%5BNOIP2014%5D%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：</p><p>路径上的所有点的出边所指向的点都直接或间接与终点连通。<br>在满足条件 1的情况下使路径最短。<br>注意：图 G 中可能存在重边和自环，题目保证终点没有出边。</p><p>请你输出符合条件的路径的长度。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。</p><p>接下来的 m 行每行 2 个整数 x,y，之间用一个空格隔开，表示有一条边从点 x 指向点y。</p><p>最后一行有两个用一个空格隔开的整数 s, t，表示起点为 s，终点为 t。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出−1。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><pre><code>3 2  1 2  2 1  1 3</code></pre><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>-1</code></pre><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><pre><code>6 6  1 2  1 3  2 6  2 5  4 5  3 4  1 5</code></pre><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><pre><code>3</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="解释1："><a href="#解释1：" class="headerlink" title="解释1："></a>解释1：</h3><p>如上图所示，箭头表示有向道路，圆点表示城市。起点1 1与终点3 3不连通，所以满足题目描述的路径不存在，故输出−1 。<br><img src="https://cdn.luogu.org/upload/pic/1350.png"></p><h3 id="解释2："><a href="#解释2：" class="headerlink" title="解释2："></a>解释2：</h3><p><img src="https://cdn.luogu.org/upload/pic/1351.png"></p><p>如上图所示，满足条件的路径为1- &gt;3- &gt;4- &gt;5。注意点2 不能在答案路径中，因为点2连了一条边到点6 ，而点6不与终点5 连通。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于30%的数据,[latex] $$0 &lt; n \le 10，0 &lt; m \le 20 $$<br>对于60%的数据$$0 &lt; n \le 100，0 &lt; m \le 2000$$<br>对于100%的数据$$ 0 &lt; n \le 10000, 0 &lt; m \le 200000,0 &lt; x,y,s,t \le n, x,s \ne t$$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>反向建边</li><li>从结束点开始遍历图</li><li>标记没有遍历到的点的出边的点为不合法的点</li><li>最短路<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>```cpp<br>#include&lt;cstdio&gt;<br>#include&lt;iostream&gt;<br>#include&lt;cstring&gt;<br>#include&lt;queue&gt;<br>using namespace std;<br>const int MAXN =200005;<br>int Nt[MAXN],Head[MAXN],to[MAXN],tot;<br>int x[MAXN],y[MAXN],d[MAXN],f[MAXN];<br>bool vis[10003];<br>int n,m,s,t;<br>bool v[10003];</li></ol><p>void add(int a,int b){<br>    Nt[++tot]=Head[a];<br>    to[tot]=b;<br>    Head[a]=tot;<br>}</p><p>void dfs(int x){<br>    v[x]=1;<br>    for(int i=Head[x];i;i=Nt[i]){<br>        int y=to[i];<br>        if(v[y])continue;<br>        dfs(y);<br>    }<br>}</p><p>priority_queue&lt;pair&lt;int,int&gt; &gt; q;<br>void dij(){<br>    memset(d,0x3f,sizeof(d));<br>    memset(vis,0,sizeof(vis));<br>    d[t]=0;<br>    q.push(make_pair(0,t));<br>    while(q.size()){<br>        int x=q.top().second;q.pop();<br>        if(vis[x]==1||f[x]==1)continue;<br>        vis[x]=1;<br>        for(int i=Head[x];i;i=Nt[i]){<br>            int y=to[i];<br>            if(d[y]&gt;d[x]+1){<br>                d[y]=d[x]+1;<br>                q.push(make_pair(-d[y],y));<br>            }<br>        }<br>    }<br>}</p><p>int main(){<br>    cin&gt;&gt;n&gt;&gt;m;<br>    for(int i=1;i&lt;=m;i++){<br>        scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);<br>        if(x[i]==y[i])continue;//忽略自环<br>        add(y[i],x[i]);<br>    }<br>    cin&gt;&gt;s&gt;&gt;t;<br>    dfs(t);<br>    for(int i=1;i&lt;=n;i++)<br>        if(v[i]==0)<br>            for(int j=Head[i];j;j=Nt[j])f[to[j]]=1;<br>    dij();<br>    if(d[s]==0x3f3f3f3f)cout&lt;&lt;-1&lt;&lt;endl;<br>    else cout&lt;&lt;d[s]&lt;&lt;endl;<br>    return 0;<br>}<br>```</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]fhq_treap 最简单的平衡树</title>
    <link href="/2018/10/22/%5B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Dfhq_treap%20%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2018/10/22/%5B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Dfhq_treap%20%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>当然，如果你说STL或者pb_ds里面的平衡树最简单我也没有话说……</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【解答发布】周六下午学长的经验分享！！</title>
    <link href="/2018/10/20/%E3%80%90%E8%A7%A3%E7%AD%94%E5%8F%91%E5%B8%83%E3%80%91%E5%91%A8%E5%85%AD%E4%B8%8B%E5%8D%88%E5%AD%A6%E9%95%BF%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%EF%BC%81%EF%BC%81/"/>
    <url>/2018/10/20/%E3%80%90%E8%A7%A3%E7%AD%94%E5%8F%91%E5%B8%83%E3%80%91%E5%91%A8%E5%85%AD%E4%B8%8B%E5%8D%88%E5%AD%A6%E9%95%BF%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%EF%BC%81%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Q1-编译器是什么版本"><a href="#Q1-编译器是什么版本" class="headerlink" title="Q1:编译器是什么版本"></a>Q1:编译器是什么版本</h1><blockquote><p>by Chen_Xi</p></blockquote><p>玄学，windows上应该都是MinGW5.x</p><h1 id="Q2-可以提前进机房嘛？"><a href="#Q2-可以提前进机房嘛？" class="headerlink" title="Q2:可以提前进机房嘛？"></a>Q2:可以提前进机房嘛？</h1><blockquote><p>by Chen_Xi</p></blockquote><p>好像是可以提前半个小时进去的。</p><h1 id="Q3-看不懂题目怎么办？"><a href="#Q3-看不懂题目怎么办？" class="headerlink" title="Q3:看不懂题目怎么办？"></a>Q3:看不懂题目怎么办？</h1><blockquote><p>by 匿名</p></blockquote><p>建议学好语文。</p><h1 id="Q4-关于SPFA已死怎么看？"><a href="#Q4-关于SPFA已死怎么看？" class="headerlink" title="Q4:关于SPFA已死怎么看？"></a>Q4:关于SPFA已死怎么看？</h1><blockquote><p>by hzy</p></blockquote><p>用于判断负环还是挺有效的，不过这种题目也挺少的吧。个人最短路径偏爱写Dijkstra，确实挺少会用到SPFA。</p><h1 id="Q5-键盘等设备适应嘛"><a href="#Q5-键盘等设备适应嘛" class="headerlink" title="Q5:键盘等设备适应嘛"></a>Q5:键盘等设备适应嘛</h1><blockquote><p>by XF</p></blockquote><p>用着没什么问题，和机房的应该差不多，适不适应看个人吧。其实也没有什么不适应的，代码没有必要敲很快。</p><h1 id="Q6-考试的场所有多大，会不会有空旷感的说？"><a href="#Q6-考试的场所有多大，会不会有空旷感的说？" class="headerlink" title="Q6:考试的场所有多大，会不会有空旷感的说？"></a>Q6:考试的场所有多大，会不会有空旷感的说？</h1><blockquote><p>by 匿名</p></blockquote><p>不算特别大吧，差不多一个教室那么大，不算很空旷，但是显示屏中间有隔板。</p><h1 id="Q7-电脑上一般会有多少个编译器（IDE），是不是只有Dev-C"><a href="#Q7-电脑上一般会有多少个编译器（IDE），是不是只有Dev-C" class="headerlink" title="Q7:电脑上一般会有多少个编译器（IDE），是不是只有Dev-C++"></a>Q7:电脑上一般会有多少个编译器（IDE），是不是只有Dev-C++</h1><blockquote><p>by yanyu</p></blockquote><p>还有guide。</p><h1 id="Q8-可以带食物吗？（糖之类的"><a href="#Q8-可以带食物吗？（糖之类的" class="headerlink" title="Q8:可以带食物吗？（糖之类的"></a>Q8:可以带食物吗？（糖之类的</h1><blockquote><p>by 匿名</p></blockquote><p>可以。</p><h1 id="Q9-可以带草稿纸，水或饮料吗？"><a href="#Q9-可以带草稿纸，水或饮料吗？" class="headerlink" title="Q9:可以带草稿纸，水或饮料吗？"></a>Q9:可以带草稿纸，水或饮料吗？</h1><blockquote><p>by 匿名</p></blockquote><p>草稿纸不可以，水或饮料可以。</p><h1 id="Q10-考场发慌怎么办？"><a href="#Q10-考场发慌怎么办？" class="headerlink" title="Q10:考场发慌怎么办？"></a>Q10:考场发慌怎么办？</h1><blockquote><p>by 匿名</p></blockquote><p>深呼吸。</p><h1 id="Q11：考前是怎样复习的？"><a href="#Q11：考前是怎样复习的？" class="headerlink" title="Q11：考前是怎样复习的？"></a>Q11：考前是怎样复习的？</h1><blockquote><p>by 匿名</p></blockquote><p>模板，对代码熟练掌握。</p><h1 id="Q12-考场上的隔板会有蛮高吗？"><a href="#Q12-考场上的隔板会有蛮高吗？" class="headerlink" title="Q12:考场上的隔板会有蛮高吗？"></a>Q12:考场上的隔板会有蛮高吗？</h1><blockquote><p>by yanyu</p></blockquote><p>高不高不好说，反正看不到隔壁的代码，也没有必要去看。</p><h1 id="Q13-文件夹里还要建立子文件夹的操作流程"><a href="#Q13-文件夹里还要建立子文件夹的操作流程" class="headerlink" title="Q13:文件夹里还要建立子文件夹的操作流程"></a>Q13:文件夹里还要建立子文件夹的操作流程</h1><blockquote><p>by yanyu</p></blockquote><p>已经建好。</p><h1 id="Q14-考场上会有厕所在哪的提示标签吗"><a href="#Q14-考场上会有厕所在哪的提示标签吗" class="headerlink" title="Q14:考场上会有厕所在哪的提示标签吗"></a>Q14:考场上会有厕所在哪的提示标签吗</h1><blockquote><p>by yanyu</p></blockquote><p>有两个监考老师，如果有人要上厕所的话由一个监考老师带去。不过个人大概是沉浸在代码中，期间没有去过厕所。</p><h1 id="Q15-是否会发很多草稿纸？"><a href="#Q15-是否会发很多草稿纸？" class="headerlink" title="Q15:是否会发很多草稿纸？"></a>Q15:是否会发很多草稿纸？</h1><blockquote><p>by yanyu</p></blockquote><p>不会发很多吧，不过草稿纸也很少用。</p><h1 id="Q16-是插空坐还是连着坐"><a href="#Q16-是插空坐还是连着坐" class="headerlink" title="Q16:是插空坐还是连着坐"></a>Q16:是插空坐还是连着坐</h1><blockquote><p>by Chen_Xi</p></blockquote><p>连着坐，有隔板。</p><h1 id="Q17-如果我考试的时候非常紧张，手抖得厉害，深呼吸不管用，我还能干嘛？"><a href="#Q17-如果我考试的时候非常紧张，手抖得厉害，深呼吸不管用，我还能干嘛？" class="headerlink" title="Q17:如果我考试的时候非常紧张，手抖得厉害，深呼吸不管用，我还能干嘛？"></a>Q17:如果我考试的时候非常紧张，手抖得厉害，深呼吸不管用，我还能干嘛？</h1><blockquote><p>by yanyu</p></blockquote><p>这个还真的不好说，个人没有特别紧张，对自己要有信心吧。个人缓解压力的方法是喝水，不过不建议喝多了，上厕所会浪费时间。</p><h1 id="Q18-考试期间严格来说可以去上厕所吗？"><a href="#Q18-考试期间严格来说可以去上厕所吗？" class="headerlink" title="Q18:考试期间严格来说可以去上厕所吗？"></a>Q18:考试期间严格来说可以去上厕所吗？</h1><blockquote><p> by yanyu</p></blockquote><p>可以的。</p><h1 id="Q19-学长们用过vim吗？都说是编辑器之神，我觉得还不如记事本orz"><a href="#Q19-学长们用过vim吗？都说是编辑器之神，我觉得还不如记事本orz" class="headerlink" title="Q19:学长们用过vim吗？都说是编辑器之神，我觉得还不如记事本orz"></a>Q19:学长们用过<strong>vim</strong>吗？都说是编辑器之神，我觉得还不如记事本orz</h1><blockquote><p>by hzy</p></blockquote><p>没有用过。</p><h1 id="Q20-停课结束后该如何快速跟上文化的学习？"><a href="#Q20-停课结束后该如何快速跟上文化的学习？" class="headerlink" title="Q20:停课结束后该如何快速跟上文化的学习？"></a>Q20:停课结束后该如何快速跟上文化的学习？</h1><blockquote><p>by 匿名</p></blockquote><h1 id="Q21-如果考试忘记了某些英文（比如优先队列的priority-queue），能打开头文件查找吗？"><a href="#Q21-如果考试忘记了某些英文（比如优先队列的priority-queue），能打开头文件查找吗？" class="headerlink" title="Q21:如果考试忘记了某些英文（比如优先队列的priority_queue），能打开头文件查找吗？"></a>Q21:如果考试忘记了某些英文（比如优先队列的<kbd>priority_queue</kbd>），能打开头文件查找吗？</h1><blockquote><p>by hzy</p></blockquote><p>可以。</p><h1 id="Q22-电脑是什么系统的，XP吗？"><a href="#Q22-电脑是什么系统的，XP吗？" class="headerlink" title="Q22:电脑是什么系统的，XP吗？"></a>Q22:电脑是什么系统的，XP吗？</h1><blockquote><p>by Lxp</p></blockquote><p>win7的</p><h1 id="Q23-键盘和学校的键盘有什么不同吗？"><a href="#Q23-键盘和学校的键盘有什么不同吗？" class="headerlink" title="Q23:键盘和学校的键盘有什么不同吗？"></a>Q23:键盘和学校的键盘有什么不同吗？</h1><blockquote><p>by Lxp</p></blockquote><p>很爽。</p><h1 id="Q24-如何调整心态，电脑有保护卡吗？如果有，不小心关机了怎么办呢？"><a href="#Q24-如何调整心态，电脑有保护卡吗？如果有，不小心关机了怎么办呢？" class="headerlink" title="Q24:如何调整心态，电脑有保护卡吗？如果有，不小心关机了怎么办呢？"></a>Q24:如何调整心态，电脑有保护卡吗？如果有，不小心关机了怎么办呢？</h1><blockquote><p>by Lxp</p></blockquote><p>存在网盘里。</p><h1 id="Q25-dev-cpp-可以调试吗？"><a href="#Q25-dev-cpp-可以调试吗？" class="headerlink" title="Q25:dev cpp 可以调试吗？"></a>Q25:dev cpp 可以调试吗？</h1><blockquote><p>by Lxp</p></blockquote><p>不太清楚。个人一直不会用调试，所以都是手动调试的。</p><h1 id="Q26-如果对手把键盘敲得咚咚咚响，给我造成了心理压力怎么办？我可以戴耳塞吗？"><a href="#Q26-如果对手把键盘敲得咚咚咚响，给我造成了心理压力怎么办？我可以戴耳塞吗？" class="headerlink" title="Q26:如果对手把键盘敲得咚咚咚响，给我造成了心理压力怎么办？我可以戴耳塞吗？"></a>Q26:如果对手把键盘敲得咚咚咚响，给我造成了心理压力怎么办？我可以戴耳塞吗？</h1><blockquote><p>by Chen_Xi</p></blockquote><p>如果你这么想就带着吧，能不能用就看监考老师了……</p><h1 id="Q27-考试机子上有python吗？"><a href="#Q27-考试机子上有python吗？" class="headerlink" title="Q27:考试机子上有python吗？"></a>Q27:考试机子上有python吗？</h1><blockquote><p>by hzy</p></blockquote><p>由于是windows，应该没有。</p><h1 id="Q28-考试前能去看考场吗？如果能，是提前多久去？"><a href="#Q28-考试前能去看考场吗？如果能，是提前多久去？" class="headerlink" title="Q28:考试前能去看考场吗？如果能，是提前多久去？"></a>Q28:考试前能去看考场吗？如果能，是提前多久去？</h1><blockquote><p>by hgf</p></blockquote><p>30分钟左右。</p><h1 id="Q29-考试时真的有时间对拍吗？"><a href="#Q29-考试时真的有时间对拍吗？" class="headerlink" title="Q29:考试时真的有时间对拍吗？"></a>Q29:考试时真的有时间对拍吗？</h1><blockquote><p>by hzy</p></blockquote><p>没有很大的必要对拍，他会给大样例用于判断代码的正确性。</p><h1 id="Q30-大佬，考试会用stl吗，比如，优先队列，map，set？"><a href="#Q30-大佬，考试会用stl吗，比如，优先队列，map，set？" class="headerlink" title="Q30:大佬，考试会用stl吗，比如，优先队列，map，set？"></a>Q30:大佬，考试会用stl吗，比如，优先队列，map，set？</h1><blockquote><p>by 匿名</p></blockquote><p>有些STL还是很实用的，在NOIP最好要熟练掌握吧。</p><h1 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h1><blockquote><p>by dpj</p></blockquote><h2 id="停课期间"><a href="#停课期间" class="headerlink" title="停课期间"></a>停课期间</h2><ol><li>乐老师比较少讲课，尽量靠自己。</li><li>从个人经验来说，那段时间是按算法和数据结构刷题，对于一个算法或者数据结构，可以先找些模板题做，然后再找一些相应的题来提高。</li><li>对于一些题目，可以先考虑暴力怎么写，写出来看下能有多少分，然后再考虑正解，毕竟比赛的时候遇到不会的题也要打暴力骗分，骗分技巧也是要稍微练一下的。</li><li>遇到难题多交流。</li><li>因为我是NOIP回去之后的考试成绩不理想，所以家里就没让我再去省选，所以要去省选的话事先还是和父母沟通好吧。</li><li>注意健康吧……我们当时6个人几乎就是活生生的反例，停课期间很少锻炼，吃饭都懒得去让去吃饭的帮带到机房……</li></ol><h2 id="NOIP流程"><a href="#NOIP流程" class="headerlink" title="NOIP流程"></a>NOIP流程</h2><blockquote><p>(这些只是去年的一些回忆，不一定准确)</p></blockquote><ol><li>电脑操作系统是Win 7，编译器有GUIDE不过网盘上提供DEV-C＋＋的下载。</li><li>带好身份证进入考场后监考老师会给你一个信封，里面装着你的账号和密码。两天是不一样的。</li><li>在桌面上有一个 NOIP.exe (印象里是叫这个名字)的快捷方式，点开来输入账号密码登录。</li><li>登录之后查看我的电脑，会有一个网络位置，里面存了试题  dev-c＋＋的安装包  注意事项的文本文档(仔细阅读)和三个英文文件夹(对应当天的三道题)。Cpp文件存在三个文件夹下(可能有所变动，按注意事项来做就可以了)。三个文件夹中还有大数据的输入输出样例，用于检测代码的正确性，命名方式不记得是否和题目指定的一样，所以调试结束后注意输入输出文件的名称与题目要求保持一致。</li><li>建议代码直接在网盘中编辑，以防电脑出现问题，但是最后文件夹里只能留cpp文件，其他调试生成的文件都删掉(去年监考老师说给的大样例不用删，不过好像删了也没关系，有什么问题的话还是问监考老师吧)。</li></ol><p>另附：<a href="http://bubbleioa.top/noip%E5%BA%94%E8%80%83%E6%8A%80%E5%B7%A7">dpj学长PPT</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[持续更新]zkw线段树学习笔记</title>
    <link href="/2018/10/19/%5B%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%5Dzkw%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/10/19/%5B%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%5Dzkw%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://artofproblemsolving.com/community/c1368h1020439">zkw大佬的PPT——统计的力量</a><br>虽然说这里有一些错误，但是zkw神犇讲的东西还是挺让人震撼的。</p></blockquote><h1 id="操作一：区间查询，单点修改"><a href="#操作一：区间查询，单点修改" class="headerlink" title="操作一：区间查询，单点修改"></a>操作一：区间查询，单点修改</h1><p><kbd>练习例题 <a href="http://codevs.cn/problem/1080/">CodeVS1080</a></kbd><br>这大概是zkw线段树最简单的操作了<br>如果你看过PPT的话，会发现我们对树的结点的访问是根据结点的二进制数来实现的：  </p><blockquote><p>子结点是父结点右移1位得到的，其中右子结点+1  </p></blockquote><p>所以说，叶子结点的最左边的那个结点无疑是很关键的，只要知道了它，我们访问其他叶子结点只要在它的id上加(i-1)就是第i个叶子结点。</p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>zkw线段树建树就是基于这样一种思想，由下到上：</p><pre><code class="cpp">inline void update(const int &amp;amp;p)&#123;    d[p]=d[p&amp;lt;&amp;lt;1]+d[p&amp;lt;&amp;lt;1|1];&#125;inline void build()&#123;    for(p=1;p&amp;lt;=n+1;p&amp;lt;&amp;lt;=1);//范围坚持zkw的“多开就好”    M=p;//记录下来    for(int i=p+1;i&amp;lt;=p+n;i++)read(d[i]);//更新叶子结点    for(int i=p-1;i;--i)update(i);//更新父结点&#125;</code></pre><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>在此基础上，单点修改也很好执行：</p><pre><code class="cpp">inline void change(int x,int y)&#123;    for(d[x+=M]+=y,x&amp;gt;&amp;gt;=1;x;x&amp;gt;&amp;gt;=1)&#123;        update(x);    &#125;&#125;</code></pre><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>区间查询有点意思，<br>我们先来看一组数据。<br>如果你足够细心的话，应该能发现上面的操作有点问题，因为我们实际建出来的树并不是你想象的那样，而是下面这样：<br>对于</p><pre><code class="cpp">1 2 3 4</code></pre><p>我们查询</p><pre><code class="cpp">2 3</code></pre><p>的话<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/zkw.jpg"><br>树就是这样的，我们把查询范围变成了一个开区间，然后让它们往上走，如果x是左子树，贡献右子树答案，如果y是右子树，贡献左子树答案。</p><p>直到它们有同一个父亲为止。<br>由于左子树和右子树只有最后一位有差别，我们只要将两个结点异或再异或1，如果为0，他们就是同一个父结点的子结点。</p><pre><code class="cpp">inline int ask(int x,int y)&#123;    int ans=0;    for(x=x+M-1,y=y+M+1;x^y^1;x&gt;&gt;=1,y&gt;&gt;=1)&#123;        if(~x&amp;1)ans+=d[x^1];//如果x是左子树，贡献右子树答案        if( y&amp;1)ans+=d[y^1];//如果y是右子树，贡献左子树答案    &#125;    return ans;&#125;</code></pre><h1 id="操作二：噩梦的开始——区间修改"><a href="#操作二：噩梦的开始——区间修改" class="headerlink" title="操作二：噩梦的开始——区间修改"></a>操作二：噩梦的开始——区间修改</h1><p>&lt;kbd&gt;例题练习 <a href="https://www.luogu.org/problemnew/show/P3372">洛谷P3372</a>&lt;/kbd&gt;<br>看完上面操作，我相信你能很快写出zkw线段树并且a掉上面的练习，正当你跃跃欲试想要实现区间修改时，一个很不幸的消息：zkw线段树的区间修改版和单点修改版完全不同，连建树都不一样。<br>具体实现方法有两种，先说差分实现的版本吧。  </p><h2 id="差分实现区间修改"><a href="#差分实现区间修改" class="headerlink" title="差分实现区间修改"></a>差分实现区间修改</h2><h3 id="建树-1"><a href="#建树-1" class="headerlink" title="建树"></a>建树</h3><pre><code class="cpp">void build()&#123;//build之前给 N 赋值    for(p=1;p&lt;=n+1;p&lt;&lt;=1);    for(int i=1;i&lt;=N;++i) read(S[p+i]);    S[p]=P[p]=0;    for(int i=N+1;i&lt;p;++i) S[p+i]=0;     for(int i=p-1;i&gt;0;--i) S[p+i]-=S[p+i-1];//差分     for(int i=1;i&lt;p;++i) P[p+i]=S[p+i]*i; //计算P    for(int i=p-1;i&gt;0;--i) PushUp(i);//建树&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[P1514][NOIP2010]引水入城</title>
    <link href="/2018/10/18/%5BP1514%5D%5BNOIP2010%5D%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E/"/>
    <url>/2018/10/18/%5BP1514%5D%5BNOIP2010%5D%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看到网上很多dfs，bfs，记忆化搜索的代码（其实这个主要也是深搜），但是本校大佬@<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a>用了一个神奇的方法，把它转化成一个线段覆盖的问题。</p><p>首先用了一便深搜，如果所有的蓄水池都建了，能不能满足要求，不满足就直接输出，满足说明肯定有解，下一步。</p><p>确保了有解之后，我们就可以从每个能建蓄水池的城市出发，走到沙漠城市，能够走到的沙漠城市一定是一段连续的区间（要不然就不会有解），我们求出这些区间，然后统计答案即可</p><p>注释说的比较详细了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;const int MAXN=500+5,inf=0x7fffffff;const int dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;/* vis[i][j]用来标记(i,j)是否访问过 */bool vis[MAXN][MAXN],used[MAXN];/* used[i]表示第i个能造蓄水池的城市有没有被遍历 *//* pos[i]表示在覆盖i点的线段中，最右边的点 *//* l[i][j],r[i][j]分别表示(i,j)能走到的最左，最右点 */int n,m,h[MAXN][MAXN],pos[MAXN],cnt,now,l[MAXN][MAXN],r[MAXN][MAXN];inline bool jud(const int &amp;amp;x,const int &amp;amp;y)&#123;    return x&amp;gt;0&amp;amp;&amp;amp;x&amp;lt;=n&amp;amp;&amp;amp;y&amp;gt;0&amp;amp;&amp;amp;y&amp;lt;=m;&#125;void dfs(int x,int y)&#123;    int nx,ny;    vis[x][y]=1;    if(x==1)used[y]=1;    if(x==n)l[x][y]=r[x][y]=y;    for(int i=0;i&amp;lt;4;++i)&#123;//四个方向走        nx=x+dir[i][0];        ny=y+dir[i][1];        if(jud(nx,ny)&amp;amp;&amp;amp;h[nx][ny]&amp;lt;h[x][y])&#123;//合法            if(!vis[nx][ny])//没被访问过                dfs(nx,ny);            if(l[x][y]&amp;gt;l[nx][ny])l[x][y]=l[nx][ny];//更新左右端点            if(r[x][y]&amp;lt;r[nx][ny])r[x][y]=r[nx][ny];        &#125;    &#125;&#125;void dfs1(int x,int y)&#123;    vis[x][y]=1;    int nx,ny;    for(int i=0;i&amp;lt;4;++i)&#123;        nx=x+dir[i][0];        ny=y+dir[i][1];        if(jud(nx,ny)&amp;amp;&amp;amp;h[nx][ny]&amp;lt;h[x][y]&amp;amp;&amp;amp;vis[nx][ny]==0)dfs1(nx,ny);    &#125;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    for(int i=1;i&amp;lt;=n;++i)        for(int j=1;j&amp;lt;=m;++j)            cin&amp;gt;&amp;gt;h[i][j];    /* 判断是否可行 如果全部都建了蓄水池还不行，那就无解 */    for(int i=1;i&amp;lt;=m;++i)if(!vis[1][i])dfs1(1,i);    for(int i=1;i&amp;lt;=m;++i)if(!vis[n][i])cnt++;    if(cnt)&#123;        printf(&amp;quot;0\n%d\n&amp;quot;,cnt);        return 0;    &#125;    /* END */        memset(vis,0,sizeof(vis));    memset(l,0x3f,sizeof(l));    for(int i=1;i&amp;lt;=m;++i)&#123;        if(!used[i])&#123;            dfs(1,i);            for(int j=l[1][i];j&amp;lt;=r[1][i];++j)if(pos[j]&amp;lt;r[1][i])pos[j]=r[1][i];//更新pos        &#125;    &#125;    for(now=1;now!=m+1;now=pos[now]+1)++cnt;//累计答案    printf(&amp;quot;1\n%d\n&amp;quot;,cnt);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOIP2012]疫情控制</title>
    <link href="/2018/10/18/%5BNOIP2012%5D%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/"/>
    <url>/2018/10/18/%5BNOIP2012%5D%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>H 国有 n个城市，这 n 个城市用 n−1条双向道路相互连通构成一棵树，1号城市是首都，也是树中的根节点。</p><p>H国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。</p><p>现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。</p><p>请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行一个整数 n，表示城市个数。</p><p>接下来的 n−1 行，每行 3个整数，u,v,w每两个整数之间用一个空格隔开，表示从城市u到城市 v 有一条长为 w 的道路。数据保证输入的是一棵树，且根节点编号为 1。</p><p>接下来一行一个整数 m，表示军队个数。</p><p>接下来一行 m个整数，每两个整数之间用一个空格隔开，分别表示这 m 个军队所驻扎的城市的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出−1。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><pre><code>4 1 2 1 1 3 2 3 4 3 2 2 2</code></pre><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>3</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="【输入输出样例说明】"><a href="#【输入输出样例说明】" class="headerlink" title="【输入输出样例说明】"></a>【输入输出样例说明】</h3><p>第一支军队在 2 号点设立检查点，第二支军队从 2 号点移动到 3 号点设立检查点，所需时间为 3 个小时。</p><h3 id="【数据范围】"><a href="#【数据范围】" class="headerlink" title="【数据范围】"></a>【数据范围】</h3><p>保证军队不会驻扎在首都。</p><p>对于 20%的数据，2≤n≤10；</p><p>对于 40%的数据，2 ≤n≤50,0&lt;w &lt;10^5</p><p>对于 60%的数据，2 ≤ n≤1000,0&lt;w &lt;10^6</p><p>对于 80%的数据，2 ≤ n≤10,000</p><p>对于 100%的数据，2≤m≤n≤50,000,0&lt;w &lt;10^9</p><p>NOIP 2012 提高组 第二天 第三题</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题确实蛮难想的，又是二分又是贪心，还要用倍增来实现<br>具体看代码吧，注释得挺详细的  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAXN=100005;int Nt[MAXN],Head[MAXN],to[MAXN],w[MAXN],tot;int n,m;long long f[MAXN][18],dis[MAXN][18];bool vis[MAXN],used[MAXN];int army[MAXN],restbj[MAXN],restmin[MAXN];struct node&#123;long long rest;int id;&#125;a[MAXN],b[MAXN];int nb,na;void add(int a,int b,int c)&#123;    Nt[++tot]=Head[a];    to[tot]=b;    w[tot]=c;    Head[a]=tot;&#125;void dfs(int x)&#123;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(y==f[x][0]) continue;        f[y][0]=x,dis[y][0]=w[i];        dfs(y);    &#125;&#125;int checkok(int x,int las)&#123;//找还没被堵死的子树    int bj=1,i,bbj=0;    if(vis[x])return 1;//遇到已经没气了的军队，返回1    for(i=Head[x];i;i=Nt[i])&#123;        if(to[i]==las)continue;bbj=1;        if(!checkok(to[i],x))&#123;//如果继续走能访问到叶子节点            bj=0;//为了让根节点遍历完所有子树还能返回0            if(x==1) b[++nb].id=to[i],b[nb].rest=w[i];//并且是根节点，就记录下这棵子树（不能直接返回0，还要遍历完所有子树）            else return 0;//如果不是根节点，直接返回0        &#125;    &#125;    if(!bbj)return 0;//到叶子节点，返回0    return bj;&#125;bool cmp(node x,node y)&#123;return x.rest&amp;gt;y.rest;&#125;bool solve(long long mid)&#123;    na=0,nb=0;    int x,now;    long long num=0;    for(int i=1;i&amp;lt;=n;++i)vis[i]=restbj[i]=0;//初始化    for(int i=1;i&amp;lt;=m;i++)used[i]=0;//初始化    for(int i=1;i&amp;lt;=m;++i)&#123;//枚举灭一个军队        x=army[i],num=0;        for(int j=17;j&amp;gt;=0;--j)//军队向上跳，要么跳到根节点下，要么跳不动不跳了            if(f[x][j]&amp;gt;1&amp;amp;&amp;amp;num+dis[x][j]&amp;lt;=mid)            num+=dis[x][j],x=f[x][j];        if(f[x][0]==1&amp;amp;&amp;amp;num+dis[x][0]&amp;lt;=mid)&#123;//如果这支军队在根节点下并且还有口气            a[++na].rest=mid-num-dis[x][0],a[na].id=i;//记录下它们剩余体力和编号            if(!restbj[x]||a[na].rest&amp;lt;restmin[x])                restmin[x]=a[na].rest,restbj[x]=i;//更新它们所在节点的最小体力值和对应的队伍编号        &#125;        else vis[x]=1;//如果没气了，标记    &#125;    if(checkok(1,0))return 1;//都被堵死了，可行！    sort(a+1,a+1+na,cmp),sort(b+1,b+1+nb,cmp);//将剩余军队和还没有封死的子树降序排序    now=1;used[0]=1;//很重要    for(int i=1;i&amp;lt;=nb;++i)&#123;//枚举每一棵未封死的子树        if(!used[restbj[b[i].id]])&#123;used[restbj[b[i].id]]=1;continue;&#125;//如果子树上有队伍，子树标记为用过        while(now&amp;lt;=na&amp;amp;&amp;amp;(used[a[now].id]||a[now].rest&amp;lt;b[i].rest))++now;//now是指已用过的队伍        if(now&amp;gt;na)return 0;        used[a[now].id]=1;    &#125;    return 1;&#125;int main()&#123;    long long sum=0;    cin&amp;gt;&amp;gt;n;    for(int i=1;i&amp;lt;n;++i)&#123;        int a,b,c;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);        add(a,b,c);add(b,a,c);sum+=c;    &#125;    cin&amp;gt;&amp;gt;m;    for(int i=1;i&amp;lt;=m;++i)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;army[i]);    &#125;        dfs(1);    for(int i=1;i&amp;lt;=17;i++)&#123;        for(int j=1;j&amp;lt;=n;j++)&#123;            f[j][i]=f[f[j][i-1]][i-1];            dis[j][i]=dis[j][i-1]+dis[f[j][i-1]][i-1];        &#125;    &#125;    long long l=0,r=sum+1;    int ans=-1;        while(l&amp;lt;=r)&#123;        long long mid=(l+r)&amp;gt;&amp;gt;1;        if(solve(mid))r=mid-1,ans=mid;        else l=mid+1;    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[P1979][NOIP2013]华容道</title>
    <link href="/2018/10/16/%5BP1979%5D%5BNOIP2013%5D%E5%8D%8E%E5%AE%B9%E9%81%93/"/>
    <url>/2018/10/16/%5BP1979%5D%5BNOIP2013%5D%E5%8D%8E%E5%AE%B9%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%8D%8E%E5%AE%B9%E9%81%931.png"><br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%8D%8E%E5%AE%B9%E9%81%932.png"><br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%8D%8E%E5%AE%B9%E9%81%933.png"></p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>3 4 20 1 1 10 1 1 00 1 0 03 2 1 2 2 21 2 2 2 3 2</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>2-1</code></pre><p><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%8D%8E%E5%AE%B9%E9%81%934.png"><br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%8D%8E%E5%AE%B9%E9%81%935.png"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote><p>算法分析摘自<kbd>《2013全国信息学奥林匹克年鉴》</kbd></p></blockquote><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>这道题主要考察同学们对最短路算法的理解。（我考试的时候怎么没看出来orz）<br>本题是一个很典型的最短路模型的题目。<br>假设我们把棋盘的局面当作结点，若A局面能通过一步变成B局面则将A局面和B局面对应的结点连上一条边权为1的边。那么问题就成了求这样建成的图中从初始局面对应的结点到达指定移动格在目标位置的局面对应的那些结点的最短路。也就是求边权都为1的途中的一个单源最短路，用BFS就可以解决这个问题了。具体做法如下：   </p><hr><p>用(EX,EY,MX,MY)表示空白格在(EX,EY)，指定移动格在(MX,MY)的局面所对应的结点。   </p><ol><li>将(EX,EY,SX,SY)进队，将Distance(EX,EY,SX,SY)设为0。</li><li>若队为空，则输出无解，算法结束。</li><li>将队首元素取出，设为(EX,EY,MX,MY)。</li></ol><ul><li>若(MX,MY)等于(TX,TY)，则Distance(EX,EY,MX,MY)即为所求答案，算法结束。  </li><li>否则，设由(EX,EY,MX,MY)能到达的局面(EX’,EY’,MX’,MY’)，且(EX’,EY’,MX’,MY’)从未进队过，则将(EX’,EY’,MX’,MY’)进队，将Distance(EX’,EY’,MX’,MY’)设Distance(EX,EY,MX,MY)+1，然后跳至步骤2.</li></ul><p>可以知道，一个局面由空白格的位置和指定移动格的位置唯一确定，所以局面的数量是[latex]O((nm)^2)[/latex]的，也就是说建成的图的结点数是[latex]O((nm)^2)[/latex]的。由于每个局面只可能通过空格和上下左右的移动格交换来变成另外一个局面，所以建成的图中的边数也是[latex]O((nm)^2)[/latex]的。因此求一次最短路的时间复杂度就为[latex]O(V+E)[/latex]，即[latex]O((nm)^2)[/latex]。但是询问有q次，所以总的时间复杂度为[latex]O(q(nm)^2)[/latex]。</p><p>我们发现之间bfs不能满足题目的要求，所以算法还需要优化。</p><p>进一步分析可以发现，指定移动格只有当空白格在它附近才能移动，所以游戏的过程可以看成将空白格先移动到指定移动格附近（此处不考虑初始位置和目标位置相同的情况），然后指定移动格和空白格交换，再将空白格移动到指定移动格附近，然后再将空白格移动到指定移动格附近，然后再将指定移动格和空白格交换……如此循环下去，直至指定移动格达到目标位置。</p><p>如果只考虑空白格在指定移动格附近的局面，那这样的局面数显然是[latex]O(nm)[/latex]的。而局面之间的转移我们只考虑两种，一种是交换指定移动格附近的位置（比如由上方移动到右方）。第一种转移只需要一步，而第二种转移所需的步数就等于固定指定移动格后将空白格移动所需的最小步数，这个步数可以bfs求出，且由于这样的bfs只有[latex]O(nm)[/latex]种，且每种所需的时间是[latex]O(nm)[/latex]，所以我们可以在[latex]O((nm)^2)[/latex]的时间内预处理出来(或者像标程一样采用记忆化的方法)。</p><p>两种转移总共最多能转移到5个新的局面，所以暗张这样的局面来建图，点数和边数都是[latex]O(nm)[/latex]的，但是边权就不是全为1了，所以需要用dijsktra算法来求最短路，时间复杂度为[latex]O(nm\times log(nm))[/latex]。加上预处理，总的时间复杂度为[latex]O((nm)^2+nm\times log(nm))[/latex]</p><p>至此，本题就完美地解决了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码来自@<a href="https://www.luogu.org/space/show?uid=13091">ghj1222</a></p><pre><code class="cpp">#include &amp;lt;bits/stdc++.h&amp;gt;#define inf 0x3f3f3f3fusing namespace std;//方向数组 const int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;;//mp是读入的地图，tt[i][j][d1][d2]是不经过(i,j)的情况下，(i,j)的d1方向转移到 (i,j)的d2方向的最短距离//d是广搜求距离用到的d数组，di是dijkstra时用到的d数组 v是dijkstra时用到的标记数组 int mp[32][32], tt[32][32][4][4], d[32][32], di[32][32][4];bool v[32][32][4];int n, m, q;//如题 //dijkstra过程中用到的状态结构体 struct st&#123;    int x, y, d, dis;    st(int x = 0, int y = 0, int d = 0, int dis = 0) : x(x), y(y), d(d), dis(dis)    &#123;        //构造函数     &#125;    friend bool operator&amp;gt;(const st &amp;amp;a, const st &amp;amp;b);&#125;;//获取当前方向与dir相反的方向 int rev(int dir)&#123;//  printf(&amp;quot;(%d,%d) - &amp;gt; (%d,%d)\n&amp;quot;, dx[dir], dy[dir], dx[dir ^ 1], dy[dir ^ 1]);    return dir ^ 1;&#125;//因为要使用小根堆，所以这里重载了大于号 bool operator&amp;gt;(const st &amp;amp;a, const st &amp;amp;b)&#123;    return a.dis &amp;gt; b.dis;&#125;//判断一个点是否合法(是否能够走到) bool valid(int x, int y)&#123;    return x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m &amp;amp;&amp;amp; mp[x][y] == 1;&#125;//利用bfs算法求出(x1,y1)到(x2,y2)的距离 int dis(int x1, int y1, int x2, int y2)&#123;//  printf(&amp;quot;求出(%d,%d)到(%d,%d)的距离\n&amp;quot;, x1, y1, x2, y2);     if(x1 == x2 &amp;amp;&amp;amp; y1 == y2)        return 0;    memset(d, 0x3f, sizeof(d));    queue&amp;lt;int&amp;gt; qx, qy;//队列     qx.push(x1);    qy.push(y1);    d[x1][y1] = 0;    while (!qx.empty())    &#123;        int x = qx.front(), y = qy.front();        qx.pop();        qy.pop();        for (int i = 0; i &amp;lt;= 3; i++)        &#123;            int nx = x + dx[i], ny = y + dy[i];            if(valid(nx, ny) &amp;amp;&amp;amp; d[nx][ny] &amp;gt;= inf)//当前方块合法且没有被搜索             &#123;                d[nx][ny] = d[x][y] + 1;                if(nx == x2 &amp;amp;&amp;amp; ny == y2)//到了终点                 &#123;//                  printf(&amp;quot;(%d,%d)到(%d,%d)的距离为%d\n&amp;quot;, x1, y1, x2, y2, d[nx][ny]);                     return d[nx][ny];                &#125;                qx.push(nx);                qy.push(ny);            &#125;        &#125;    &#125;    return inf;&#125;void prework()&#123;    int x1, y1, x2, y2;    for (int i = 1; i &amp;lt;= n; i++)        for (int j = 1; j &amp;lt;= m; j++)            if (mp[i][j] == 1)            &#123;                mp[i][j] = 0;//暂时将(i,j)标记为不可以动的方块                 for (int src = 0; src &amp;lt;= 3; src++)//枚举d1                     if (valid(x1 = i + dx[src], y1 = j + dy[src]))//d1方向的块合法                         for (int dest = 0; dest &amp;lt;= 3; dest++)//枚举d2                             if (valid(x2 = i + dx[dest], y2 = j + dy[dest]))//d2方向的块合法                                 tt[i][j][src][dest] = dis(x1, y1, x2, y2);//求两个块间的距离                 mp[i][j] = 1;//还原标记             &#125;&#125;void work()&#123;    int ex, ey, sx, sy, tx, ty;//如题     priority_queue&amp;lt;st, vector&amp;lt;st&amp;gt;, greater&amp;lt;st&amp;gt; &amp;gt;pq;//小根堆     scanf(&amp;quot;%d%d%d%d%d%d&amp;quot;, &amp;amp;ex, &amp;amp;ey, &amp;amp;sx, &amp;amp;sy, &amp;amp;tx, &amp;amp;ty);    if(sx == tx &amp;amp;&amp;amp; sy == ty)//他本来就在目标位置     &#123;        printf(&amp;quot;0\n&amp;quot;);        return;    &#125;    memset(di, 0x3f, sizeof(di));//初始化距离数组     memset(v, 0, sizeof(v));//初始化     mp[sx][sy] = 0;///注意要把指定可移动块标记为不可移动     for (int i = 0; i &amp;lt;= 3; i++)//枚举空白格子去指定可移动块的那个方向     &#123;        int nx = sx + dx[i], ny = sy + dy[i];        if (valid(nx, ny))//这个位置合法         &#123;            int ds = dis(ex, ey, nx, ny);//计算距离             pq.push(st(sx, sy, i, ds));//扔进小根堆，dij用             di[sx][sy][i] = ds;//更新dijkstra的di数组         &#125;    &#125;    mp[sx][sy] = 1;//把指定可移动块不可移动的标记还原     while (!pq.empty())//dijkstra的套路     &#123;        st now = pq.top();        pq.pop();//      printf(&amp;quot;迪杰斯特拉 %d %d (%d,%d) %d\n&amp;quot;, now.x, now.y, dx[now.d], dy[now.d], now.dis);         if (v[now.x][now.y][now.d] == 1)            continue;        v[now.x][now.y][now.d] = 1;        int &amp;amp;x = now.x, &amp;amp;y = now.y;         for (int i = 0; i &amp;lt;= 3; i++)        &#123;            int nx = x + dx[i], ny = y + dy[i];//让空白块移动到(nx,ny)然后让指定可移动块移动到空白块位置 //          printf(&amp;quot;下一个为(%d,%d)\n&amp;quot;, nx, ny);             if (valid(nx, ny))//(nx,ny)是合法的             &#123;//              printf(&amp;quot;(%d,%d)合法\n&amp;quot;, nx, ny);                 int ds = tt[x][y][now.d][i];//直接从tt数组获取空白格子移动的距离                 if (v[nx][ny][rev(i)] == 0 &amp;amp;&amp;amp; now.dis + ds + 1 &amp;lt; di[nx][ny][rev(i)])//dij套路，更新距离                 &#123;//                  printf(&amp;quot;由(%d,%d,%d,%d,%d)到(%d,%d,%d,%d,%d)\n&amp;quot;, now.x, now.y, dx[now.d], dy[now.d], now.dis, nx, ny, dx[rev(i)], dy[rev(i)], now.dis + ds + 1);                     di[nx][ny][rev(i)] = now.dis + ds + 1;                    pq.push(st(nx, ny, rev(i), now.dis + ds + 1));                &#125;            &#125;        &#125;    &#125;    int mind = inf;    for (int i = 0; i &amp;lt;= 3; i++)//枚举目标位置的4个方向的状态更新最小值     &#123;        mind = min(mind, di[tx][ty][i]);//      printf(&amp;quot;di[%d][%d][%d] = %d\n&amp;quot;, tx, ty, i, di[tx][ty][i]);    &#125;    if (mind == inf)//最小值没有被更新，说明目标位置不可到达         printf(&amp;quot;-1\n&amp;quot;);    else        printf(&amp;quot;%d\n&amp;quot;, mind);&#125;//主函数 int main()&#123;    scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;q);    for (int i = 1; i &amp;lt;= n; i++)        for (int j = 1; j &amp;lt;= m; j++)            scanf(&amp;quot;%d&amp;quot;, &amp;amp;mp[i][j]);    prework();    for (int i = 1; i &amp;lt;= q; i++)        work();    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOIP2012]国王游戏</title>
    <link href="/2018/10/14/%5BNOIP2012%5D%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F/"/>
    <url>/2018/10/14/%5BNOIP2012%5D%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.yzoj.fun/upload/image/20181009/20181009221055_60327.jpg"><br><img src="http://www.yzoj.fun/upload/image/20181009/20181009221055_57583.jpg"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote><p>内容摘自李煜东所著《算法竞赛进阶指南》<br>由于本题输出过大，要用高进度，但是这里主要讨论贪心，请先无视高精度  </p></blockquote><p>按照每个大臣左、右手上的数的乘积从小到大排序，就是最优排队方案。这个贪心算法可以使用微扰（临项交换）证明。<br>对于任意一种排序，设[latex]n[/latex]名大臣左、右手上的数分别是[latex]A[1][/latex]到[latex]A[n][/latex]与[latex]B[1][/latex]到[latex]B[n][/latex]，国王里的数是[latex]A[0][/latex]和[latex]B[0][/latex]。<br>如果我们交换两个相邻的大臣[latex]i[/latex]与[latex]i+1[/latex]，在交换前这两个大臣获得的奖励是：  </p><center>[latex]\displaystyle \frac{1}{B[i]} \times \prod_{j=0}^{i-1} A[j] [/latex]与[latex]\displaystyle \frac{1}{B[i+1]} \times \prod_{j=0}^i A[j][/latex]</center><p>交换之后这两个大臣获得的奖励是：</p><center>[latex]\displaystyle \frac{1}{B[i+1]} \times \prod_{j=0}^{i-1} A[j] [/latex]与[latex]\displaystyle \frac{A[i+1]}{B[i]} \times \prod_{j=0}^{i-1} A[j][/latex]</center><p>其他大臣获得的奖励显然都不变，因此我们只需要比较上面两组式子最大值的变化。提取出公因式[latex]\prod_{j=0}^{i-1}A[j][/latex]后，实际上需要比较下面两个式子的大小关系：</p><center>[latex]max(\frac{1}{B[i]},\frac{A[i]}{B[i+1]})[/latex] ——[latex]max(\frac{1}{B[i+1]},\frac{A[i+1]}{B[i]})[/latex]</center><p>两边同时乘上[latex]B[i]\times B[i+1][/latex]，变为比较：</p><center>[latex]max(B[i+1],A[i]\times B[i])[/latex] ——[latex]max(B[i],A[i+1]\times B[i+1])[/latex]</center>注意到大臣手上的树都是正整数，故[latex]B[i+1]\le A[i+1]\times B[i+1][/latex]，且[latex]B[i] \le A[i]\times B[i][/latex]。<p>于是，当[latex]A[i]\times B[i]\le A[i+1]\times B[i+1][/latex]时，[latex]左式\le 右式[/latex]，交换前更优。当[latex]A[i+1]\times B[i+1]\le A[i]\times B[i][/latex]时[latex] 右式\le 左式[/latex]，交换后更优。也就是说，在任何局面下，减小逆序对数都不会造成整体结果变差，而增加逆序对数则不会使整体结果变好。</p><p>最后，根据冒泡排序的知识，任何一个序列都能通过邻项交换的方式变为有序序列。故当逆序对数为0，即按上述方案排序时就是最优策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN=1005;const unsigned long long N=1000000000000000;int n;struct hand&#123;    int l,r;&#125;h[MAXN];    #define MAXN 9999#define MAXSIZE 10000000#define DLEN 4  class BigNum&#123;private:    int a[5000];    //可以控制大数的位数     int len;       //大数长度public:    BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125;   //构造函数    BigNum(const int);       //将一个int类型的变量转化为大数    BigNum(const char*);     //将一个字符串类型的变量转化为大数    BigNum(const BigNum &amp;amp;);  //拷贝构造函数    BigNum &amp;amp;operator=(const BigNum &amp;amp;);   //重载赋值运算符，大数之间进行赋值运算      friend istream&amp;amp; operator&amp;gt;&amp;gt;(istream&amp;amp;, BigNum&amp;amp;);   //重载输入运算符    friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp;, BigNum&amp;amp;);   //重载输出运算符      BigNum operator+(const BigNum &amp;amp;) const;   //重载加法运算符，两个大数之间的相加运算     BigNum operator-(const BigNum &amp;amp;) const;   //重载减法运算符，两个大数之间的相减运算     BigNum operator*(const BigNum &amp;amp;) const;   //重载乘法运算符，两个大数之间的相乘运算     BigNum operator/(const int   &amp;amp;) const;    //重载除法运算符，大数对一个整数进行相除运算      BigNum operator^(const int  &amp;amp;) const;    //大数的n次方运算    int    operator%(const int  &amp;amp;) const;    //大数对一个int类型的变量进行取模运算        bool   operator&amp;gt;(const BigNum &amp;amp; T)const;   //大数和另一个大数的大小比较    bool   operator&amp;gt;(const int &amp;amp; t)const;      //大数和一个int类型的变量的大小比较      void print();       //输出大数&#125;;BigNum::BigNum(const int b)     //将一个int类型的变量转化为大数&#123;    int c, d = b;    len = 0;    memset(a, 0, sizeof(a));    while (d &amp;gt; MAXN)    &#123;        c = d - (d / (MAXN + 1)) * (MAXN + 1);        d = d / (MAXN + 1);        a[len++] = c;    &#125;    a[len++] = d;&#125;BigNum::BigNum(const char*s)     //将一个字符串类型的变量转化为大数&#123;    int t, k, index, l, i;    memset(a, 0, sizeof(a));    l = strlen(s);    len = l / DLEN;    if (l%DLEN)        len++;    index = 0;    for (i = l - 1; i &amp;gt;= 0; i -= DLEN)    &#123;        t = 0;        k = i - DLEN + 1;        if (k&amp;lt;0)            k = 0;        for (int j = k; j &amp;lt;= i; j++)            t = t * 10 + s[j] - &amp;#039;0&amp;#039;;        a[index++] = t;    &#125;&#125;BigNum::BigNum(const BigNum &amp;amp; T) : len(T.len)  //拷贝构造函数&#123;    int i;    memset(a, 0, sizeof(a));    for (i = 0; i &amp;lt; len; i++)        a[i] = T.a[i];&#125;BigNum &amp;amp; BigNum::operator=(const BigNum &amp;amp; n)   //重载赋值运算符，大数之间进行赋值运算&#123;    int i;    len = n.len;    memset(a, 0, sizeof(a));    for (i = 0; i &amp;lt; len; i++)        a[i] = n.a[i];    return *this;&#125;istream&amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp; in, BigNum &amp;amp; b)   //重载输入运算符&#123;    char ch[MAXSIZE * 4];    int i = -1;    in &amp;gt;&amp;gt; ch;    int l = strlen(ch);    int count = 0, sum = 0;    for (i = l - 1; i &amp;gt;= 0;)    &#123;        sum = 0;        int t = 1;        for (int j = 0; j&amp;lt;4 &amp;amp;&amp;amp; i &amp;gt;= 0; j++, i--, t *= 10)        &#123;            sum += (ch[i] - &amp;#039;0&amp;#039;)*t;        &#125;        b.a[count] = sum;        count++;    &#125;    b.len = count++;    return in;  &#125;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; out, BigNum&amp;amp; b)   //重载输出运算符&#123;    int i;    cout &amp;lt;&amp;lt; b.a[b.len - 1];    for (i = b.len - 2; i &amp;gt;= 0; i--)    &#123;        cout.width(DLEN);        cout.fill(&amp;#039;0&amp;#039;);        cout &amp;lt;&amp;lt; b.a[i];    &#125;    return out;&#125;  BigNum BigNum::operator+(const BigNum &amp;amp; T) const   //两个大数之间的相加运算&#123;    BigNum t(*this);    int i, big;      //位数       big = T.len &amp;gt; len ? T.len : len;    for (i = 0; i &amp;lt; big; i++)    &#123;        t.a[i] += T.a[i];        if (t.a[i] &amp;gt; MAXN)        &#123;            t.a[i + 1]++;            t.a[i] -= MAXN + 1;        &#125;    &#125;    if (t.a[big] != 0)        t.len = big + 1;    else        t.len = big;    return t;&#125;BigNum BigNum::operator-(const BigNum &amp;amp; T) const   //两个大数之间的相减运算 &#123;    int i, j, big;    bool flag;    BigNum t1, t2;    if (*this&amp;gt;T)    &#123;        t1 = *this;        t2 = T;        flag = 0;    &#125;    else    &#123;        t1 = T;        t2 = *this;        flag = 1;    &#125;    big = t1.len;    for (i = 0; i &amp;lt; big; i++)    &#123;        if (t1.a[i] &amp;lt; t2.a[i])        &#123;            j = i + 1;            while (t1.a[j] == 0)                j++;            t1.a[j--]--;            while (j &amp;gt; i)                t1.a[j--] += MAXN;            t1.a[i] += MAXN + 1 - t2.a[i];        &#125;        else            t1.a[i] -= t2.a[i];    &#125;    t1.len = big;    while (t1.a[len - 1] == 0 &amp;amp;&amp;amp; t1.len &amp;gt; 1)    &#123;        t1.len--;        big--;    &#125;    if (flag)        t1.a[big - 1] = 0 - t1.a[big - 1];    return t1;&#125;  BigNum BigNum::operator*(const BigNum &amp;amp; T) const   //两个大数之间的相乘运算 &#123;    BigNum ret;    int i, j, up;    int temp, temp1;    for (i = 0; i &amp;lt; len; i++)    &#123;        up = 0;        for (j = 0; j &amp;lt; T.len; j++)        &#123;            temp = a[i] * T.a[j] + ret.a[i + j] + up;            if (temp &amp;gt; MAXN)            &#123;                temp1 = temp - temp / (MAXN + 1) * (MAXN + 1);                up = temp / (MAXN + 1);                ret.a[i + j] = temp1;            &#125;            else            &#123;                up = 0;                ret.a[i + j] = temp;            &#125;        &#125;        if (up != 0)            ret.a[i + j] = up;    &#125;    ret.len = i + j;    while (ret.a[ret.len - 1] == 0 &amp;amp;&amp;amp; ret.len &amp;gt; 1)        ret.len--;    return ret;&#125;BigNum BigNum::operator/(const int &amp;amp; b) const   //大数对一个整数进行相除运算&#123;    BigNum ret;    int i, down = 0;    for (i = len - 1; i &amp;gt;= 0; i--)    &#123;        ret.a[i] = (a[i] + down * (MAXN + 1)) / b;        down = a[i] + down * (MAXN + 1) - ret.a[i] * b;    &#125;    ret.len = len;    while (ret.a[ret.len - 1] == 0 &amp;amp;&amp;amp; ret.len &amp;gt; 1)        ret.len--;    return ret;&#125;int BigNum::operator %(const int &amp;amp; b) const    //大数对一个int类型的变量进行取模运算    &#123;    int i, d = 0;    for (i = len - 1; i &amp;gt;= 0; i--)    &#123;        d = ((d * (MAXN + 1)) % b + a[i]) % b;    &#125;    return d;&#125;BigNum BigNum::operator^(const int &amp;amp; n) const    //大数的n次方运算&#123;    BigNum t, ret(1);    int i;    if (n&amp;lt;0)        exit(-1);    if (n == 0)        return 1;    if (n == 1)        return *this;    int m = n;    while (m&amp;gt;1)    &#123;        t = *this;        for (i = 1; i &amp;lt;&amp;lt; 1 &amp;lt;= m; i &amp;lt;&amp;lt;= 1)        &#123;            t = t * t;        &#125;        m -= i;        ret = ret * t;        if (m == 1)            ret = ret * (*this);    &#125;    return ret;&#125;bool BigNum::operator&amp;gt;(const BigNum &amp;amp; T) const   //大数和另一个大数的大小比较&#123;    int ln;    if (len &amp;gt; T.len)        return true;    else if (len == T.len)    &#123;        ln = len - 1;        while (a[ln] == T.a[ln] &amp;amp;&amp;amp; ln &amp;gt;= 0)            ln--;        if (ln &amp;gt;= 0 &amp;amp;&amp;amp; a[ln] &amp;gt; T.a[ln])            return true;        else            return false;    &#125;    else        return false;&#125;bool BigNum::operator &amp;gt;(const int &amp;amp; t) const    //大数和一个int类型的变量的大小比较&#123;    BigNum b(t);    return *this&amp;gt;b;&#125;void BigNum::print()    //输出大数&#123;    int i;    cout &amp;lt;&amp;lt; a[len - 1];    for (i = len - 2; i &amp;gt;= 0; i--)    &#123;        cout.width(DLEN);        cout.fill(&amp;#039;0&amp;#039;);        cout &amp;lt;&amp;lt; a[i];    &#125;    cout &amp;lt;&amp;lt; endl;&#125; bool cmp(hand a,hand b)&#123;    return a.r*a.l&amp;lt;b.r*b.l;&#125; int main()&#123;    cin&amp;gt;&amp;gt;n;    int l,r;    cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;    for(int i=1;i&amp;lt;=n;i++)&#123;        cin&amp;gt;&amp;gt;h[i].l&amp;gt;&amp;gt;h[i].r;    &#125;    sort(h+1,h+1+n,cmp);    BigNum ans=0;    BigNum sum=l;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(sum/h[i].r&amp;gt;ans)&#123;            ans=sum/h[i].r;        &#125;        sum=sum*h[i].l;    &#125;    ans.print();    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[看见统计]一个超赞的交互式学习网站</title>
    <link href="/2018/10/14/%5B%E7%9C%8B%E8%A7%81%E7%BB%9F%E8%AE%A1%5D%E4%B8%80%E4%B8%AA%E8%B6%85%E8%B5%9E%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
    <url>/2018/10/14/%5B%E7%9C%8B%E8%A7%81%E7%BB%9F%E8%AE%A1%5D%E4%B8%80%E4%B8%AA%E8%B6%85%E8%B5%9E%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>我说的再好也不如大家自己去体会一下：  </p><p><a href="https://seeing-theory.brown.edu/">网站链接</a></p><p>支持中文！！！  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[BZOJ1857][Scoi2010]传送带</title>
    <link href="/2018/10/14/%5BBZOJ1857%5D%5BScoi2010%5D%E4%BC%A0%E9%80%81%E5%B8%A6/"/>
    <url>/2018/10/14/%5BBZOJ1857%5D%5BScoi2010%5D%E4%BC%A0%E9%80%81%E5%B8%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>在一个2维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段AB和线段CD。Lxp在AB上的移动速度为P，在CD上的移动速度为Q，在平面上的移动速度R。现在Lxp想从A点走到D点，他想知道最少需要走多长时间</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入数据第一行是4个整数，表示A和B的坐标，分别为Ax，Ay，Bx，By 第二行是4个整数，表示C和D的坐标，分别为Cx，Cy，Dx，Dy 第三行是3个整数，分别是P，Q，R</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出数据为一行，表示Lxp从A点走到D点的最短时间，保留到小数点后2位</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>0 0 0 100100 0 100 1002 2 1</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>136.60</code></pre><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>对于100%的数据，1&lt;= Ax，Ay，Bx，By，Cx，Cy，Dx，Dy&lt;=1000<br>1&lt;=P，Q，R&lt;=10</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;ctime&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;const double R=0.98,Exp=1e-3,times=50;inline double dis(double X1,double Y1,double X2,double Y2)&#123;    return sqrt((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2));&#125;int main()&#123;    srand((unsigned)time(0));    double ax,ay,bx,by,cx,cy,dx,dy;    int p,q,r;    scanf(&amp;quot;%lf%lf%lf%lf&amp;quot;,&amp;amp;ax,&amp;amp;ay,&amp;amp;bx,&amp;amp;by);    scanf(&amp;quot;%lf%lf%lf%lf&amp;quot;,&amp;amp;cx,&amp;amp;cy,&amp;amp;dx,&amp;amp;dy);    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;p,&amp;amp;q,&amp;amp;r);    double ab,cd,ac,bc,ad,bd;    ab=dis(ax,ay,bx,by);    cd=dis(cx,cy,dx,dy);    ac=dis(ax,ay,cx,cy);    bc=dis(bx,by,cx,cy);    ad=dis(ax,ay,dx,dy);    bd=dis(bx,by,dx,dy);    double ans=min(ad/r,min(ab/p+bd/r,min(ab/p+bc/r+cd/q,ac/r+cd/q)));    for(int i=1;i&amp;lt;=times;i++)&#123;        double tx=ax,ty=ay,px=bx,py=by,mx,my,T=20070831;        while(dis(tx,ty,px,py)&amp;gt;Exp)&#123;//走AB，中途直接前往D            mx=(tx+px)/2,my=(ty+py)/2;            double fu=dis(mx,my,ax,ay)/p+dis(mx,my,dx,dy)/r;            if(fu&amp;lt;ans)&#123;                ans=fu;                if(rand()%2) tx=mx,ty=my;                else px=mx,py=my;            &#125;            else &#123;                if(rand()&amp;lt;T) &#123;                    if(rand()%2)tx=mx,ty=my;                    else px=mx,py=my;                    T*=R;                &#125;            &#125;        &#125;        tx=cx,ty=cy,px=dx,py=dy,mx,my,T=20070831;        while(dis(tx,ty,px,py)&amp;gt;Exp)&#123;//A直接走到CD某点上            mx=(tx+px)/2,my=(ty+py)/2;            double fu=dis(mx,my,ax,ay)/r+dis(mx,my,dx,dy)/q;            if(fu&amp;lt;ans)&#123;                ans=fu;                if(rand()%2) tx=mx,ty=my;                else px=mx,py=my;            &#125;            else &#123;                if(rand()&amp;lt;T) &#123;                    if(rand()%2)tx=mx,ty=my;                    else px=mx,py=my;                    T*=R;                &#125;            &#125;        &#125;        tx=ax,ty=ay,px=bx,py=by,mx,my,T=20070831;        while(dis(tx,ty,px,py)&amp;gt;Exp)&#123;//走AB，中途前往CD            mx=(tx+px)/2,my=(ty+py)/2;            double fu=dis(mx,my,ax,ay)/p+dis(mx,my,cx,cy)/r+cd/q;            if(fu&amp;lt;ans)&#123;                ans=fu;                if(rand()%2) tx=mx,ty=my;                else px=mx,py=my;            &#125;            else &#123;                if(rand()&amp;lt;T) &#123;                    if(rand()%2)tx=mx,ty=my;                    else px=mx,py=my;                    T*=R;                &#125;            &#125;        &#125;        tx=cx,ty=cy,px=dx,py=dy,mx,my,T=20070831;        while(dis(tx,ty,px,py)&amp;gt;Exp)&#123;//走完AB再前往CD            mx=(tx+px)/2,my=(ty+py)/2;            double fu=dis(mx,my,bx,by)/r+dis(mx,my,dx,dy)/q+ab/p;            if(fu&amp;lt;ans)&#123;                ans=fu;                if(rand()%2) tx=mx,ty=my;                else px=mx,py=my;            &#125;            else &#123;                if(rand()&amp;lt;T) &#123;                    if(rand()%2)tx=mx,ty=my;                    else px=mx,py=my;                    T*=R;                &#125;            &#125;        &#125;    &#125;    printf(&amp;quot;%.2lf&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOI1999][POJ1190]生日蛋糕</title>
    <link href="/2018/10/14/%5BNOI1999%5D%5BPOJ1190%5D%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/"/>
    <url>/2018/10/14/%5BNOI1999%5D%5BPOJ1190%5D%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层生日蛋糕，每层都是一个圆柱体。<br>设从下往上数第i(1 &lt;= i &lt;= M)层蛋糕是半径为Ri, 高度为Hi的圆柱。当i &lt; M时，要求Ri &gt; Ri+1且Hi &gt; Hi+1。<br>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。<br>令Q = Sπ<br>请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。<br>（除Q外，以上所有数据皆为正整数）</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>有两行，第一行为N（N &lt;= 10000），表示待制作的蛋糕的体积为Nπ；第二行为M(1&lt;=M &lt;= 20)，表示蛋糕的层数为M。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>仅一行，是一个正整数S（若无解则S = 0）。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>1002</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>68</code></pre><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>圆柱公式<br>体积[latex]V = πR^2H[/latex]<br>侧面积[latex]A’ = 2πRH[/latex]<br>底面积[latex]A = πR^2[/latex]</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于这种没有多项式复杂度的题目显然最好的做法是搜索。<br>但是这可是道NOI的题目，所以我们还要进行一些剪枝，我这里可能不是所有的剪枝都用了，但足够了，POJ16ms  </p><p>首先我们搜索有5个状态，剩余层数，用了的表面积，用了的体积，当前层的高度，当前层的半径。  </p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><ol><li>上下界剪枝（范围剪枝）<br>我们在第dep层时，只需要在以下范围内枚举高度和半径即可：<br>[latex]R\in [dep,min(\lfloor \sqrt{N-v} \rfloor,r[dep+1]-1)][/latex]<br>[latex]H\in [dep,min(\lfloor \frac{N-v}{R^2} \rfloor,h[dep+1]-1)][/latex]</li><li>优化搜索顺序<br>上面的范围中，倒序枚举。</li><li>可行性剪枝/最优化剪枝（见注释）</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;int n,m,ans;int mincake[30];void dfs(int last,int s,int v,int h,int r)&#123;    if(last==0)&#123;        if(v==n&amp;amp;&amp;amp;s&amp;lt;ans)&#123;            ans=s;        &#125;        return;    &#125;    if(v+mincake[last-1]&amp;gt;n)return;//当前体积+下一层最小体积&amp;gt;总体积，可行性剪枝    if(2*(n-v)/r+s&amp;gt;=ans)return;//最优性剪枝    for(int i=r-1;i&amp;gt;=last;i--)&#123;        if(last==m)s=i*i;        int hh=min((n-v-mincake[last-1])/(i*i),h-1);        for(int j=hh;j&amp;gt;=last;j--)&#123;            dfs(last-1,s+2*i*j,v+i*i*j,j,i);        &#125;    &#125;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    ans=1&amp;lt;&amp;lt;30;    for(int i=1;i&amp;lt;=20;i++)mincake[i]=mincake[i-1]+i*i*i;//第i层最小的蛋糕体积    dfs(m,0,0,n+1,n+1);    if(ans==1&amp;lt;&amp;lt;30)cout&amp;lt;&amp;lt;0;    else cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[BZOJ2469][中山市选2010]简单数谜</title>
    <link href="/2018/10/13/%5BBZOJ2469%5D%5B%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892010%5D%E7%AE%80%E5%8D%95%E6%95%B0%E8%B0%9C/"/>
    <url>/2018/10/13/%5BBZOJ2469%5D%5B%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892010%5D%E7%AE%80%E5%8D%95%E6%95%B0%E8%B0%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>很多人都曾经听说过数独，但你是否听说过数谜（Karuro）呢？实际上，数谜是数独的更大（且更难）的兄弟问题，而且在日本也是非常受欢迎的。<br>数谜问题和填字游戏类似，不过它要填的不是文字而是数字。数谜游戏的目标是用1-9填满所有空格，且这些数字相加的和满足相应的要求（或者称为“提示”），且在同一栏（“栏”是指一些水平或者竖直的连续的空格，用于提示的格子不算空格）不能填重复的数字。当所有格子按要求被填满后，这个数谜就看作被解决了。图1和图2是一个可能的数谜游戏示例。<br>当然，直接求解数谜问题的话会比较困难。所以现在我们需要解决的是一个更简单的数谜问题。简单数谜的形状是一个(n+1）行乘(m+1)列的矩形。而简单数谜也只有两种要求，就是行要求和列要求，且分别处于第一行和第一列，其他格子则是空格，而左上角是忽略不计的。coolzzz同学爱好简单数谜，他已经给一些简单数谜填好了其中的一些空格。现在，他想寻求你的帮助，来帮他完成这些简单数谜。如图3所示，2和9是coolzzz同学已经填好的空格，图4则是一个基于图3 的一个可能的解答。<br><img src="https://www.lydsy.com/JudgeOnline/upload/201109/bbb.jpg"></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入包含多组测试数据。第一行包含一个正整数T，表示测试数据数目。每组数据第一行是n(n&lt;10)和m(m&lt;10)，表示数谜的形状的大小。接下来一行有n个整数，是相应的行要求；然后一行是m个整数，是相应的列要求。接下来的n行每行有m个小于10的非负整数，0表示该空格还没有被填数字，其他表示coolzzz同学已经填好的数字。输入数据保证未填数字的空格不会超过16个。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组测试数据，输出若干行。如果基于coolzzz已填的结果，该数谜只有一个解，则输出该解；如果不止一个解，则输出一行“Not unique.”；如果没有解，则输出一行“No answer.”。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>33 36 6 66 6 60 0 00 3 00 0 02 310 175 16 62 0 00 9 02 23 54 40 00 0</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>Not unique.2 7 13 9 5No answer.</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一道简单的爆搜题，和数独比起来稍微复杂一点（然而代码量更少），比较坑爹的就是如果不加一句话的话全部超时，加上去了就只要32ms<br>我们每次填只关心当前行满不满足要求，最后结束的时候再来判断是不是合法<br>具体数组作用可以用一个表格体现  </p><table><thead><tr><th align="center">数组（变量）名称</th><th align="center">数组（变量）作用</th></tr></thead><tbody><tr><td align="center">ans</td><td align="center">用来存放最终的结果</td></tr><tr><td align="center">num</td><td align="center">用来统计有多少个答案</td></tr><tr><td align="center">kakuro</td><td align="center">初始状态以及之后搜索时的状态</td></tr><tr><td align="center">x,y</td><td align="center">要求的行、列和</td></tr><tr><td align="center">X,Y</td><td align="center">当前行、列有哪些数是用过的</td></tr><tr><td align="center">val_x,val_y</td><td align="center">当前状态的行、列和</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN=15;int num;int ans[MAXN][MAXN],kakuro[MAXN][MAXN];int x[MAXN],y[MAXN];bool Y[MAXN][MAXN],X[MAXN][MAXN];int val_x[MAXN],val_y[MAXN];int n,m; inline void init()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    num=0;    memset(ans,0,sizeof(ans));    memset(kakuro,0,sizeof(kakuro));    memset(val_x,0,sizeof(val_x));    memset(val_y,0,sizeof(val_y));    memset(X,0,sizeof(X));    memset(Y,0,sizeof(Y));    for(int i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;y[i];    for(int j=1;j&amp;lt;=m;j++)cin&amp;gt;&amp;gt;x[j];    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=m;j++)&#123;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;kakuro[i][j]);            Y[i][kakuro[i][j]]=1;            X[j][kakuro[i][j]]=1;            val_y[i]+=kakuro[i][j];            val_x[j]+=kakuro[i][j];        &#125;    &#125;&#125; inline void dfs(int now_x,int now_y)&#123;    if(num&amp;gt;=2)return;    if(now_y&amp;gt;n)&#123;        bool ok=1;        for(int i=1;i&amp;lt;=m;i++)&#123;            if(val_x[i]!=x[i])&#123;                ok=0;                break;            &#125;        &#125;        if(ok)&#123;            num++;            memcpy(ans,kakuro,sizeof(kakuro));        &#125;    &#125;    else if (now_x &amp;gt; m) &#123;        if (val_y[now_y] == y[now_y]) &#123;//不加全超时            dfs(1, now_y + 1);        &#125;    &#125;    else if(kakuro[now_y][now_x]!=0)dfs(now_x+1,now_y);    else &#123;        for(int i=1;i&amp;lt;=9;i++)&#123;            if(!Y[now_y][i]&amp;amp;&amp;amp;!X[now_x][i]&amp;amp;&amp;amp;val_x[now_x]+i&amp;lt;=x[now_x]&amp;amp;&amp;amp;val_y[now_y]+i&amp;lt;=y[now_y])&#123;                Y[now_y][i]=X[now_x][i]=1;                val_x[now_x]+=i;                val_y[now_y]+=i;                kakuro[now_y][now_x]=i;                dfs(now_x+1,now_y);                Y[now_y][i]=X[now_x][i]=0;                val_x[now_x]-=i;                val_y[now_y]-=i;                kakuro[now_y][now_x]=0;            &#125;        &#125;    &#125;&#125; inline void out()&#123;    if(num==0)printf(&amp;quot;No answer.\n&amp;quot;);    else if(num==1)&#123;        for(int i=1;i&amp;lt;=n;i++)&#123;            for(int j=1;j&amp;lt;=m;j++)&#123;                printf(&amp;quot;%d &amp;quot;,ans[i][j]);            &#125;            printf(&amp;quot;\n&amp;quot;);        &#125;    &#125;    else &#123;        printf(&amp;quot;Not unique.\n&amp;quot;);    &#125;&#125; int main()&#123;//   freopen(&amp;quot;poi.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);    int t;    cin&amp;gt;&amp;gt;t;    int T=t;    while(t--)&#123;        // printf(&amp;quot;Case %d:\n&amp;quot;,T-t);        init();        dfs(1,1);        out();    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[USACO17OPEN]Modern Art</title>
    <link href="/2018/10/12/%5BUSACO17OPEN%5DModern%20Art/"/>
    <url>/2018/10/12/%5BUSACO17OPEN%5DModern%20Art/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Art critics worldwide have only recently begun to recognize the creative genius behind the great bovine painter, Picowso.</p><p>Picowso paints in a very particular way. She starts with an N \times NN×N blank canvas, represented by an N \times NN×N grid of zeros, where a zero indicates an empty cell of the canvas. She then draws N^2N<br>2<br>  rectangles on the canvas, one in each of N^2N<br>2<br>  colors (conveniently numbered 1 \ldots N^21…N<br>2<br> ). For example, she might start by painting a rectangle in color 2, giving this intermediate canvas:</p><p>2 2 2 0</p><p>2 2 2 0</p><p>2 2 2 0</p><p>0 0 0 0</p><p>She might then paint a rectangle in color 7:</p><p>2 2 2 0</p><p>2 7 7 7</p><p>2 7 7 7</p><p>0 0 0 0</p><p>And then she might paint a small rectangle in color 3:</p><p>2 2 3 0</p><p>2 7 3 7</p><p>2 7 7 7</p><p>0 0 0 0</p><p>Each rectangle has sides parallel to the edges of the canvas, and a rectangle could be as large as the entire canvas or as small as a single cell. Each color from 1 \ldots N^21…N<br>2<br>  is used exactly once, although later colors might completely cover up some of the earlier colors.</p><p>Given the final state of the canvas, please count how many of the N^2N<br>2<br>  colors could have possibly been the first to be painted.</p><p>小TY突然想画画，他有独特的艺术风格，他从N×N空白画布开始，其中0表示画布的空单元格。然后他会在画布上绘制恰好矩形，每个颜色是1到N×N中的一个。他每次可以选择任意一种未使用过的颜色进行绘画。例如，他可以从颜色2的矩形开始，画出这样的画布：</p><p>2 2 2 0</p><p>2 2 2 0</p><p>2 2 2 0</p><p>0 0 0 0</p><p>然后他可以用颜色7绘制一个矩形：</p><p>2 2 2 0</p><p>2 7 7 7</p><p>2 7 7 7</p><p>0 0 0 0</p><p>然后他可以在颜色3上绘制一个小矩形：</p><p>2 2 3 0</p><p>2 7 3 7</p><p>2 7 7 7</p><p>0 0 0 0</p><p>每个矩形都平行于画布边缘，而且矩形可以与整个画布一样大或者像一个单元一样小。每个颜色从1到正好使用一次，后来的颜色可能完全覆盖一些较早画上的颜色。</p><p>现在已知画布的最终状态，请计算有多少种颜色可能被第一个被画。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>The first line of input contains NN, the size of the canvas (1 \leq N \leq 10001≤N≤1000).</p><p>The next NN lines describe the final picture of the canvas, each containing NN integers that are in the range 0 \ldots N^20…N<br>2<br> . The input is guaranteed to have been drawn as described above, by painting successive rectangles in different colors.</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>Please output a count of the number of colors that could have been drawn first.</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><pre><code>42 2 3 02 7 3 72 7 7 70 0 0 0</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><pre><code>14</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>In this example, color 2 could have been the first to be painted. Color 3 clearly had to have been painted after color 7, and color 7 clearly had to have been painted after color 2. Since we don’t see the other colors, we deduce that they also could have been painted first.</p><p>感谢@ yhf_2015 的翻译</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>似乎没人写差分的代码，我这里就稍微介绍一下。<br>首先呢，这道题目很毒瘤，我花了好大功夫才读懂题目，无论它给你的矩阵里面有多少种颜色，它一共还是有[latex]N^2[/latex]种颜色，所以显然我们找不合法的颜色就行。<br>观察样例我们可以发现，2颜色的矩阵显然被7的覆盖了一部分，7肯定不能第一个涂，3又把7给覆盖掉了，3也不能第一个涂。<br>那么我们可以把问题转化成，有x个矩形（有些被覆盖了的矩形左上角右下角还是可以算到的），求重叠部分上面的矩形的颜色总数。  </p><p>当然用暴力就可以莽过去，但是遇到类似的问题用二维前缀和+二维差分显然是更优的。<br>参照一维差分的思想，我们可以在一个矩形的左上角+1，右下角+1，右边-1,下边-1<br>样例的差分数组：</p><pre><code> 1  0  0 -1 0  1  0  0 0  0 -1  1-1 -1  1  0</code></pre><p>这样子统计前缀和后，每个点的前缀和的值就是该点被覆盖的次数。<br>细节见代码注释。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN=1005,inf=0x7fffffff;int pos[MAXN*MAXN][4],ma[MAXN][MAXN],col,ans,sum[MAXN][MAXN],cnt;bool fla[MAXN*MAXN];int main()&#123;    int n;    cin&amp;gt;&amp;gt;n;    for(int i=0;i&amp;lt;=n*n;i++)&#123;//初始化        pos[i][0]=pos[i][1]=inf,pos[i][2]=pos[i][3]=0;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=n;j++)&#123;            cin&amp;gt;&amp;gt;col;            ma[i][j]=col;            if(col)&#123;//非0                if(pos[col][2]==0)cnt++;                if(i&amp;lt;pos[col][0])pos[col][0]=i;//矩形上边边界                if(j&amp;lt;pos[col][1])pos[col][1]=j;//矩形左边边界                if(i+1&amp;gt;pos[col][2])pos[col][2]=i+1;//矩形下边边界+1                if(j+1&amp;gt;pos[col][3])pos[col][3]=j+1;//矩形右边边界+1            &#125;        &#125;    &#125;    for(int i=1;i&amp;lt;=n*n;i++)&#123;        if(pos[i][0]==inf||pos[i][2]==0)continue;//枚举出现过的颜色        sum[pos[i][0]][pos[i][1]]++;//上面说的        sum[pos[i][2]][pos[i][3]]++;        sum[pos[i][0]][pos[i][3]]--;        sum[pos[i][2]][pos[i][1]]--;    &#125;    //前缀和    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=n;j++)&#123;            sum[i][j]+=sum[i][j-1];        &#125;    &#125;    for(int j=1;j&amp;lt;=n;j++)&#123;        for(int i=1;i&amp;lt;=n;i++)&#123;            sum[i][j]+=sum[i-1][j];        &#125;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=n;j++)&#123;            if(ma[i][j]&amp;amp;&amp;amp;sum[i][j]&amp;gt;1&amp;amp;&amp;amp;fla[ma[i][j]]==0)&#123;//每种颜色只能贡献一次答案                ans++,fla[ma[i][j]]=1;            &#125;        &#125;    &#125;    if(n!=1&amp;amp;&amp;amp;cnt==1)ans++;    printf(&amp;quot;%d\n&amp;quot;,n*n-ans);    return 0;&#125; </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[USACO17OPEN]Modern Art 2</title>
    <link href="/2018/10/11/%5BUSACO17OPEN%5DModern%20Art%202/"/>
    <url>/2018/10/11/%5BUSACO17OPEN%5DModern%20Art%202/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>小TY的同学HF也想创作艺术</p><p>HF只有一块长条状的画布(画条)，所以每一次涂色只能涂上连续几个单位的颜料，同样新的颜料可以完全覆盖旧的颜料</p><p>由于他的颜料同样非常傲娇，每次涂完要等上1day才能完全干，只有旧颜料干了以后才能用新颜料覆盖</p><p>现在小HF用了2017个年头终于画出了一个大作品，自己非常满意</p><p>现在他想复制这份作品</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Having become bored with standard 2-dimensional artwork (and also frustrated at others copying her work), the great bovine artist Picowso has decided to switch to a more minimalist, 1-dimensional style.</p><p>Although, her paintings can now be described by a 1-dimensional array of colors of length NN (1 \leq N \leq 100,0001≤N≤100,000), her painting style remains unchanged: she starts with a blank canvas and layers upon it a sequence of “rectangles” of paint, which in this 1-dimensional case are simply intervals. She uses each of the colors 1 \ldots N1…N exactly once, although just as before, some colors might end up being completely covered up by the end.</p><p>To Picowso’s great dismay, her competitor Moonet seems to have figured out how to copy even these 1-dimensional paintings, using a similar strategy to the preceding problem: Moonet will paint a set of disjoint intervals, wait for them to dry, then paint another set of disjoint intervals, and so on. Moonet can only paint at most one interval of each color over the entire process. Please compute</p><p>the number of such rounds needed for Moonet to copy a given 1-dimensional Picowso painting.</p><p>现在给你一个长度为N(N≤1e5)的画条</p><p>上面有若干种颜色，每位的数字表示一种颜色，0表示没有涂色</p><p>为了快捷，每次涂色可以用一种颜色填充一个区间，同一种颜色只能使用一次</p><p>每次可以涂色好几次，但是这些区间必须分别连续切两两不能相交</p><p>然后等待1day油漆干了后再同样操作，输出创作完成并全干了后的最少时间</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>The first line of input contains NN, and the next NN lines contain an integer in the range 0 \ldots N0…N indicating the color of each cell in the 1-dimensional painting (0 for a blank cell).</p><p>第一行为N，画条长度</p><p>一下N行每行一个数表示颜色</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>Please output the minimum number of rounds needed to copy this painting, or -1 if this could not have possibly been an authentic work of Picowso (i.e., if she could not have painted it using a layered sequence of intervals, one of each color).</p><p>输出一个整数表示最少天数。数据若不合法则输出-1</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><p>7<br>0<br>1<br>4<br>5<br>1<br>3<br>3</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><p>2</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>In this example, the interval of color 1 must be painted in an earlier round than the intervals of colors 4 and 5, so at least two rounds are needed.</p><h2 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h2><p>第一次可以把1颜色和3颜色填充，变成</p><p>0 1 1 1 1 3 3</p><p>等待1Day后再填充颜色4和颜色5，变成</p><p>0 1 4 5 1 3 3</p><p>在等待一Day油漆干了后创作完成</p><p>所以答案是2</p><p>感谢 @ Night_Aurora 贡献翻译</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一道大水题（容易想得太复杂了），一种颜色只能用一次，而且必须连续涂，那么被分开来的就一定是被其他颜色覆盖了的，而这段“其他颜色”又可以被覆盖，而且颜色块不能相交（例如0 1 2 1 2就是非法的），我们的问题就转化成了，最大有多少层嵌套的问题。<br>我们可以从前往后扫，用栈纪录当前层的颜色。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;const int MAXN=100005;int l[MAXN],r[MAXN];//某种颜色的开始点和结束点int zhan[MAXN],p;//当前层的颜色int a[MAXN],ans;//第i个位置的颜色int tmp;//其实可以不用它，它一直和p相等 int main()&#123;    int n;    cin&amp;gt;&amp;gt;n;    for(int i=1;i&amp;lt;=n;i++)&#123;        cin&amp;gt;&amp;gt;a[i];        if(!l[a[i]])l[a[i]]=i;        r[a[i]]=i;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(a[i]==0)&#123;            if(p)&#123;//如果0被夹在两个相同颜色块里面，肯定不合法                cout&amp;lt;&amp;lt;-1;                return 0;            &#125;            else continue;        &#125;        if(l[a[i]]==i)&#123;//该点是某种颜色的起始点            if(p&amp;amp;&amp;amp;r[a[zhan[p]]]&amp;lt;r[a[i]])&#123;//上面说到的交叉的情况，没这段会错一个点                cout&amp;lt;&amp;lt;-1;                return 0;            &#125;            zhan[++p]=i;//入栈            tmp++;            ans=max(ans,tmp); //更新答案        &#125;        if(r[a[i]]==i)&#123;//到了结束点，出栈            tmp--;            p--;        &#125;    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1967][NOIP2013]货车运输</title>
    <link href="/2018/10/11/%5B%E6%B4%9B%E8%B0%B7P1967%5D%5BNOIP2013%5D%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/"/>
    <url>/2018/10/11/%5B%E6%B4%9B%E8%B0%B7P1967%5D%5BNOIP2013%5D%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q 辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行有两个用一个空格隔开的整数n,m表示A国有n座城市和m条道路。</p><p>接下来m行每行3个整数 x, y, z每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。注意：x不等于y，两座城市之间可能有多条道路 。</p><p>接下来一行有一个整数 q，表示有 q 辆货车需要运货。</p><p>接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>共有q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出−1。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><pre><code>4 31 2 42 3 33 1 131 31 41 3</code></pre><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>3-13</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于 30%的数据，0 &lt; n &lt; 1,000,0 &lt; m &lt; 10,000,0 &lt; q&lt; 1,000；</p><p>对于 60%的数据，0 &lt; n &lt; 1,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 1,000；</p><p>对于 100%的数据，0 &lt; n &lt; 10,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 30,000,0 ≤ z ≤ 100,000</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote><p>部分内容摘自<kbd>2013年鉴</kbd></p></blockquote><p>其实这道题就是比较简单的图论题（作为最后一天的最后一题来讲）<br>首先对图做最大生成树（方法和最小生成树一样），得到的是一个森林。对于每一辆车，设其起点、终点分别为x,y，如果x,y连通，那么x,y在一棵树上，该火车最多能运送的货物为x,y之间的路径中的最小的边c。因为如果在原图中存在一条路径连接x,y,且所有的边的边权都大于c，那么最大生成树一定求错了（因为将该路径上的边加到生成树中去，必然形成包括c边在内的一个环，此时删除c边可以得到更大的生成树）<br>所以此题变成了求各个点对在树种路径上的最小边。  </p><h3 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h3><p>就是去实现上面的步骤，求LCA的时候暴力来求，不用倍增，可以AC（具体见暴力），如果是一条链的话会被卡，然而并没有这种数据。  </p><h3 id="方法二：倍增"><a href="#方法二：倍增" class="headerlink" title="方法二：倍增"></a>方法二：倍增</h3><p>此时我们可以用倍增的子项求某两个点的路径上的最小边。首先纪录每个点向上（向树根）走[latex]v(v=2^0,2^1,\dots)[/latex]步所经过的路径中最小边是多少。对于一个询问x,y，可以求出其最近公共祖先z，然后求x，z之间的最小边和y，z之间的最小边。<br>时间复杂度为[latex]O(mlogm+n+logn)[/latex]</p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>标称用的方法并不是倍增法，只需要在最大生成树的里面加一个求解的询问就行。首先用一个数组ans表示最终的答案，ans[i]表示第i个询问最多能运的货物数量。再用kruskal算法中，每将一条边加到最大生成树里面，那么这条边会将连个点集合并到一起。<br>如果某个询问i，他的两个点x，y分别属于这两个点集，那么这个询问的答案就是新加入的这条边的边权（因为此时x,y已经在一棵树中，所以x,y之间有路径。由于Kruskal求最大生成树时是由边权从大到小加入的，所以当前边是路径上边权最小的边）我们只需要在每个电商挂一个询问的链，每次询问时将两个询问的链合并到一起，合并的时候选取询问较少的那个链进行扫描并更新答案。所以对链的操作的时间复杂度为[合并次数+每次合并时扫描的询问个数和]。时间的小号主要在扫描，但是我们可以发现，每次扫描都只扫描了较少的那一部分，设长度为L，并且合并后询问的长度增长到2L以上。所以总的时间复杂度为[latex]O(mlogm+qlogq)[/latex]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>LCA暴力，代码来自本校神犇<kbd>yanyu</kbd></p><pre><code class="cpp">#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int maxn=11000;const int maxm=51000;int head[maxn],Next[maxm&amp;lt;&amp;lt;1],ver[maxm&amp;lt;&amp;lt;1],weigh[maxm&amp;lt;&amp;lt;1];int f[maxn],fa[maxn],dis[maxn],deep[maxn];int n,m,q,tot;struct node&#123;    int x,y,weigh;&#125;edge[maxm&amp;lt;&amp;lt;1]; inline void add(int x,int y,int w)&#123;    ver[++tot]=y;weigh[tot]=w;Next[tot]=head[x];head[x]=tot;&#125; bool cmp(node a,node b)&#123;    return a.weigh &amp;gt; b.weigh;    &#125; int find(int x)&#123;    return fa[x]==x?x:fa[x]=find(fa[x]);&#125; void dfs(int x)&#123;    for(int i=head[x];i;i=Next[i])&#123;        int y=ver[i];        if(deep[y]==0)&#123;            dis[y]=weigh[i];            deep[y]=deep[x]+1;            f[y]=x;            dfs(y);        &#125;    &#125;&#125; int lca(int x,int y)&#123;    int ans=1&amp;lt;&amp;lt;30;    if(deep[x]&amp;gt;deep[y]) swap(x,y);    while(deep[x]!=deep[y])&#123;        ans=min(ans,dis[y]);        y=f[y];    &#125;    while(x!=y)&#123;        ans=min(ans,min(dis[x],dis[y]));        x=f[x],y=f[y];    &#125;    return ans;&#125; int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=1;i&amp;lt;=n;i++) fa[i]=i;    for(int i=1;i&amp;lt;=m;i++)        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;edge[i].x,&amp;amp;edge[i].y,&amp;amp;edge[i].weigh);    sort(edge+1,edge+m+1,cmp);    for(int i=1;i&amp;lt;=m;i++)&#123;        int fx=find(edge[i].x);        int fy=find(edge[i].y);        if(fx!=fy)&#123;            fa[fx]=fy;            add(edge[i].x,edge[i].y,edge[i].weigh);            add(edge[i].y,edge[i].x,edge[i].weigh);        &#125;    &#125;    for(int i=1;i&amp;lt;=n;i++)        if(deep[i]==0) dfs(i);    scanf(&amp;quot;%d&amp;quot;,&amp;amp;q);    for(int i=1,x,y;i&amp;lt;=q;i++)&#123;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        if(find(x)!=find(y)) printf(&amp;quot;-1\n&amp;quot;);        else printf(&amp;quot;%d\n&amp;quot;,lca(x,y));    &#125;    return 0;&#125;</code></pre><p>倍增</p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAXN =50005;int dep[MAXN];int n,m;struct node&#123;    int x,y,w;&#125;edge[MAXN];int fa[MAXN];int Nt[MAXN],Head[MAXN],wight[MAXN],to[MAXN],tot;int f[20005][21],w[20005][21];void add(int x,int y,int v)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    wight[tot]=v;    Head[x]=tot;&#125;int Find(int x)&#123;    if(fa[x]!=x)fa[x]=Find(fa[x]);    return fa[x]; &#125;bool cmp(node a,node b)&#123;    return a.w&amp;gt;b.w;&#125;void dfs(int x)&#123;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(dep[y])continue;        dep[y]=dep[x]+1;        f[y][0]=x;        w[y][0]=wight[i];        dfs(y);    &#125;&#125;void kruskal()&#123;    sort(edge+1,edge+m+1,cmp);    for(int i=1;i&amp;lt;=n;i++)fa[i]=i;    for(int i=1;i&amp;lt;=m;i++)&#123;        int fa_x=Find(edge[i].x),fa_y=Find(edge[i].y);        if(fa_x==fa_y)continue;        fa[fa_x]=fa_y;        add(edge[i].x,edge[i].y,edge[i].w);        add(edge[i].y,edge[i].x,edge[i].w);    &#125;&#125;int lca(int x,int y)&#123;    if(Find(x)!=Find(y)) return -1;    int ans=1&amp;lt;&amp;lt;30;    if(dep[x]&amp;gt;dep[y])swap(x,y);    for(int i=20;i&amp;gt;=0;i--)&#123;        if(dep[f[y][i]]&amp;gt;=dep[x])&#123;            ans=min(ans,w[y][i]);            y=f[y][i];        &#125;    &#125;    if(x==y)return ans;    for(int i=20;i&amp;gt;=0;i--)&#123;        if(f[x][i]!=f[y][i])&#123;            ans=min(ans,min(w[x][i],w[y][i]));            y=f[y][i];            x=f[x][i];        &#125;    &#125;    ans=min(ans, min(w[x][0], w[y][0]));    return ans;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;    for(int i=1;i&amp;lt;=m;i++)&#123;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;edge[i].x,&amp;amp;edge[i].y,&amp;amp;edge[i].w);    &#125;    kruskal();    int q;    cin&amp;gt;&amp;gt;q;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(!dep[i])&#123;            dep[i]=1;            dfs(i);            f[i][0]=i;            w[i][0]=1&amp;lt;&amp;lt;30;        &#125;    &#125;    for(int i=1;i&amp;lt;=20;i++)&#123;        for(int j=1;j&amp;lt;=n;j++)&#123;            f[j][i]=f[f[j][i-1]][i-1];            w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]);        &#125;    &#125;    for(int i=1;i&amp;lt;=q;i++)&#123;        int x,y;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        printf(&amp;quot;%d\n&amp;quot;,lca(x,y));    &#125;    return 0;&#125; </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[vijos1056]图形面积</title>
    <link href="/2018/10/09/%5Bvijos1056%5D%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
    <url>/2018/10/09/%5Bvijos1056%5D%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>桌面上放了N个平行于坐标轴的矩形，这N个矩形可能有互相覆盖的部分，求它们组成的图形的面积。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行为一个数N（1≤N≤100），表示矩形的数量。下面N行，每行四个整数，分别表示每个矩形的左下角和右上角的坐标，坐标范围为–10^8到10^8之间的整数。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出只有一行，一个整数，表示图形的面积。</p><h2 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><pre><code>31 1 4 32 -1 3 24 0 5 2</code></pre><h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><pre><code>10</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里有篇<a href="http://www.matrix67.com/blog/archives/108">很好的文章</a>，对于深入理解有帮助<br>对于这道题目，第一想法就是用bool数组标记，最后统和，但是奈何数据范围不允许。<br>可以用扫描线+线段树维护，但是总觉得有点大动干戈。<br>而“离散化”这一奇妙的思想能帮我们优雅地解决这道题（然而样例不能很好体现）  </p><p>我们首先来看看样例<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF1.png"><br>其中一样的颜色的点为一对输入（一个矩形），我们取出它们的横纵坐标，去重，排序，然后再去枚举，就得到了那些黑色的点。（有些和有颜色的点重复了）<br>其实到了这一步我们已经离散化了（还没明白?别急，先往下看）<br>于是我们枚举每一个黑色的点，让它和它右上方的黑点构成一个矩形，如果这个矩形在任意输入矩形内部，则对答案有贡献<br>这样子我们就做到了不重不漏(黑点枚举出来的矩形不重复，并且黑点构成的全部矩形肯定把输入矩形囊括在内)<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF3.png"></p><p>到这里貌似就结束了，但是这种方法看上去还是在数格子？<br>让我们把输入改成  </p><pre><code>31 1 4 42 -1 3 34 0 5 3</code></pre><p>再看看图像<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF2.png"><br>我们的枚举量并没有随着坐标范围变大而变大，并且还是做到了不重不漏，其原因就是我们在枚举黑点的时候，本来是2的距离，转化成了该点与上个点相差2，而空间上这两个点还是相邻的，这就是离散化。  </p><p>上面已经解释得很清楚了，代码就不写注释了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAXN=203;long long x[MAXN],y[MAXN],x1[MAXN],x2[MAXN],y1[MAXN],y2[MAXN];long long S,ans;int n;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%lld%lld%lld%lld&amp;quot;,&amp;amp;x1[i],&amp;amp;y1[i],&amp;amp;x2[i],&amp;amp;y2[i]);        x[2*i-1]=x1[i];        y[2*i-1]=y1[i];        x[2*i]=x2[i];        y[2*i]=y2[i];    &#125;    sort(x+1,x+2*n+1);    sort(y+1,y+2*n+1);//这里忘了去重，如果有重复的，(x[i+1]-x[i])*(y[j+1]-y[j])必定有一项为0，对答案没贡献    for(int i=1;i&amp;lt;=2*n-1;i++)&#123;        for(int j=1;j&amp;lt;=2*n-1;j++)&#123;            S=(x[i+1]-x[i])*(y[j+1]-y[j]);            for(int k=1;k&amp;lt;=n;k++)&#123;                if(x[i]&amp;gt;=x1[k]&amp;amp;&amp;amp;y[j]&amp;gt;=y1[k]&amp;amp;&amp;amp;x[i+1]&amp;lt;=x2[k]&amp;amp;&amp;amp;y[j+1]&amp;lt;=y2[k])&#123;                    ans+=S;                    break;                &#125;            &#125;        &#125;    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125; </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【留言板】</title>
    <link href="/2018/10/08/%E3%80%90%E7%95%99%E8%A8%80%E6%9D%BF%E3%80%91/"/>
    <url>/2018/10/08/%E3%80%90%E7%95%99%E8%A8%80%E6%9D%BF%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>欢迎留言~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[POJ3191] The Moronic Cowmpouter</title>
    <link href="/2018/10/08/%5BPOJ3191%5D%20The%20Moronic%20Cowmpouter/"/>
    <url>/2018/10/08/%5BPOJ3191%5D%20The%20Moronic%20Cowmpouter/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Inexperienced in the digital arts, the cows tried to build a calculating engine (yes, it’s a cowmpouter) using binary numbers (base 2) but instead built one based on base negative 2! They were quite pleased since numbers expressed in base -2 do not have a sign bit.</p><p>You know number bases have place values that start at 1 (base to the 0 power) and proceed right-to-left to base^1, base^2, and so on. In base -2, the place values are 1, -2, 4, -8, 16, -32, … (reading from right to left). Thus, counting from 1 goes like this: 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001, and so on.</p><p>Eerily, negative numbers are also represented with 1’s and 0’s but no sign. Consider counting from -1 downward: 11, 10, 1101, 1100, 1111, and so on.</p><p>Please help the cows convert ordinary decimal integers (range -2,000,000,000 .. 2,000,000,000) to their counterpart representation in base -2.</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>A single integer to be converted to base -2</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>A single integer with no leading zeroes that is the input integer converted to base -2. The value 0 is expressed as 0, with exactly one 0.</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><pre><code>-13</code></pre><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>110111</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>Hint<br>Explanation of the sample:<br>Reading from right-to-left:<br>1*1 + 1*-2 + 1*4 + 0*-8 +1*16 + 1*-32 = -13</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个十进制[latex]N(−2,000,000,000≤N≤2,000,000,000)[/latex]，输出它的[latex]−2[/latex]进制数</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>平常我们很少会涉及到负进制，按照提示所给内容，我们应该很快能想到第一种做法，<br>第一种想法，我们去枚举每一个负二进制数，对于每一个负二进制数，我们将它转换成十进制数，看看是不是一样。<br>代码如下：</p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;int n;long long p[32]; void init()&#123;    cin&amp;gt;&amp;gt;n;    p[0]=1;    for(int i=1;i&amp;lt;=31;i++)&#123;        p[i]=p[i-1]*-2;    &#125;&#125; inline bool jud(int num)&#123;    int res=0,cnt=0;    while(num)&#123;        if(num&amp;amp;1)res+=p[cnt];        ++cnt;        num&amp;gt;&amp;gt;=1;    &#125;    if(res==n)return 1;    return 0;&#125; void out(int num)&#123;    int tmp[200],t=0;    while(num)&#123;        if(num&amp;amp;1)tmp[++t]=1;        else tmp[++t]=0;        num&amp;gt;&amp;gt;=1;    &#125;    for(int i=t;i&amp;gt;=1;i--)printf(&amp;quot;%d&amp;quot;,tmp[i]);&#125; int main()&#123;    init();    for(long long i=1;i&amp;lt;=2000000000LL;i++)&#123;        if(jud(i))&#123;            // cout&amp;lt;&amp;lt;&amp;quot;!!&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;            out(i);            break;        &#125;    &#125;    return 0;&#125;</code></pre><p>然而上面的做法会T，那么我们能不能直接从十进制算到负二进制呢？<br>这个需要好好观察一下提示，<br>我们发现如果要确定当前位是0还是1，只要对下一个为1时取余就知道了，如果余数为0，那么当前这个数自然是后面位的倍数了，取0，否则就取1.</p><p>然后减去当前还剩的数，继续往后走。</p><p>最后减到0就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;const int MAXN=1e5+7;const int inf =1e9;int ans[1000];long long n;long long pw(int a,int b)&#123;//很普通的快速幂    long long sum=1;    long long base=a;    while(b)&#123;        if(b&amp;amp;1)sum*=base;        base*=base;        b&amp;gt;&amp;gt;=1;    &#125;    return sum;&#125;int main()&#123;    scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n);    int top=0;    if(!n)ans[top++]=0;//0的时候特判    while(n)&#123;        if(n%(pw(-2,top+1)))ans[top]=1;        else ans[top]=0;        n-=ans[top]*pw(-2,top);//相当于不断把n这个10进制数拆分成-2进制数        top++;    &#125;    while(top)printf(&amp;quot;%d&amp;quot;,ans[--top]);    return 0;&#125;</code></pre><p>另外，这里还有一道题和这个几乎一样<br><kbd><a href="https://www.luogu.org/problemnew/show/UVA11121">UVA11121 Base -2</a></kbd></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LOJ10022]埃及分数</title>
    <link href="/2018/10/08/%5BLOJ10022%5D%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/"/>
    <url>/2018/10/08/%5BLOJ10022%5D%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在古埃及，人们使用单位分数的和（形如1/a的，a是自然数）表示一切有理数。如：2/3=1/2+1/6，但不允许2/3=1/3+1/3，因为加数中有相同的。对于一个分数a/b，表示方法有很多种，但是哪种最好呢？首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数值越大越好。<br>    如：</p><pre><code>19/45=1/3+1/12+1/18019/45=1/3+1/15+1/4519/45=1/3+1/18+1/3019/45=1/4+1/6+1/18019/45=1/5+1/6+1/18</code></pre><p>最好的是最后一种，因为1/18比1/180,1/45,1/30,1/180都大。<br>给出a,b（0&lt;a&lt;b&lt;1000），编程计算最好的表达方式。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>只有一行，为a,b。（0&lt;a&lt;b&lt;1000）</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>若干个数，自小到大排列，依次是单位分数的分母，每个数字以空格隔开。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>19 45</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>5 6 18</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://baike.baidu.com/item/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/634864?fr=aladdin">埃及分数</a>真的是一个神奇的东西，网上很多题解直接就将IDA*算法，但是为什么拿到这道题就会想到IDA*呢？</p><p>我们可以发现，本题的特别之处在于它的状态空间是<strong>无限大</strong>的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;cstdio&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;cmath&amp;gt;#define MAXN 5100typedef long long ll;using namespace std;ll a,b;ll dep=0;ll ans[MAXN],v[MAXN];inline ll gcd(ll x,ll y)&#123;    return y==0? x : gcd(y,x%y);&#125;inline ll G_first(ll xx,ll yy) &#123;//满足1/c&amp;lt;=xx/yy的最小c    return yy/xx+1;&#125;inline bool better() &#123;    for(int i=dep;i&amp;gt;=1;i--)         if(ans[i]!=v[i]) return ans[i]==0||v[i]&amp;lt;ans[i];    return false; &#125;inline bool dfs(ll now,ll from,ll xx,ll yy)&#123;    if(now==dep) &#123;        if(yy%xx) return false;//保证最后一个的xx为1（约分后        v[now]=yy/xx;        if(better())            for(ll i=1;i&amp;lt;=dep;i++) ans[i]=v[i];          return true;     &#125;    bool ok=false;    from=max(from,G_first(xx,yy));    for(ll i=from; ;i++)&#123;        // (dep-now+1)/i &amp;lt;= xx/yy 移项得        if(yy*(dep-now+1)&amp;lt;=i*xx) break;//如果剩下的分数全是1/i加起来也无法超过xx/yy ,则剪去        v[now]=i;        ll y2=yy*i,x2=xx*i-yy;        ll g=gcd(x2,y2);        if(dfs(now+1,i+1,x2/g,y2/g)) ok=true;    &#125;    return ok;&#125;int main()&#123;    scanf(&amp;quot;%lld%lld&amp;quot;,&amp;amp;a,&amp;amp;b);    else &#123;        bool ok=false;        for(dep=1;;dep++)&#123;            memset(ans,0,sizeof(ans));            if(dfs(1,G_first(a,b),a,b))&#123;                ok=true; break;            &#125;        &#125;        if(ok) for(int i=1;i&amp;lt;=dep;i++) printf(&amp;quot;%d &amp;quot;,ans[i]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LOJ10181]绿色通道</title>
    <link href="/2018/10/07/%5BLOJ10181%5D%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93/"/>
    <url>/2018/10/07/%5BLOJ10181%5D%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.yzoj.fun/upload/image/20180826/20180826204018_13150.png"><br><a href="https://loj.ac/problem/10181">传送门</a></p><p>一看到求什么“最大的最小值”，“最小的最大值”就马上想到二分（还有可能是单调队列）<br>再仔细看看题目，貌似没什么头绪，但答案似乎存在单调性，果断二分。<br>答案肯定在0到n范围内。<br>设[latex]f[i][/latex]为做到第[latex]i[/latex]个作业时所需要花的最短时间。<br>假如我们可以空[latex]k[/latex]道题（二分出来的）<br>[latex]f[i]=min(f[i],f[j]+a[i])[/latex]<br>其中 $$i-k+1 \le j &lt; i$$</p><pre><code class="cpp">//90分，超时#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN=50004;int n,t;int a[MAXN],f[MAXN];  bool check(int k)&#123;    memset(f,0x3f,sizeof(f));    f[0]=0;    for(int i=1;i&amp;lt;=k;i++)f[i]=a[i];    for(int i=k+1;i&amp;lt;=n;i++)&#123;        for(int j=i-k-1;j&amp;lt;i;j++)&#123;            f[i]=min(f[i],f[j]+a[i]);        &#125;    &#125;    int ans=1&amp;lt;&amp;lt;30;    for(int i=n-k;i&amp;lt;=n;i++)ans=min(f[i],ans);    if(ans&amp;lt;=t)return 1;    return 0;&#125;  int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;t;    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);    int l=0,r=n,ans=0;    while(l&amp;lt;=r)&#123;        int mid=(l+r)/2;        if(check(mid))r=mid-1,ans=mid;        else l=mid+1;    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre><p>如果你想要满分，就要减少枚举量，就是减少枚举j的次数。<br>我们要维护一个区间最小数，可以用线段树来写，我这里采用的是优先队列。<br>采用优先队列有一个原则，那就是队列里的元素要单调，并且还要有另一个条件限制它们，我比较喜欢叫做“保质期”（因为保质期是不变的但是时间在变）<br>这个题目单调队列里的元素的保质期就是下标，如果他的下表不满足上面的枚举j的条件，这个元素就“过期”了  </p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;deque&amp;gt;using namespace std;const int MAXN=50004;int n,t;int a[MAXN],f[MAXN];deque&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt;q;  bool check(int k)&#123;    memset(f,0x3f,sizeof(f));    while(q.size())q.pop_front();    f[0]=0;    //q.push_back(make_pair(0,0));加上这句话就不用分开处理    for(int i=1;i&amp;lt;=k+1;i++)&#123;        f[i]=a[i];        while(q.size()&amp;amp;&amp;amp;q.back().first&amp;gt;=a[i])q.pop_back();        q.push_back(make_pair(a[i],i));    &#125;    for(int i=k+2;i&amp;lt;=n;i++)&#123;        // cout&amp;lt;&amp;lt;q.front().first&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;q.front().second&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;i-k-1&amp;lt;&amp;lt;endl;        while(q.size()&amp;amp;&amp;amp;q.front().second&amp;lt;i-k-1)q.pop_front();        f[i]=min(f[i],q.front().first+a[i]);        while(q.size()&amp;amp;&amp;amp;q.back().first&amp;gt;=f[i])q.pop_back();        q.push_back(make_pair(f[i],i));    &#125;    int ans=1&amp;lt;&amp;lt;30;    for(int i=n-k;i&amp;lt;=n;i++)ans=min(f[i],ans);    if(ans&amp;lt;=t)return 1;    return 0;&#125;  int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;t;    for(int i=1;i&amp;lt;=n;i++)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);    int l=0,r=n,ans=0;    while(l&amp;lt;=r)&#123;        int mid=(l+r)/2;        if(check(mid))r=mid-1,ans=mid;        else l=mid+1;    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LOJ10159]旅游规划</title>
    <link href="/2018/10/07/%5BLOJ10159%5D%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
    <url>/2018/10/07/%5BLOJ10159%5D%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.yzoj.fun/upload/image/20180827/20180827090543_13812.png"><br><a href="https://loj.ac/problem/10159">传送门</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树的直径不止一条，而题目要求我们把所有直径上的点给输出来。  </p><table><thead><tr><th align="center">数组名</th><th align="center">数组作用</th></tr></thead><tbody><tr><td align="center">d1</td><td align="center">i点到叶子节点的最长距离</td></tr><tr><td align="center">d2</td><td align="center">i点到叶子节点的次长距离</td></tr><tr><td align="center">d3</td><td align="center">i点向除子树外的最远距离</td></tr></tbody></table><p>就拿样例来说，下面这个图应该很清楚了（红色的是树的直径）<br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92.jpg">  </p><p>显然，如果一个点满足d1+d2=树的直径或者d1+d3=树的直径，那么这个点肯定是树的直径上的点  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;const int MAXN=200005;int n;int Nt[MAXN&amp;lt;&amp;lt;1],Head[MAXN&amp;lt;&amp;lt;1],to[MAXN&amp;lt;&amp;lt;1],tot;int d1[MAXN],d2[MAXN],d3[MAXN],maxx; inline int read()&#123;    char ch;ch=getchar();    int x=0,f=1;    while(ch&amp;lt;&amp;#039;0&amp;#039;||ch&amp;gt;&amp;#039;9&amp;#039;)&#123;if(ch==&amp;#039;-&amp;#039;)f=-1;ch=getchar();&#125;    while(ch&amp;gt;=&amp;#039;0&amp;#039;&amp;amp;&amp;amp;ch&amp;lt;=&amp;#039;9&amp;#039;)&#123;x=x*10+ch-&amp;#039;0&amp;#039;;ch=getchar();&#125;    return x*f;&#125; void add(int x,int y)&#123;    Nt[++tot]=Head[x];    to[tot]=y;    Head[x]=tot;&#125; void dfs(int x,int fa)&#123;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(y==fa) continue;        dfs(y,x);        if(d1[y]+1&amp;gt;d1[x])&#123;            d2[x]=d1[x];            d1[x]=d1[y]+1;        &#125;        else if(d1[y]+1&amp;gt;d2[x]) d2[x]=d1[y]+1;    &#125;    if(d1[x]+d2[x]&amp;gt;maxx) maxx=d1[x]+d2[x];&#125; void dfs2(int x,int fa)&#123;    for(int i=Head[x];i;i=Nt[i])&#123;        int y=to[i];        if(y==fa) continue;        if(d1[y]+1==d1[x]) d3[y]=max(d3[x],d2[x])+1;//如果子节点是d1更新的方向，那么就在父节点的d2,d3中取最大值        else d3[y]=max(d3[x],d1[x])+1;        dfs2(y,x);    &#125;&#125; int main()&#123;    n=read();    int x,y;    for(int i=1;i&amp;lt;n;i++)&#123;        x=read(),y=read();        add(x,y);        add(y,x);    &#125;    dfs(0,0);    dfs2(0,0);    for(int i=0;i&amp;lt;n;++i) if(d3[i]+d1[i]==maxx||d1[i]+d2[i]==maxx) printf(&amp;quot;%d\n&amp;quot;,i);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LOJ10220]Fibonacci 第 n 项</title>
    <link href="/2018/10/06/%5BLOJ10220%5DFibonacci%20%E7%AC%AC%20n%20%E9%A1%B9/"/>
    <url>/2018/10/06/%5BLOJ10220%5DFibonacci%20%E7%AC%AC%20n%20%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道Fibonacci数列把，[latex]f_1=1,f_2=1,f_3=2,f_4=3,f_n=f_{n-1}+f_{n-2}[/latex]<br>现在问题很简单，输入[latex]n[/latex]和[latex]m[/latex]，求[latex]f_n mod m[/latex]</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入[latex]n,m[/latex]</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出[latex]f_n mod m[/latex]</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>5 1000</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>5</code></pre><h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于[latex]100%[/latex]的数据，[latex]1\le n \le 2\times 10^9,1\le m\le 10^9 + 10[/latex]</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看到这个数据范围，就知道这肯定不能够一般地递推了。<br>于是我们要介绍一个工具来帮助我们计算这个数列——<strong>矩阵乘法</strong><br>两个矩阵的乘法仅当第一个矩阵A的列数和第二个矩阵B的行数相等的时候才能定义<br>就举个例子好了</p><center>[latex]\begin{bmatrix}1&0&2\\ -1&3&1\end{bmatrix} \times \begin{bmatrix} 3&1 \\ 2&1\\ 1&0\end{bmatrix}=\begin{bmatrix}(1\times3+0\times2+2\times0)&(1\times1+0\times1+2\times0) \\ (-1\times3+3\times2+1\times1)&(-1\times1+3\times1+1\times0)\end{bmatrix}[/latex]</center><p>那么我们根据这个性质，可以定义两个矩阵，一个是<strong>数值矩阵</strong>用来存贮递推时的数据，需要有一个初始值，还有一个是<strong>递推矩阵</strong>用来定义如何递推。<br>在这道里，我们可以初始化数值矩阵为：  </p><center>[latex]\begin{bmatrix}f_2&0\\f_1&0\end{bmatrix}[/latex]  </center>而我们定义递推矩阵为：<center>[latex]\begin{bmatrix}1&1\\1&0\end{bmatrix}[/latex]</center><p>每次用数值矩阵乘递推矩阵，得到的新矩阵中，数列的下标正好是原来的下标+1，递推得以进行。（请读者自己动手体会一下，不然你永远只为停留在“哇，这个算法好神奇”这个层面）<br>而对于乘法的递推，我们很容易就想到快速幂，于是这道题就完美解决。<br>至于如何定义<strong>数值矩阵</strong>和<strong>递推矩阵</strong>，我认为还是要多自己思考，多做几次就会了。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int n,mod;long long res[3][3],mul[3][3]; void mul_res()&#123;    long long tmp[3][3];    memset(tmp,0,sizeof(tmp));    for(int i=1;i&amp;lt;=2;i++)&#123;        for(int j=1;j&amp;lt;=2;j++)&#123;            for(int k=1;k&amp;lt;=2;k++)&#123;                tmp[i][j]=(tmp[i][j]+mul[i][k]*res[k][j])%mod;            &#125;        &#125;    &#125;    memcpy(res,tmp,sizeof(tmp));&#125; void mul_mul()&#123;    long long tmp[3][3];    memset(tmp,0,sizeof(tmp));    for(int i=1;i&amp;lt;=2;i++)&#123;        for(int j=1;j&amp;lt;=2;j++)&#123;            for(int k=1;k&amp;lt;=2;k++)&#123;                tmp[i][j]=(tmp[i][j]+mul[i][k]*mul[k][j])%mod;            &#125;        &#125;    &#125;    memcpy(mul,tmp,sizeof(tmp));&#125; int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;mod;    if(n&amp;lt;=2)&#123;cout&amp;lt;&amp;lt;1;return 0;&#125;    res[1][1]=res[2][1]=1;    mul[1][1]=mul[2][1]=mul[1][2]=1;    n-=2;//初始状态我们可以认为已经是f2的时候了    while(n)&#123;        if(n&amp;amp;1)mul_res();        mul_mul();        n&amp;gt;&amp;gt;=1;    &#125;    cout&amp;lt;&amp;lt;res[1][1];    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[BZOJ1041]HAOI2008圆上的整点</title>
    <link href="/2018/10/05/%5BBZOJ1041%5DHAOI2008%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/"/>
    <url>/2018/10/05/%5BBZOJ1041%5DHAOI2008%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求一个给定的圆([latex]x^2+y^2=r^2[/latex])，在圆周上有多少个点的坐标是整数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>r</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>整点个数</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>4</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>[latex]n\le2000000000[/latex]</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>转自<a href="http://www.cppblog.com/zxb/archive/2010/10/18/130330.html">这篇文章</a><br>这里先只考虑x，y都大于0的情况</p><p>如果[latex]x^2+y^2=r^2[/latex]，则<a href="r-x">latex</a>(r+x)=y^2[/latex]</p><p>令[latex]d=gcd(r-x,r+x)[/latex]</p><p>则<a href="r-x">latex</a>/d[/latex]与<a href="r+x">latex</a>/d[/latex]一定互质，二者相乘为完全平方数，则二者一定都为完全平方数</p><p>令[latex]r-x=d\times a^2[/latex],[latex]r+x=d\times b^2[/latex]</p><p>则显然有a,b互质，a&lt;b</p><p>其中$$x=\frac{d(b^2-a^2)}{2}$$<br>$$y=d\times a\times b$$<br>$$r=\frac{d\times (a^2+b^2)}{2}$$</p><p>枚举[latex]2r[/latex]的因数[latex]d[/latex]，对于每个d我们用[latex]O(\sqrt{\frac{r}{d}})[/latex]的时间枚举[latex]a[/latex] 代入[latex]r[/latex]的计算式得出[latex]b^2[/latex] 计算[latex]b^2[/latex]是否为完全平方数及[latex]a^2[/latex]与[latex]b^2[/latex]是否互质</p><p>这样可以枚举出一个象限内的整点个数 然后输出<a href="ans+1">latex</a>\times 4[/latex]即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;typedef long long ll;ll r,ans;ll gcd(ll a,ll b)&#123;    return b? gcd(b,a%b):a;&#125;void solve(ll x)&#123;    ll top=(ll)sqrt(x/2);    for(int a=1;a&amp;lt;=top;a++)&#123;        ll A=a*a;        ll B=x-A;        ll b=(ll)sqrt(B);        if(gcd(A,B)==1&amp;amp;&amp;amp;B==b*b&amp;amp;&amp;amp;A!=B)&#123;            ans++;        &#125;    &#125;&#125;int main()&#123;    cin&amp;gt;&amp;gt;r;    ll top=(ll)sqrt(2*r);    for(int i=1;i&amp;lt;=top;i++)&#123;        if(2*r%i==0)&#123;            solve(i);            solve(2*r/i);        &#125;    &#125;    cout&amp;lt;&amp;lt;ans*4+4;//+4个坐标轴上的点    return 0;&#125;</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>这题还有一个更美妙的解法，0msAC，具体就是下面这个视频<br>如果你不想花时间看的话也可以看<a href="http://chty.coding.me/blog/2018/05/17/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0%E4%B8%8E%E5%B9%B3%E6%96%B9%E5%92%8C%E9%97%AE%E9%A2%98/">这篇文章</a>，基本上就是整个视频对我们有用的知识的提炼  </p><iframe src="//player.bilibili.com/player.html?aid=12131743&cid=20005978&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>代码如下:</p><pre><code class="cpp">#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;int main()&#123;    long long r;    int ans=1;    cin&amp;gt;&amp;gt;r;    for(int i=2;i&amp;lt;=sqrt(r);i++)&#123;        int p=0;        while(r%i==0)&#123;            if(i%4!=3)&#123;                p+=2;            &#125;            r/=i;        &#125;        if(i!=2)            ans*=(p+1);    &#125;    if(r!=1)&#123;        if(r%4!=3)&#123;            ans*=3;        &#125;    &#125;    cout&amp;lt;&amp;lt;ans*4&amp;lt;&amp;lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LOJ10172]涂抹果酱</title>
    <link href="/2018/10/04/%5BLOJ10172%5D%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/"/>
    <url>/2018/10/04/%5BLOJ10172%5D%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个 N×M的矩形，它被划分成 N×M个边长为 1×1的小正方形区域（可以把蛋糕当成 N 行 M 列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为 1,2,3。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 K 行的果酱，且无法修改。<br>现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数 [latex] mod 10^6[/latex]<br>若不存在满足条件的方案，请输出 0。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共三行。<br>第一行：N,M；<br>第二行：K；<br>第三行：M 个整数，表示第 K 行的方案。<br>字母的详细含义见题目描述，其他参见样例。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，为可行的方案总数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><pre><code>2 2 1 2 3</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>3</code></pre><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p><img src="http://bubbleioa.top/wp-content/uploads/2018/10/TIM%E6%88%AA%E5%9B%BE20181004235342.png"></p><h2 id="数据范围和提示"><a href="#数据范围和提示" class="headerlink" title="数据范围和提示"></a>数据范围和提示</h2><p>对于 30% 的数据，1≤N×M≤20；<br>对于 60% 的数据，1≤N≤1000,1≤M≤3；<br>对于 100% 的数据，1≤N≤10000,1≤M≤5。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一开始拿到这道题目发现不就是状态压缩嘛，而且是相邻不重复的计数问题，这种题目早就已经轻车熟路了。<br>但是仔细看了才发现不简单，不是普通的二进制状压，而是三进制状压。  </p><p>但是进制本质上都是一样的，我们一边参照二进制状压，一边实现三进制状压。  </p><p>首先是左移右移，实际上二进制的左移右移就是[latex]\times 2[/latex]还有/2，既然是三进制，当然是*3还有/3</p><p>还有就是实现状态合法判定，具体的在check函数和judge函数的注释里，这两个函数稍微有点不同。</p><p>状态转移的话就是上一行的所有合法状态之和（这个和二进制状压是一样的）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;const int MAXN=10004,mod=1000000;int n,m,k,pos;int ban,ans=0;int can[1005],tot=0;int f[MAXN][1005];inline bool check(int x)&#123;//自身合法性判断，每次弹出最末尾的一个数，存起来，看看和下一个数是不是一样    int tmp=0x3f;    for(int i=1;i&amp;lt;=m;++i)&#123;        if(tmp==x%3)return false;        tmp=x%3,x/=3;    &#125;    return true;&#125;inline bool judge(int a,int b)&#123;//相互合法性判断，就是按位比对    for(int i=1;i&amp;lt;=m;++i)&#123;        if(a%3==b%3)return false;        a/=3,b/=3;    &#125;    return true;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;k;    int in=1;    for(int i=0;i&amp;lt;m;i++)in*=3;    for(int i=0;i&amp;lt;in;++i)if(check(i))can[++tot]=i;    for(int i=1;i&amp;lt;=m;++i)&#123;        int tmp;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;tmp);        ban=ban*3+tmp-1;    &#125;    for(int i=1;i&amp;lt;=tot;++i)if(ban==can[i])&#123;pos=i;break;&#125;    if(!pos)&#123;cout&amp;lt;&amp;lt;0;return 0;&#125;    for(int i=1;i&amp;lt;=n;++i)&#123;        if(i==k)&#123;            if(i==1)f[i][pos]=1;            else for(int j=1;j&amp;lt;=tot;++j)if(judge(can[pos],can[j]))(f[i][pos]+=f[i-1][j])%=mod;        &#125;        else for(int j=1;j&amp;lt;=tot;++j)&#123;            if(i==1)f[i][j]=1;            else for(int k=1;k&amp;lt;=tot;++k)if(judge(can[j],can[k]))(f[i][j]+=f[i-1][k])%=mod;        &#125;    &#125;    for(int i=1;i&amp;lt;=tot;++i)(ans+=f[n][i])%=mod;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[CF776B]Sherlock and his girlfriend</title>
    <link href="/2018/10/03/%5BCF776B%5DSherlock%20and%20his%20girlfriend/"/>
    <url>/2018/10/03/%5BCF776B%5DSherlock%20and%20his%20girlfriend/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Sherlock has a new girlfriend (so unlike him!). Valentine’s day is coming and he wants to gift her some jewelry.</p><p>He bought n pieces of jewelry. The i-th piece has price equal to i + 1, that is, the prices of the jewelry are 2, 3, 4, … n + 1.</p><p>Watson gave Sherlock a challenge to color these jewelry pieces such that two pieces don’t have the same color if the price of one piece is a prime divisor of the price of the other piece. Also, Watson asked him to minimize the number of different colors used.</p><p>Help Sherlock complete this trivial task.</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>The only line contains single integer n (1 ≤ n ≤ 100000) — the number of jewelry pieces.</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>The first line of output should contain a single integer k, the minimum number of colors that can be used to color the pieces of jewelry with the given constraints.</p><p>The next line should consist of n space-separated integers (between 1 and k) that specify the color of each piece in the order of increasing price.</p><p>If there are multiple ways to color the pieces using k colors, you can output any of them.</p><h2 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h2><h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><pre><code>3</code></pre><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><pre><code>21 1 2 </code></pre><h3 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h3><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><pre><code>4</code></pre><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><pre><code>22 1 1 2</code></pre><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>In the first input, the colors for first, second and third pieces of jewelry having respective prices 2, 3 and 4 are 1, 1 and 2 respectively.</p><p>In this case, as 2 is a prime divisor of 4, colors of jewelry having prices 2 and 4 must be distinct.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然如果[latex]i + 1[/latex]是一个质数，那么只有价格为[latex]i + 1[/latex]的倍数的珠宝必须具有不同的颜色<br>所以我们枚举[latex]2[/latex]到[latex]n+1[/latex]，并且如果枚举到的珠宝没涂色，说明是个质数，让他的倍数涂色<br>最后我们留下来的就是质数和非质数，而质数之间不可能互为质因数，非质数之间也不能为质因数，所以只要你将他们分别输出不同的数字就行  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;bool s[100005];int main()&#123;    int n;    cin&amp;gt;&amp;gt;n;    for(int i=2;i&amp;lt;=n+1;i++)&#123;        if(!s[i])&#123;            for(int j=i&amp;lt;&amp;lt;1;j&amp;lt;=n+1;j+=i)s[j]=1;        &#125;    &#125;    if(n&amp;gt;2)cout&amp;lt;&amp;lt;&amp;quot;2\n&amp;quot;;    else cout&amp;lt;&amp;lt;&amp;quot;1\n&amp;quot;;    for(int i=2;i&amp;lt;=n+1;i++)&#123;        if(!s[i])cout&amp;lt;&amp;lt;&amp;quot;1 &amp;quot;;        else cout&amp;lt;&amp;lt;&amp;quot;2 &amp;quot;;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个新兴的东方同音社团——纽约花残月乐团</title>
    <link href="/2018/10/02/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%85%B4%E7%9A%84%E4%B8%9C%E6%96%B9%E5%90%8C%E9%9F%B3%E7%A4%BE%E5%9B%A2%E2%80%94%E2%80%94%E7%BA%BD%E7%BA%A6%E8%8A%B1%E6%AE%8B%E6%9C%88%E4%B9%90%E5%9B%A2/"/>
    <url>/2018/10/02/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%85%B4%E7%9A%84%E4%B8%9C%E6%96%B9%E5%90%8C%E9%9F%B3%E7%A4%BE%E5%9B%A2%E2%80%94%E2%80%94%E7%BA%BD%E7%BA%A6%E8%8A%B1%E6%AE%8B%E6%9C%88%E4%B9%90%E5%9B%A2/</url>
    
    <content type="html"><![CDATA[<center>繁花分落的四月旧城，都市，樱瓣流舞天际微凉，点点微光照耀着的是北极星的残象幽风起，皎月将落未落此处，即梦开始的地方……这里是纽约花残月乐团一个新兴的东方同音社团愿天籁之音，奏响于此时。各位好，这里是纽约花残月乐团。[latex]NewYork\ HKT\ Studio[/latex]</center><hr><p><img src="http://bubbleioa.top/wp-content/uploads/2018/10/psb.jpg"><br>今年8月份刚刚建立起的一个东方同人音乐社团～<br>在2019年的2月份，我们将会推出第一张专辑。我们正在与<a href="http://weibo.com/u/5971410018">幻梦缘起</a>和<a href="https://weibo.com/u/6411746236">心界巡回</a>合作，因此我们的第一张专辑将包含以上<strong>两个社团的各两首歌曲</strong>。</p><p>同时，我们需要专业性的编曲指导，如果有意请联系主催～（即原po <a href="https://user.qzone.qq.com/1325054302">@SeiKasahara</a>）</p><p>欢迎来我们的社团外群观光，这里各个都是人才，进去就不想出来的那种（雾）</p><p>此次宣传非常感谢我的画师也是我的cp <a href="https://user.qzone.qq.com/2047617745">@⑨色の人形使い</a>  可以关注她的pixiv账号：<a href="https://www.pixiv.net/member_illust.php?id=7155418&type=illust">@グリンー</a></p><p>也同时感谢我团的御用画师柯达君 <a href="http://user.qzone.qq.com/925162293">@Owl</a>  担当了本次CD的bk设计。</p><p>更要感谢为宣传提出意见的作词和吉祥物。<br><a href="http://user.qzone.qq.com/1581634840">@河城不取～かっぱぱりら～</a> <a href="http://user.qzone.qq.com/823631903">@楠</a> <a href="http://user.qzone.qq.com/1250269261">@ Vanellope</a>  </p><p>我们将在10.5广州tho 幻梦缘起摊位上，期待您的到来。（屑主催要女装天子kora）</p><p>微博：<a href="https://weibo.com/nonomuraryotarou?from=myfollow_all&is_all=1">@纽约花残月乐团官微</a><br>外群群号：<a href="https://jq.qq.com/?_wv=1027&k=50SDVc6">260836338</a><br><img src="http://bubbleioa.top/wp-content/uploads/2018/10/psb-1.jpg"><br>[formidable id=”6”]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1896][SCOI2005]互不侵犯</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1896%5D%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1896%5D%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p><p>注：数据有加强（2018/4/25）</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>所得的方案数</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>3 2</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>16</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>建议先食用<a href="https://bubbleioa.github.io/2018/09/20/[%E6%B4%9B%E8%B0%B7P1879][USACO06NOV]%E7%8E%89%E7%B1%B3%E7%94%B0Corn%20Fields/#more">这道题</a><br>这道题，其实也是一道模板题，只不过情况稍微复杂了一点，状态稍微难转移一点。</p><table><thead><tr><th align="center">函数\变量名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">[latex]f[i][j][m][/latex]</td><td align="center">第[latex]i[/latex]行，第[latex]j[/latex]个状态，放了[latex]m[/latex]个国王</td></tr><tr><td align="center">[latex]get_one(x)[/latex]</td><td align="center">返回二进制数[latex]x[/latex]的1的个数</td></tr><tr><td align="center">[latex]can[i][/latex]</td><td align="center">预处理合法状态</td></tr><tr><td align="center">[latex]num[i][/latex]</td><td align="center">[latex]i[/latex]状态有多少个1</td></tr></tbody></table><p>和玉米田不同的是，这里[latex]f[/latex]的第二维是<strong>第[latex]j[/latex]个状态</strong>而不是状态[latex]j[/latex]  </p><p>预处理[latex]can[/latex]以及[latex]f[1][/latex]：<br>不能有相邻的国王，左移后若没有重叠则合法<br>顺便将当前状态的第一行赋值为1</p><p>后面就和玉米田差不多了，注释里只有与玉米田不同的注释</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;int n,k,cnt;long long f[10][1000][100];//第i行，第j个状态，放了m个国王int can[1000],num[1000];int get_one(int x)&#123;    int ans=0;    for(;x&amp;gt;0;x&amp;gt;&amp;gt;=1)ans+=x&amp;amp;1;    return num[cnt]=ans;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;    int top=(1&amp;lt;&amp;lt;n)-1;    for(int i=0;i&amp;lt;=top;i++)&#123;        if(((i&amp;lt;&amp;lt;1)&amp;amp;i)==0)can[++cnt]=i,f[1][cnt][get_one(i)]=1;    &#125;    for(int i=2;i&amp;lt;=n;i++)&#123;        for(int j=1;j&amp;lt;=cnt;j++)&#123;            int x=can[j];            for(int z=1;z&amp;lt;=cnt;z++)&#123;                int y=can[z];                if ((x&amp;amp;y)||(x&amp;amp;(y&amp;lt;&amp;lt;1))||(x&amp;amp;(y&amp;gt;&amp;gt;1))) continue;//左下角和右下角都不能放                for (int l=0;l&amp;lt;=k;l++) f[i][j][num[j]+l]+=f[i-1][z][l];//l是上个状态的国王数量，而我们找到的合法状态国王数量应该是上个国王数量加上当前状态的国王数量            &#125;        &#125;    &#125;    long long res=0;//注意long long    for (int i=1;i&amp;lt;=cnt;i++) res+=f[n][i][k];    printf(&amp;quot;%lld&amp;quot;,res);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1879][USACO06NOV]玉米田Corn Fields</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1879%5D%5BUSACO06NOV%5D%E7%8E%89%E7%B1%B3%E7%94%B0Corn%20Fields/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1879%5D%5BUSACO06NOV%5D%E7%8E%89%E7%B1%B3%E7%94%B0Corn%20Fields/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p><p>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p><p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p><p>John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行：两个整数M和N，用空格隔开。</p><p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>一个整数，即牧场分配总方案数除以100,000,000的余数。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>2 31 1 10 1 0</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>9</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一道状态压缩入门题，也是第一道我在不看任何题解的情况下写出来的状压dp题<br>状压dp一般会有明显的数据范围特征，即n,m一般都在20以内  </p><p>状压dp的状态设计和转移是有套路的，就拿这道题来说，[latex]f[i][j][/latex]表示第[latex]i[/latex]行在状态[latex]j[/latex]的时候的方案数，其中[latex]j[/latex]我们用一个二进制数来表示。<br>转移的时候只要判断与当前行和上一行是否冲突即可，如果不冲突，[latex]f[i][j]=\sum_{z为不冲突的状态} f[i-1][z][/latex]</p><p>[latex]\sum_{1\le i\le cnt} f[n][i][/latex] 就是最后的答案（[latex]cnt[/latex]为状态总数）</p><p>至于为什么在下面的代码里先枚举本层，在枚举上一层：<br>因为我们动态规划是靠状态转移来实现的，上一行相当于处在i-1阶段，我们需要不断用上一个阶段来更新下一个阶段（逆推），因此本层循环在外侧。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int mod=100000000;int f[13][5000];int ok[13];//纪录每一行输入的数据，也是用二进制保存int n,m;int can[5000],cnt;//预处理出所有合法状态int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            int a;            cin&gt;&gt;a;            ok[i]&lt;&lt;=1;//这里的顺序一定要注意            ok[i]|=a;        &#125;    &#125;    int MAXN=(1&lt;&lt;m)-1;//假设m为5最大的状态显然为1 1 1 1 1    for(int i=0;i&lt;=MAXN;i++)if((i&amp;(i&lt;&lt;1))==0)can[++cnt]=i;//自己如果和自己左移重叠了，说明有相邻的，不合法，只有不重叠才合法，注意从0开始    for(int i=1;i&lt;=cnt;i++)&#123;        if(can[i]&amp;(~ok[1]))continue;//第一行单独处理，~按位取反        f[1][i]=1;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=cnt;j++)&#123;//枚举当前行            int x=can[j];            for(int z=1;z&lt;=cnt;z++)&#123;//枚举上一行                int y=can[z];                if(x&amp;y||x&amp;(~ok[i])||y&amp;(~ok[i-1]))continue;                f[i][j]=(f[i][j]+f[i-1][z])%mod;            &#125;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=cnt;i++)ans=(ans+f[n][i])%mod;    cout&lt;&lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>个人dp小结</title>
    <link href="/2018/10/01/%E4%B8%AA%E4%BA%BAdp%E5%B0%8F%E7%BB%93/"/>
    <url>/2018/10/01/%E4%B8%AA%E4%BA%BAdp%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言：最近做了很多动态规划题，但是每次遇到新的题目的时候还是做不出来，于是就像做一个小结，梳理下近些天做的题目，从中获取经验。</p></blockquote><h1 id="第零节：DP的基础概念"><a href="#第零节：DP的基础概念" class="headerlink" title="第零节：DP的基础概念"></a>第零节：DP的基础概念</h1><p>动态规划和其他某些算法具有一定的相似度，都是利用<font color="FF0000"><strong>问题的可划分性</strong></font>以及<font color="FF0000"><strong>子问题的相似性</strong></font>来进行归纳，降低时间复杂度。<br>来说说动态规划的几个基本条件：</p><table><thead><tr><th align="center">条件</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">无后效性</td><td align="center">已求解的子问题不受后续阶段的影响[latex]^{[1]}[/latex]</td></tr><tr><td align="center">最优子结构</td><td align="center">下一个阶段的最优解应该能够由前面各阶段子问题的最优解导出</td></tr><tr><td align="center">子问题重叠</td><td align="center">动态规划通过对每个子问题只解一次，把解保存在一个需要时就可以查看的表中[latex]^{[2]}[/latex]</td></tr></tbody></table><blockquote><p>[1]：在《算法竞赛进阶指南》中有一个很好的说法，“动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该图的一个拓扑序。”<br>[2]：其实就是动态规划会用查询的方式解决重复出现的子问题，而不是像递归那样每次算一遍。</p></blockquote><p>构成动态规划的三要素：</p><table><thead><tr><th align="center">要素</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">状态</td><td align="center">即我们通常所说的f或dp数组，他们用来表示什么</td></tr><tr><td align="center">阶段</td><td align="center">即各个状态在不同时刻的表示</td></tr><tr><td align="center">决策</td><td align="center">状态如何转移到 下一个状态</td></tr></tbody></table><p>知道了这些并没有什么用，重要的还是在题目中体会。</p><h1 id="第一节：线性DP"><a href="#第一节：线性DP" class="headerlink" title="第一节：线性DP"></a>第一节：线性DP</h1><p>我们在解决一些线性区间上的最优化问题的时候，往往也能够利用到动态规划的思想，这种问题可以叫做线性dp。  </p><ul><li><input checked="" disabled="" type="checkbox"> 线性空间  </li></ul><p>在有关线性dp问题中，有着几个比较经典而基础的模型，例如最长上升子序列(LIS)、最长公共子序列(LCS)、最大子序列和等，那么首先我们从这几个经典的问题出发开始对线性dp的探索。</p><blockquote><p>注：下表引用自《算法竞赛进阶指南》P258表</p></blockquote><hr><p><font size=4><center>LIS问题</center></font></p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">问题描述</td><td align="center">最长上升子序列。给定一个长度为[latex]N[/latex]的数列[latex]A[/latex]，求数值单调递增的子序列的长度是多少。[latex]A[/latex]的任意子序列[latex]B[/latex]可表示为[latex]B={A_{k1},A_{k2},…,A_{kp}}[/latex]，其中[latex]k_1&lt;k_2&lt;…&lt;k_p[latex]</td></tr><tr><td align="center">状态表示</td><td align="center">[latex]F[i][/latex]表示以[latex]A[i][/latex]为结尾的“最长上升子序列”的长度</td></tr><tr><td align="center">阶段划分</td><td align="center">子序列的位置（数列[latex]A[/latex]中的位置，从前到后）</td></tr><tr><td align="center">转移方程</td><td align="center">$$F[i]=max{F[j]+1},0\le j&lt; i, A [ j ] &lt; A[i] $$</td></tr><tr><td align="center">边界</td><td align="center">[latex] F[0]=0 [/latex]</td></tr><tr><td align="center">目标</td><td align="center">[latex]max{F[i]},1\le i \le N[/latex]</td></tr></tbody></table><p>还有两个大家自行看书~（打这个太累啦）<br>通过这三个问题，我们可以了解到，线性DP无论是多维还是一维，“线性”都体现在“作用在空间上的递推”————DP的阶段沿着各个维度线性增长，从一个或多个“边界点”开始有方向地向整个状态空间转移、扩展，最后每个状态上都保留了以自身为目标子问题的最优解。<br>下面我们开始线性DP的进阶，我们从例题开始。</p><h3 id="【例1】Mr-Young’s-Picture-Permutations-latex-poj2279-latex"><a href="#【例1】Mr-Young’s-Picture-Permutations-latex-poj2279-latex" class="headerlink" title="【例1】Mr. Young’s Picture Permutations[latex]^{poj2279}[/latex]"></a><a href="https://bubbleioa.github.io/2018/08/26/[SP15637][POJ2279]GNYR04H%20-%20Mr%20Youngs%20Picture%20Permutations/">【例1】Mr. Young’s Picture Permutations[latex]^{poj2279}[/latex]</a></h3><p>这是一个五维的线性DP，从该题给出的解法中我们发现，设计动态规划的状态转移方程，不一定要以“如何计算出一个状态”的形式给出，也可以考虑“<strong>一个已知状态应该更新哪些后续阶段的未知状态</strong>”。</p><h1 id="第二节：背包"><a href="#第二节：背包" class="headerlink" title="第二节：背包"></a>第二节：背包</h1><p>其实我们OIer很多时候都是靠眼睛学习的，偶尔通过听觉也是不错的。  </p><iframe src="//player.bilibili.com/player.html?aid=7752071&cid=12709344&page=1" width=620 height=470 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="⭐0-1背包"><a href="#⭐0-1背包" class="headerlink" title="⭐0/1背包"></a>⭐0/1背包</h2><h2 id="⭐完全背包"><a href="#⭐完全背包" class="headerlink" title="⭐完全背包"></a>⭐完全背包</h2><h2 id="⭐多重背包"><a href="#⭐多重背包" class="headerlink" title="⭐多重背包"></a>⭐多重背包</h2><h2 id="⭐分组背包"><a href="#⭐分组背包" class="headerlink" title="⭐分组背包"></a>⭐分组背包</h2><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><h2 id="⭐背包类树形DP"><a href="#⭐背包类树形DP" class="headerlink" title="⭐背包类树形DP"></a>⭐背包类树形DP</h2><p>推荐个视频  </p><iframe src="//player.bilibili.com/player.html?aid=19615811&cid=31986336&page=1" scrolling="no" border="0" frameborder="no" width=620 height=470 framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[SP15637][POJ2279]GNYR04H - Mr Youngs Picture Permutations</title>
    <link href="/2018/10/01/%5BSP15637%5D%5BPOJ2279%5DGNYR04H%20-%20Mr%20Youngs%20Picture%20Permutations/"/>
    <url>/2018/10/01/%5BSP15637%5D%5BPOJ2279%5DGNYR04H%20-%20Mr%20Youngs%20Picture%20Permutations/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>杨先生希望为他的班级拍照。学生将排成一行，每行不超过后面的行，并且行的左端对齐。例如，可以安排12名学生排列（从后到前）5,3,3和1名学生。</p><pre><code>X X X X XX X XX X XX</code></pre><p>此外，杨先生希望每排学生安排高度从左到右减少。此外，学生身高应从后向前减少。想想看，杨先生看到，对于这个12人的例子，至少有两种安排学生的方式（数字代表高度，其中1代表最高）：</p><pre><code>1  2  3  4  5     1  5  8 11 126  7  8           2  6  99 10 11           3  7 1012                4</code></pre><p>杨先生想知道，对于给定排列的排列，可能有多少不同的学生安排。他尝试用长度为3,2和1的行开始计数，并计数16个排列：</p><pre><code>123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 14645  46  35  36  34  36  34  35  25  26  24  26  24  25  26  256   5   6   5   6   4   5   4   6   5   6   4   5   4   3   3</code></pre><p>杨先生认为，手动点数对于任何合理数量的学生来说都不会很有效。他通过编写计算机程序来帮助你确定一组给定行的学生的不同安排数量。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入描述了一系列测试，每个测试分两行描述。第一行将行数k作为十进制整数。第二行包含从后到前的行的长度（n {1} 1 ，n {2} 2 ，…，n _ {K} ķ ）作为由单个空格分隔的十进制整数。问题集以行计数为0的行结束。最多不会超过5行，学生总数N（行长度总和）最多不超过30行。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个测试用例输出一个整数：N个学生排列在给定行中的数量，以便高度从左到右沿着每行减少，并且从后到前沿着每列减小（假定所有高度都不同）。结果应该分开。输入数据将被选择，以便结果总是适合一个无符号的32位整数。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>13051 1 1 1 133 2 145 3 3 156 5 4 3 2215 150</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>111641581418926089694845</code></pre><p>翻译by@<a href="https://www.luogu.org/space/show?uid=89910">_UMR_</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看到网上很多人说《算法竞赛进阶指南》上的方法不行，会MLE<br>那动态开空间不就是了……<br>在合法的方案中，每一行，每一列都是单调的，也就是说我们要确保每一次放的时候，放的人要小于左边的，上面的。<br>其实这也很好办，假设我们放的人的高度是递减的，第一行我们只要放得去，就能满足单调，而下面几行，只要各自人数小于等于上面一行的人数就OK了。<br>让我们来看看这一题的“动态规划信息表”</p><table><thead><tr><th align="center">信息</th><th align="center">表示方式</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">状态</td><td align="center">[latex]F_{a_1,a_2,a_3,a_4,a_5}[/latex]</td><td align="center">表示各排从左端起，分别占了[latex]a_1,a_2,a_3,a_4,a_5[/latex]个人时，合影方案数量</td></tr><tr><td align="center">边界</td><td align="center">[latex]F_{0,0,0,0,0}=1[/latex]</td><td align="center">其余为0</td></tr><tr><td align="center">目标</td><td align="center">[latex]F_{N_1,N_2,N_3,N_4,N_5}[/latex]</td><td align="center">无</td></tr><tr><td align="center">转移</td><td align="center">无</td><td align="center">若[latex]a_1&lt;N_1[/latex],则令[latex]F_{a_1+1,a_2,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}[/latex]。若[latex]a_2&lt;N_2&amp;&amp;a_1&gt;a_2[/latex]则令[latex]F_{a_1,a_2+1,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}[/latex]  第3~5同理</td></tr></tbody></table><p>至于杨氏矩阵和钩长公式，还请大家自行了解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int k,a[6],n[6];int main()&#123;    while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;k))&#123;        if(k==0)break;        memset(n,0,sizeof(n));        for(int i=1;i&amp;lt;=k;i++) scanf(&amp;quot;%d&amp;quot;,&amp;amp;n[i]);        int f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1];        memset(f,0,sizeof(f));        f[0][0][0][0][0]=1;        for(a[1]=0;a[1]&amp;lt;=n[1];a[1]++)            for(a[2]=0;a[2]&amp;lt;=n[2];a[2]++)                  for(a[3]=0;a[3]&amp;lt;=n[3];a[3]++)                       for(a[4]=0;a[4]&amp;lt;=n[4];a[4]++)                        for(a[5]=0;a[5]&amp;lt;=n[5];a[5]++)&#123;                            int t=f[a[1]][a[2]][a[3]][a[4]][a[5]];                            if(a[1]&amp;lt;n[1]) f[a[1]+1][a[2]][a[3]][a[4]][a[5]]+=t;                            if(a[2]&amp;lt;n[2]&amp;amp;&amp;amp;a[1]&amp;gt;a[2]) f[a[1]][a[2]+1][a[3]][a[4]][a[5]]+=t;                            if(a[3]&amp;lt;n[3]&amp;amp;&amp;amp;a[2]&amp;gt;a[3]) f[a[1]][a[2]][a[3]+1][a[4]][a[5]]+=t;                            if(a[4]&amp;lt;n[4]&amp;amp;&amp;amp;a[3]&amp;gt;a[4]) f[a[1]][a[2]][a[3]][a[4]+1][a[5]]+=t;                            if(a[5]&amp;lt;n[5]&amp;amp;&amp;amp;a[4]&amp;gt;a[5]) f[a[1]][a[2]][a[3]][a[4]][a[5]+1]+=t;                        &#125;        printf(&amp;quot;%d\n&amp;quot;,f[n[1]][n[2]][n[3]][n[4]][n[5]]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P4011]孤岛营救问题</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P4011%5D%E5%AD%A4%E5%B2%9B%E8%90%A5%E6%95%91%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P4011%5D%E5%AD%A4%E5%B2%9B%E8%90%A5%E6%95%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>[latex]1944[/latex] 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 [latex]N[/latex] 行，东西方向被划分为 [latex]M[/latex] 列，于是整个迷宫被划分为 [latex]N\times M[/latex] 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 [latex]2[/latex] 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 [latex]P[/latex] 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。</p><p>大兵瑞恩被关押在迷宫的东南角，即 <a href="N,M">latex</a>[/latex] 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 <a href="1,1">latex</a>[/latex] 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为[latex]1[/latex] ，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。</p><p>试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p><img src="https://s1.ax1x.com/2018/08/25/PH4tQH.md.png"></p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 -1 。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>4 4 991 2 1 3 21 2 2 2 02 1 2 2 02 1 3 1 02 3 3 3 02 4 3 4 13 2 3 3 03 3 4 3 04 3 4 4 022 1 24 2 1</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>14</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><img src="https://s1.ax1x.com/2018/08/25/PH4Nyd.png"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>虽然它是网络流24题，但是其实根本不用网络流做。<br>首先我们来看看这个题目的数据范围，挺有意思的。<br>[latex]N,M,P\le10[/latex]钥匙种类和地图大小都很小，嗯，感觉可以广搜，置于钥匙，我们就可以<strong>状态压缩</strong>一下  </p><table><thead><tr><th align="center">变量名</th><th align="center">变量作用</th></tr></thead><tbody><tr><td align="center">[latex]vis_{i,j,k}[/latex]</td><td align="center">记录你是否揣着[latex]k[/latex]这个集合的钥匙到过<a href="i,j">latex</a>[/latex]处</td></tr><tr><td align="center">[latex]map_{x1,y1,x2,y2}[/latex]</td><td align="center">表示<a href="x1,y1">latex</a>[/latex]到<a href="x2,y2">latex</a>[/latex]是个什么情况</td></tr><tr><td align="center">[latex]key_{i,j,k}[/latex]</td><td align="center">表示<a href="i,j">latex</a>[/latex]存放的第[latex]k[/latex]把钥匙</td></tr><tr><td align="center">[latex]num_{i,j}[/latex]</td><td align="center">表示在<a href="i,j">latex</a>[/latex]处有几把钥匙</td></tr><tr><td align="center">[latex]tt[/latex]</td><td align="center">当前携带的钥匙集合</td></tr></tbody></table><h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>至于状态压缩的话，假设现在有5种钥匙，我们用1表示现在身上有，0没有。初始情况：</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr><td>现在，我们来了第二把钥匙（从右往左）</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>0</th><th>0</th><th>0</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>这东西是不是很像二进制？</td><td></td><td></td><td></td><td></td></tr><tr><td>所以我们就可以用二进制来进行状压。</td><td></td><td></td><td></td><td></td></tr><tr><td>每次我们得到钥匙时，$$ tt</td><td>=1&lt;&lt;(key[i][j][k]-1) $$</td><td></td><td></td><td></td></tr><tr><td>每次查询是否有第i把钥匙时，只要$$ tt&amp;(1&lt;&lt;(i-1)) $$为真，我们就可以认为有这把钥匙。</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;const int dx[4] = &#123; -1,1,0,0 &#125;;const int dy[4] = &#123; 0,0,-1,1 &#125;;struct node &#123;    int x, y, step, key;&#125;;queue&amp;lt;node&amp;gt;q;bool v[11][11][1 &amp;lt;&amp;lt; 11];//v[x][y][tt]表示点(x,y)带有这么多的钥匙是否来过int n, m, p, k;int mp[11][11][11][11];//mp[x1][y1][x2][y2]表示两个点直接是否有墙或者是门，0表示可以直接通过int key[11][11][11];//key[x][y][i]表示点（x,y）放的第i把钥匙int num[11][11];//num[x][y]表示点（x,y)有多少把钥匙int bfs() &#123;    int tt = 0;    for (int i = 1; i &amp;lt;= num[1][1]; i++) &#123;        tt |= (1 &amp;lt;&amp;lt; (key[1][1][i] - 1));//初始点可以放钥匙    &#125;    v[1][1][tt] = 1;    q.push((node) &#123; 1, 1, 0, tt &#125;);    while (!q.empty()) &#123;        node x = q.front(); q.pop();        if (x.x == n &amp;amp;&amp;amp; x.y == m) return x.step;        for (int i = 0; i &amp;lt;= 3; i++) &#123;            int xx = x.x + dx[i];            int yy = x.y + dy[i];            if (1 &amp;lt;= xx &amp;amp;&amp;amp; xx &amp;lt;= n &amp;amp;&amp;amp; 1 &amp;lt;= yy &amp;amp;&amp;amp; yy &amp;lt;= m) &#123;//是否合法                if (mp[x.x][x.y][xx][yy] == -1) continue;//墙，不能                int t;                if ((t = mp[x.x][x.y][xx][yy]) != 0)//门                    if ((x.key&amp;amp;(1 &amp;lt;&amp;lt; (t - 1))) == 0) continue;//没有钥匙                int tt = x.key;                for (int j = 1; j &amp;lt;= num[xx][yy]; j++)                    tt = tt | (1 &amp;lt;&amp;lt; (key[xx][yy][j] - 1));//带上钥匙                if (v[xx][yy][tt]) continue;//同样的地点带着同样的钥匙，我们就认为状态重复了                v[xx][yy][tt] = 1;                q.push((node) &#123; xx, yy, x.step + 1, tt &#125;);            &#125;        &#125;    &#125;    return -1;&#125;int main() &#123;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; p &amp;gt;&amp;gt; k;    for (int i = 1; i &amp;lt;= k; i++) &#123;        int x1, x2, y1, y2, g;        scanf(&amp;quot;%d%d%d%d%d&amp;quot;, &amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2, &amp;amp;g);        if (g == 0)mp[x1][y1][x2][y2] = mp[x2][y2][x1][y1] = -1;        else mp[x1][y1][x2][y2] = mp[x2][y2][x1][y1] = g;    &#125;    int s;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;s);    for (int i = 1; i &amp;lt;= s; i++) &#123;        int x, y, p;        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;p);        key[x][y][++num[x][y]] = p;    &#125;    printf(&amp;quot;%d\n&amp;quot;, bfs());    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[UVA11362]Phone List</title>
    <link href="/2018/10/01/%5BUVA11362%5DPhone%20List/"/>
    <url>/2018/10/01/%5BUVA11362%5DPhone%20List/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://uva.onlinejudge.org/external/113/p11362.pdf">PDF</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>虽然我很想说这是一道字典树模板题，但是还是有点技巧的。<br>对于每组输入，我们先把它存入字典树，然后再来查找（也就是所谓的离线）<br>为了说明方便，用表格说明一下变量吧  </p><table><thead><tr><th align="center">变量名</th><th align="center">变量作用</th></tr></thead><tbody><tr><td align="center">[latex]st[/latex]</td><td align="center">保存读入的字符串，用于离线</td></tr><tr><td align="center">[latex]word[/latex]</td><td align="center">保存字典树每条边被覆盖的次数，遍历时为1说明不是前缀</td></tr><tr><td align="center">[latex]ch[/latex]</td><td align="center">字典树，第一维是编号，第二维是哪条边，值为指向的点</td></tr><tr><td align="center">[latex]sz[/latex]</td><td align="center">用来编号，类似于链式前向星里的[latex]tot[/latex]</td></tr></tbody></table><p>关键是遍历的时候，只要word为1就返回0（就是它自己啊），能顺利的走下来就返回1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 1e5 + 10;int t,n;char st[10100][10];int word[MAX],ch[MAX][10],sz;void reset()&#123;//每组数据需要重置   sz = 1;   memset(ch[0],0,sizeof(ch[0]));   memset(word,0,sizeof(word));&#125;void insert(char *s)&#123;//插入进字典树    int nl = strlen(s),u = 0;    for(int i = 0 ; i &amp;lt; nl ;i++)&#123;        int c = s[i] - &amp;#039;0&amp;#039;;        if(! ch[u][c])&#123;          memset(ch[sz],0,sizeof(ch[sz]));            ch[u][c] = sz++;        &#125;        u = ch[u][c];        word[u]++;    &#125;&#125;int find(char *s)&#123;//是否是前缀   int nl = strlen(s),u = 0;   for(int i = 0; i &amp;lt; nl; i++)&#123;        int c = s[i] - &amp;#039;0&amp;#039;;        u = ch[u][c];        if(word[u] == 1) return 0;   &#125;   return 1;&#125;int main()&#123;    cin&amp;gt;&amp;gt;t;    while(t--)&#123;        reset();        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        for(int i = 1 ; i &amp;lt;= n; i++)&#123;            scanf(&amp;quot;%s&amp;quot;,st[i]);            insert(st[i]);        &#125;        int ok = 1;        for(int i = 1 ; i &amp;lt;= n; i++)            if(find(st[i]))&#123;                ok = 0;                break;            &#125;        if(ok) printf(&amp;quot;YES\n&amp;quot;);        else printf(&amp;quot;NO\n&amp;quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOIP2014]联合权值</title>
    <link href="/2018/10/01/%5BNOIP2014%5D%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC/"/>
    <url>/2018/10/01/%5BNOIP2014%5D%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>无向连通图G 有n 个点，n – 1 条边。点从1 到n 依次编号，编号为 i 的点的权值为W i   ，每条边的长度均为1 。图上两点( u ,  v ) 的距离定义为u 点到v 点的最短距离。对于图G 上的点对( u, v) ，若它们的距离为2 ，则它们之间会产生Wu<br>×Wv 的联合权值。<br>请问图G 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件名为link .in。<br>第一行包含1 个整数n 。<br>接下来n – 1 行，每行包含 2 个用空格隔开的正整数u 、v ，表示编号为 u 和编号为v 的点之间有边相连。<br>最后1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示图G 上编号为i 的点的权值为W i 。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件名为link .out 。<br>输出共1 行，包含2 个整数，之间用一个空格隔开，依次为图G 上联合权值的最大值<br>和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007 取余。<br>「数据说明」<br>对于30% 的数据，1 &lt; n≤ 100 ；<br>对于60% 的数据，1 &lt; n≤ 2000；<br>对于100%的数据，1 &lt; n≤ 200 , 000 ，0 &lt; wi≤ 10, 000 。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>5  1 2  2 33 4  4 5  1 5 2 3 10 </code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>20 74</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题其实是道水题（逃ε=ε=ε=┏(゜ロ゜;)┛<br>我们首先要发现的一点就是如果我们确定了一个点，他所遍历到的所有点它们互相的距离就是$2$。<br>所以我们就可以枚举每一个点，枚举它每一个可通往的点，最大值取</p><p>[latex]Mx=max(Mx,该点遍历的最大值\times该点遍历到的次大值)[/latex]<br>而总和我们就取<br>$$Ans=\sum V[i] \times V[j]$$<br>i为遍历过的边 j为当前边<br>注意要最后答案要乘2，因为(1,3)(3,1)要算两次  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAXN = 200004, mod = 10007;int Head[MAXN], Nt[MAXN * 2], to[MAXN * 2];int tot, n;int v[MAXN];int mx, ans;void add(int a, int b) &#123;    Nt[++tot] = Head[a];    to[tot] = b;    Head[a] = tot;&#125;void get(int x) &#123;    int sum = 0, ma = 0, m = 0;//当前总和，最大值，次大值    for (int i = Head[x]; i; i = Nt[i]) &#123;        if (v[to[i]]&amp;gt;ma) &#123; m = ma;    ma = v[to[i]]; &#125;        else if (v[to[i]]&amp;gt;m)m = v[to[i]];        ans = (ans + sum * v[to[i]]) % mod;        sum = (sum + v[to[i]]) % mod;    &#125;    mx= max(mx, ma*m);&#125;int main() &#123;    cin &amp;gt;&amp;gt; n;    for (int i = 1; i &amp;lt; n; i++) &#123;        int a, b;        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);        add(a, b);        add(b, a);    &#125;    for (int i = 1; i &amp;lt;= n; i++) &#123;        scanf(&amp;quot;%d&amp;quot;, &amp;amp;v[i]);    &#125;    for (int i = 1; i &amp;lt;= n; i++) &#123;        get(i);    &#125;    cout &amp;lt;&amp;lt; mx &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ans*2%mod &amp;lt;&amp;lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[NOIP2009]最优贸易</title>
    <link href="/2018/10/01/%5BNOIP2009%5D%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/"/>
    <url>/2018/10/01/%5BNOIP2009%5D%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>C 国有n 个大城市和m 条道路，每条道路连接这n 个城市中的某两个城市。任意两个<br>城市之间最多只有一条道路直接相连。这m 条道路中有一部分为单向通行的道路，一部分<br>为双向通行的道路，双向通行的道路在统计条数时也计为1 条。<br>C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价<br>格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。<br>商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息<br>之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C 国n 个城<br>市的标号从1~ n，阿龙决定从1 号城市出发，并最终在n 号城市结束自己的旅行。在旅游的<br>过程中，任何城市可以重复经过多次，但不要求经过所有n 个城市。阿龙通过这样的贸易方<br>式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另<br>一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C 国旅游，他决定<br>这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。<br>假设 C 国有5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路<br>为单向通行，双向箭头表示这条道路为双向通行。<br><img src="https://cdn.luogu.org/upload/pic/27.png"><br>假设 1~n 号城市的水晶球价格分别为4，3，5，6，1。<br>阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在2 号城市以3 的价格买入水晶球，在3<br>号城市以5 的价格卖出水晶球，赚取的旅费数为2。<br>阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第1 次到达5 号城市时以1 的价格<br>买入水晶球，在第2 次到达4 号城市时以6 的价格卖出水晶球，赚取的旅费数为5。</p><p>现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号<br>以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含 2 个正整数n 和m，中间用一个空格隔开，分别表示城市的数目和道路的<br>数目。<br>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这n 个城<br>市的商品价格。<br>接下来 m 行，每行有3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果z=1，<br>表示这条道路是城市x 到城市y 之间的单向道路；如果z=2，表示这条道路为城市x 和城市<br>y 之间的双向道路。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>包含1 个整数，表示最多能赚取的旅费。如果没有进行贸易，<br>则输出0。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>5 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>5</code></pre><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>输入数据保证 1 号城市可以到达n 号城市。<br>对于 10%的数据，1≤n≤6。<br>对于 30%的数据，1≤n≤100。<br>对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。<br>对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市<br>水晶球价格≤100。  </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN = 500010;int n, m;int flag = 0;int Head[MAXN / 5], Nt[MAXN * 2], to[MAXN * 2], tot;int price[MAXN / 5], f[MAXN / 5], mi[MAXN / 5];void add(int a, int b) &#123;    Nt[++tot] = Head[a];    to[tot] = b;    Head[a] = tot;&#125;void dfs(int x, int minn, int pre) &#123;    int flag = 1;    minn = min(minn, price[x]);    if (mi[x]&amp;gt;minn)mi[x] = minn, flag = 0;    int maxx = max(f[pre], price[x] - mi[x]);    if (f[x]&amp;lt;maxx)f[x] = maxx, flag = 0;    if (flag)return;    for (int i = Head[x]; i; i = Nt[i]) &#123;        int y = to[i];        dfs(y, minn, x);    &#125;&#125;int main() &#123;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;    memset(mi, 0x7f, sizeof(mi));    for (int i = 1; i &amp;lt;= n; i++) &#123;        scanf(&amp;quot;%d&amp;quot;, &amp;amp;price[i]);    &#125;    for (int i = 1; i &amp;lt;= m; i++) &#123;        int a, b, c;        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);        add(a, b);        if (c == 2)add(b, a);    &#125;    dfs(1, 1 &amp;lt;&amp;lt; 30, 0);    printf(&amp;quot;%d&amp;quot;, f[n]);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P4071][SDOI2016]排列计数</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P4071%5D%5BSDOI2016%5D%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P4071%5D%5BSDOI2016%5D%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求有多少种长度为 n 的序列 A，满足以下条件：<br>1 ~ n 这 n 个数在序列中各出现了一次<br>若第 i 个数 A[i] 的值为 i，则称 i 是稳定的。序列恰好有 m 个数是稳定的<br>满足条件的序列可能很多，序列数对 10^9+7 取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个数 T，表示有 T 组数据。<br>接下来 T 行，每行两个整数 n、m。<br>T=500000，n≤1000000，m≤1000000</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 T 行，每行一个数，表示求出的序列数</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>51 01 15 2100 5010000 5000</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>012057802888760695423</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>没思路？我们来找规律！<br>比如一个[latex]n=5[/latex]的排列，我们假设[latex]m=2[/latex]也就是说，我们其实已经确定了排列种某些位置的值，就这个例子来说：</p><p>[latex]12???[/latex] [latex]1?3??[/latex] [latex]1??4?[/latex] [latex]1???5[/latex] [latex]?23??[/latex] [latex]?2?4?[/latex] [latex]?2??5[/latex] [latex]??34?[/latex] [latex]??3?5[/latex] [latex]???45[/latex] </p><p>共10种，很容易发现其实就是[latex]C_n^m[/latex]，那么其中的问号又多少种排列呢？</p><p>没思路？我们再来找规律！<br>我们设[latex]D_i[/latex]为i个?的可能的排列数，显然，[latex]D_1=0[/latex] [latex]D_2=1[/latex]<br>接着我们来看下[latex]D_3[/latex]，可以有[latex]312[/latex],[latex]231[/latex]<br>如果我们继续找下去的话，容易出错，所以我们现在来找找规律（灵魂画师）。<br>就拿[latex]D_4[/latex]来说，上面的是数，下面的是位置，首先，1不能放到1号位，而且放到2，3，4上对于递推是等价的，于是他别无选择地放到了其他地方（假设是2号位）<br><img src="https://s1.ax1x.com/2018/08/22/PTVWbn.png"><br>然后我们假设2放到1号位上去，剩下的3，4正好是[latex]D_2[/latex]<br><img src="https://s1.ax1x.com/2018/08/22/PTVy8S.png"><br>但2怎么可能只有放在1号位上的命运呢？它还可以不放到1号位，咦？我们之前说，i不能放到i号位，那么既然2不放到1号位，那么1号位在这里是不是等价于2号位呢？没错！<br><img src="https://s1.ax1x.com/2018/08/22/PTVcvQ.png"><br>而之前的“万恶之源”数字1，它有[latex]n-1[/latex]种放法，所以我们就大胆猜测：[latex]D_n=(n-1)(D_{n-1}+D_{n-2})[/latex]<br>严谨的证明还请大家自己百度<br>然后我们就愉快地输出[latex]C_n^m\times D_{n-m}[/latex]就好啦<br>其他知识点比如说逆元求组合数（费马小定理）还请大家自行了解  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;typedef long long ll;const int MAXN=1000005,mod=1000000007;ll f[MAXN],inv[MAXN],d[MAXN];int t;ll qpow(ll a,ll b)&#123;    ll ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=a*ans%mod;        a=a*a%mod;        b&amp;gt;&amp;gt;=1;    &#125;    return ans;&#125;void prework()&#123;    f[0]=1;    for(int i=1;i&amp;lt;MAXN;i++)&#123;        f[i]=f[i-1]*i%mod;        inv[i]=qpow(f[i],mod-2);    &#125;    d[1]=0,d[2]=1,d[3]=2;    for(int i=4;i&amp;lt;MAXN;i++)&#123;        d[i]=(i-1)*(d[i-1]+d[i-2])%mod;    &#125;&#125;int main()&#123;    cin&amp;gt;&amp;gt;t;    prework();    for(int i=1;i&amp;lt;=t;i++)&#123;        ll n,m;        scanf(&amp;quot;%lld%lld&amp;quot;,&amp;amp;n,&amp;amp;m);        if (n - m == 1) printf(&amp;quot;0\n&amp;quot;);        else if (m == n) printf(&amp;quot;1\n&amp;quot;);        else if (m == 0) printf(&amp;quot;%lld\n&amp;quot;,d[n]);        else &#123;            printf(&amp;quot;%lld\n&amp;quot;,f[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[开学考试]最大平方数</title>
    <link href="/2018/10/01/%5B%E5%BC%80%E5%AD%A6%E8%80%83%E8%AF%95%5D%E6%9C%80%E5%A4%A7%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2018/10/01/%5B%E5%BC%80%E5%AD%A6%E8%80%83%E8%AF%95%5D%E6%9C%80%E5%A4%A7%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 [latex]N[/latex] ,求 [latex]1[/latex]  到 [latex]N[/latex] 个数中选出任意个数相乘能组成的最大平方数,由<br>于此数可能很大,你只需要输出此数除 [latex]100000007[/latex] 的余数即可。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>7</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>144</code></pre><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>[latex]2\times 3 \times 4\times 6=144[/latex]</p><h2 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h2><p>由于各大oj可能没有，故在此提供<a href="https://bubbleioa.github.io/Square.zip">测试数据</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目就是这么简单，然而考试并没有想到[latex]QAQ[/latex]<br>因为是任意个数相乘，我们可以将[latex]N![/latex]进行质因数分解<br>然后因为[latex]A^2\times B^2=(A\times B)^2[/latex]<br>我们就可以把所有的2的整数倍次方全部乘入答案里，就是最大的平方数。</p><p>而普通的方法分解[latex]N![/latex]需要[latex]O(N\sqrt{N})[/latex]的时间复杂度，我们可以考虑一种新方法。</p><p>显然，[latex]N![/latex]的每个质因子都不会超过[latex]N[/latex]，我们可以先筛选出[latex]1-N[/latex]的每个质数[latex]p[/latex]，然后考虑阶乘中一共包含多少个质因子[latex]p[/latex]</p><p>[latex]N![/latex]中质因子[latex]p[/latex]的个数就等于[latex]1-N[/latex]每个数包含的质因子[latex]p[/latex]的个数之和。在[latex]1-N[/latex]中，[latex]p[/latex]的倍数，即至少包含1个质因子[latex]p[/latex]的显然有[latex]\lfloor N/p \rfloor[/latex]个。而[latex]p^2[/latex]的倍数，即至少包含2个质因子[latex]p[/latex]的有[latex]\lfloor N/p^2 \rfloor[/latex]个。不过其中的一个质因子已经在[latex]\lfloor N/p \rfloor[/latex]中统计过，所以只需要再统计第2个质因子，即累加上[latex]\lfloor N/p^2 \rfloor[/latex]，而不是[latex]2\times \lfloor N/p^2 \rfloor[/latex]</p><p>综上所述，[latex]N![/latex]中质因子[latex]p[/latex]的个数为：</p><p>$$ \left\lfloor \frac{N}{P} \right\rfloor+\left\lfloor \frac{N}{P^2} \right\rfloor+\left\lfloor \frac{N}{P^3} \right\rfloor+\dots+\left\lfloor \frac{N}{P^{\lfloor log_p N \rfloor}} \right\rfloor=\sum_{p^k\le N}\left\lfloor \frac{N}{P^k} \right\rfloor $$</p><p>上面的计算只需要[latex]O(logN)[/latex]的时间<br>整个过程只需要[latex]O(NlogN)[/latex]的时间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;const int mod=100000007;int n,ans=1;bool v[10000010];vector&amp;lt;int&amp;gt; prime;void get_prime(int n)&#123;    for(int i=2;i&amp;lt;=n;i++)&#123;        if(v[i])continue;        prime.push_back(i);        for(int j=i;j&amp;lt;=n/i;j++)v[i*j]=1;    &#125;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n;    get_prime(n);    for(int i=0;i&amp;lt;prime.size();i++)&#123;        int p=prime[i],c=0;        for(int j=n;j;j/=p)c+=j/p;        if(c==0)continue;        if(c&amp;amp;1)&#123;            for(int i=1;i&amp;lt;c;i++)ans=(long long)ans*p%mod;//这里要么取两次mod，要么用long long，后者快一点，当然可以用快速幂，更快（我懒orz        &#125;        else for(int i=1;i&amp;lt;=c;i++)ans=(long long)ans*p%mod;//这里要么取两次mod，要么用long long，后者快一点，当然可以用快速幂，更快    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[国际信息学奥赛2018]官方视频搬运</title>
    <link href="/2018/10/01/%5B%E5%9B%BD%E9%99%85%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B2018%5D%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E6%90%AC%E8%BF%90/"/>
    <url>/2018/10/01/%5B%E5%9B%BD%E9%99%85%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B2018%5D%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<center>2018年的国际信息学奥赛的比赛已经告一段落，官网也发布了一些视频，蒟蒻看没人搬就搬过来了。<h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Arrival-Sep-1"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Arrival-Sep-1" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Arrival Sep.1"></a>【国际信息学奥赛】IOI 2018 JAPAN Arrival Sep.1</h2><iframe src="//player.bilibili.com/player.html?aid=31170181&cid=54452885&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Opening-Ceremony-Sep-2"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Opening-Ceremony-Sep-2" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Opening Ceremony Sep.2"></a>【国际信息学奥赛】IOI 2018 JAPAN Opening Ceremony Sep.2</h2><iframe src="//player.bilibili.com/player.html?aid=31170329&cid=54453483&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Contest-Day-1-Sep-3"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Contest-Day-1-Sep-3" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Contest Day 1 Sep.3"></a>【国际信息学奥赛】IOI 2018 JAPAN Contest Day 1 Sep.3</h2><iframe src="//player.bilibili.com/player.html?aid=31170416&cid=54453749&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Excursion-1-Sep-4"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Excursion-1-Sep-4" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Excursion 1 Sep.4"></a>【国际信息学奥赛】IOI 2018 JAPAN Excursion 1 Sep.4</h2><iframe src="//player.bilibili.com/player.html?aid=31170517&cid=54453902&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Contest-Day-2-Sep-5"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Contest-Day-2-Sep-5" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Contest Day 2 Sep.5"></a>【国际信息学奥赛】IOI 2018 JAPAN Contest Day 2 Sep.5</h2><iframe src="//player.bilibili.com/player.html?aid=31227878&cid=54561289&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Excursion-2-Sep-6"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Excursion-2-Sep-6" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Excursion 2 Sep.6"></a>【国际信息学奥赛】IOI 2018 JAPAN Excursion 2 Sep.6</h2><iframe src="//player.bilibili.com/player.html?aid=31289328&cid=54674520&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【国际信息学奥赛】IOI-2018-JAPAN-Closing-Ceremony-Sep-7"><a href="#【国际信息学奥赛】IOI-2018-JAPAN-Closing-Ceremony-Sep-7" class="headerlink" title="【国际信息学奥赛】IOI 2018 JAPAN Closing Ceremony Sep.7"></a>【国际信息学奥赛】IOI 2018 JAPAN Closing Ceremony Sep.7</h2><iframe src="//player.bilibili.com/player.html?aid=31341076&cid=54768422&page=1" width=745 height=545 scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>这些视频都是一些剪辑，至于比赛，开幕式等完整过程，在ioi官网有，不过是在NicoNico以直播的形式放送的，搬运难度大，而且费时间，NOIP前并没有搬运的打算。</p></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1040]加分二叉树</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1040%5D%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1040%5D%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第j个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：<br>    subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。若某个子树为空 ，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空  子树。<br>    试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；<br>    （1）tree的最高加分<br>    （2）tree的前序遍历  </p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行：一个整数n（n＜30），为节点个数。</p><p> 第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。</p><p>第2行：n个用空格隔开的整数，为该树的前序遍历。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>55 7 1 2 10</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>1453 1 2 4 5</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一道入门的区间dp，当然，根据写法不同你还可以把它归类为树形dp或者记忆化搜索，其实都无所谓啦。<br>作为一道入门题，我们完全可以“显然”地做出来，但是在这里还是想和大家回顾下动态规划以及区间动规。  </p><p>Q：dp特点是什么？<br>A：dp把原问题视作若干个<strong>重叠</strong>的子问题的逐层递进，每个子问题的求解过程都会构成一个“阶段”，在完成一个阶段后，才会执行下一个阶段。<br>Q：dp要满足无后效性，什么叫无后效性？<br>A：已经求解的子问题不受后续阶段的影响。</p><p>有人觉得dp很抽象，那是因为没有一步一步来想，直接听别人的结论，我们在这里以这道题为例，一步一步来推导。</p><p>首先，我们要做的就是<strong>设计状态</strong>，其实就是设计dp数组的含义，它要满足无后效性。<br>关注这个  <em>左子树*右子树+根</em> 我只要知道左子树分数和右子树分数和根的分数（已给出），不就可以了吗？管他子树长什么样！<br>所以，我们[latex]f[/latex]数组存的就是最大分数，怎么存呢？<br>我们发现：子树是一个或多个节点的集合。<br>那么我们可不可以开一个[latex]f[i][j][/latex]来表示节点i到节点j成树的最大加分呢？可以先保留这个想法（毕竟暂时也想不到更好的了）。 </p><p>如果这样话，我们就来设计状态转移方程。<br>按照刚刚的设计来说的话，我们的答案就是[latex]f[1][n][/latex]了，那么我们可以从小的子树开始，也就是len，区间长度。有了区间长度我们就要枚举区间起点，i为区间起点，然后就可以算出区间终点j。<br>通过加分二叉树的式子我们可以知道，二叉树的分取决于谁是根，于是我们就在区间内枚举根k。<br>特别的，[latex]f[i][i]=a[i][/latex]其中a[i]为第i个节点的分数。<br>因为是要求最大值，所以我们就可以设计出<br>$$f[i][j]=MAX(f[i][k-1]*f[k+1][j]+f[k][k])$$<br>于是乎，我们就自己设计出了一个dp过程，因为是顺着来的，所以很少有不成立的。  </p><p>至于输出前序遍历，我们再设计一个状态[latex]root[i][j][/latex]来表示节点i到节点j成树的最大加分所选的根节点。<br>所以我们按照[latex]根-&gt;左-&gt;右[/latex]的顺序递归输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN = 50;typedef long long ll;ll n;ll f[MAXN][MAXN], root[MAXN][MAXN];void print(ll l, ll r) &#123;    if (l &amp;gt; r)return;    printf(&amp;quot;%lld &amp;quot;, root[l][r]);    if (l == r)return;    print(l, root[l][r] - 1);    print(root[l][r]+1,r);&#125;int main() &#123;    scanf(&amp;quot;%lld&amp;quot;, &amp;amp;n);    for (int i = 1; i &amp;lt;= n; i++)scanf(&amp;quot;%lld&amp;quot;, &amp;amp;f[i][i]),f[i][i-1]=1, root[i][i] = i;    for (int len = 1; len &amp;lt; n; ++len) &#123;        for (int i = 1; i + len &amp;lt;= n; ++i) &#123;            int j = i + len;            f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解            root[i][j] = i;//默认从起点选根            for (int k = i + 1; k &amp;lt; j; ++k) &#123;                if (f[i][j] &amp;lt; f[i][k - 1] * f[k + 1][j] + f[k][k]) &#123;                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];                    root[i][j] = k;                &#125;            &#125;        &#125;    &#125;    cout &amp;lt;&amp;lt; f[1][n] &amp;lt;&amp;lt; endl;    print(1, n);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1771] 方程的解</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1771%5D%20%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1771%5D%20%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>佳佳碰到了一个难题，请你来帮忙解决。</p><p>对于不定方程a1+a2+…+ak-1+ak=g(x)，其中k≥2且k∈N，x是正整数，g(x)=x^x mod 1000(即x^x除以1000的余数)，x，k是给定的数。我们要求的是这个不定方程的正整数解组数。</p><p>举例来说，当k=3，x=2时，分别为(a1,a2,a3)=(2,1,1)’(1,2,1)，(1,1,2)。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件equation.in有且只有一行，为用空格隔开的两个正整数，依次为k，x。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件equation.out有且只有一行，为方程的正整数解组数。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>3 2</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>3</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于40%的数据，ans≤10^16；对于100%的数据，k≤100，x≤2^31-1，k≤g(x)。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先呢，[latex]g(x)[/latex]我们是可以求解的，我们设[latex]n=g(x)[/latex]<br>我们可以先写出[latex]n[/latex]个1，我们发现它们之间有[latex]n-1[/latex]个空隙，而我们的任务是寻找k个数，使k个数的和等于[latex]n[/latex]，于是我们就可以将问题转化成在[latex]n-1[/latex]个空隙中选出[latex]k-1[/latex]个空隙放挡板，形成的[latex]k[/latex]个数的和正好就是[latex]n[/latex]。<br>换句话说，我们要求[latex]C_{n-1}^{k-1}[/latex]<br>对于样例的画图辅助理解<br><img src="https://s1.ax1x.com/2018/08/15/PRdr7Q.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;typedef long long ll;const int MAXN = 100, mod = 1000, inf = 1000000;ll k, x, n;ll sum[MAXN], cnt = 1;ll qpow(ll a, ll b) &#123;    ll ans = 1;    while (b) &#123;        if (b &amp;amp; 1)ans = ans * a%mod;        a = a * a%mod;        b &amp;gt;&amp;gt;= 1;    &#125;    return ans;&#125;void c(ll n, ll m) &#123;    sum[1] = 1, cnt = 1;    for (int i = m; i &amp;gt;= m - n + 1; i--) &#123;//对组合数公式进行了化简        for (int j = 1; j&amp;lt;MAXN; j++) &#123;            sum[j] *= i;        &#125;        for (int j = 1; j&amp;lt;MAXN; j++) &#123;            if (sum[j] &amp;gt;= inf) &#123;                sum[j + 1] += sum[j] / inf;                sum[j] %= inf;            &#125;        &#125;    &#125;    for (int i = 2; i &amp;lt;= n; i++) &#123;        for (int j = MAXN-1; j &amp;gt;= 1; j--) &#123;            if (sum[j] == 0)   continue;            if (sum[j] &amp;gt;= i) &#123;                sum[j - 1] += sum[j] % i*inf;                sum[j] /= i;            &#125;            else sum[j - 1] += sum[j] * inf, sum[j] = 0;        &#125;    &#125;&#125;int main() &#123;    ll k, x;    cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; x;    n = qpow(x, x);    if (k - 1 &amp;lt;= 0 || n - 1 &amp;lt;= 0) &#123;        printf(&amp;quot;0&amp;quot;);        return 0;    &#125;    c(k - 1, n - 1);//总共有n-1个间隙，要插k-1个隔板；    int id;    for (int i = MAXN - 1; i &amp;gt;= 1; i--) &#123;        if (sum[i]) &#123;            id = i;            break;        &#125;    &#125;    printf(&amp;quot;%lld&amp;quot;, sum[id]);    for (int i = id-1; i &amp;gt;= 1; i--) &#123;        printf(&amp;quot;%06lld&amp;quot;, sum[i]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[UVA10140]Prime Distance</title>
    <link href="/2018/10/01/%5BUVA10140%5DPrime%20Distance/"/>
    <url>/2018/10/01/%5BUVA10140%5DPrime%20Distance/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by 1 and itself). The first prime numbers are 2,3,5,7 but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, 2,3 are the only adjacent primes that are also adjacent numbers.<br>Your program is given 2 numbers: L and U (1&lt;=L&lt; U&lt;=2,147,483,647), and you are to find the two adjacent primes C1 and C2 (L&lt;=C1&lt; C2&lt;=U) that are closest (i.e. C2-C1 is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes D1 and D2 (L&lt;=D1&lt; D2&lt;=U) where D1 and D2 are as distant from each other as possible (again choosing the first pair if there is a tie).<br>Input</p><p>给定两个整数 L,R，求闭区间 [L,R]中相邻两个质数差值最小的数对与差值最大的数对。当存在多个时，输出靠前的素数对。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each line of input will contain two positive integers, L and U, with L &lt; U. The difference between L and U will not exceed 1,000,000.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each L and U, the output will either be the statement that there are no adjacent primes (because there are less than two primes between the two given numbers) or a line giving the two pairs of adjacent primes.</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>2 1714 17</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>2,3 are closest, 7,11 are most distant.There are no adjacent primes.</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>部分内容来自李煜东所著《算法进阶指南》  </p><p>暴力是不可能的，R的范围太大了。<br>但是我们发现，R-L的范围很小，有什么办法可以求出R-L之间的质数呢？<br>显然：  </p><blockquote><p>定理：如果n是一个合数， 那么n一定有一个不超过[latex]\sqrt{n}[/latex]的素数因子<br>推论：任意一个合数n必定包含一个不超过[latex]\sqrt{n}[/latex]的质因子</p></blockquote><p>用质因数分解定理可以简单证明。<br>所以，我们只要用筛法求出[latex]2[/latex]~[latex]\sqrt{R}[/latex]之间所有的质数，对于每个质数p，把[latex][L,R][/latex]中能被p整除的数标记，即标记[latex]i*p\left(\Big\lceil\frac{L}{P}\Big\rceil\le\Big\lceil\frac{R}{P}\Big\rceil\right)[/latex]为合数。<br>最终所有还没有被标记的数就是[latex]\left[L,R\right][/latex]中的质数。对相邻质数两两比较，找出差最大的即可。<br>时间复杂度为[latex]O\left(\sum_{质数p\le\sqrt{R}}\frac{R-L}{p}\right)=O\left(\sqrt{R}loglog\sqrt{R}+(R-L)loglogR\right)[/latex]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN = 46345;typedef long long ll;int p[MAXN],cnt,l,r,m;bool v[1000001];int b[1000001];void prime() &#123;    memset(v, 1, sizeof(v));    for (int i = 2; i &amp;lt;= MAXN; i++)        if (v[i])&#123;            p[++cnt] = i;            for (int j = 2; j &amp;lt;= 46340 / i; j++) v[i*j] = false;        &#125;&#125;int main() &#123;    prime();    while (cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r) &#123;        memset(v, 1, sizeof(v));        if (l == 1) v[0] = false;        for (ll i = 1; i &amp;lt;= cnt; i++)            for (ll j = l / p[i]; j &amp;lt;= r / p[i]; j++) &#123;                if (p[i] * j - l &amp;lt; 0)continue;//这里不加，poj过不了                if (j &amp;gt; 1) v[p[i] * j - l] = false;            &#125;        m = 0;        for (ll i = l; i &amp;lt;= r; i++)&#123;//这里一定要开ll的i，要不然溢出了就会死循环            if (v[i - l]) b[++m] = i;        &#125;        ll t1 = 2147483647; ll t2 = 0;        ll x1, x2, y1, y2;        for (ll i = 1; i&amp;lt;m; i++)&#123;            ll cha = b[i + 1] - b[i];            if (cha&amp;lt;t1) &#123; t1 = cha; x1 = b[i]; y1 = b[i + 1]; &#125;            if (cha&amp;gt;t2) &#123; t2 = cha; x2 = b[i]; y2 = b[i + 1]; &#125;        &#125;        if (!t2) cout &amp;lt;&amp;lt; &amp;quot;There are no adjacent primes.\n&amp;quot;;        else cout &amp;lt;&amp;lt; x1 &amp;lt;&amp;lt; &amp;#039;,&amp;#039; &amp;lt;&amp;lt; y1 &amp;lt;&amp;lt; &amp;quot; are closest, &amp;quot; &amp;lt;&amp;lt; x2 &amp;lt;&amp;lt; &amp;#039;,&amp;#039; &amp;lt;&amp;lt; y2 &amp;lt;&amp;lt; &amp;quot; are most distant.\n&amp;quot;;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1445][Violet]樱花</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1445%5D%5BViolet%5D%E6%A8%B1%E8%8A%B1/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1445%5D%5BViolet%5D%E6%A8%B1%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求方程<br>$$ \frac{1}{X}+\frac{1}{Y}=\frac{1}{N!} $$<br>的正整数解的组数，其中N≤10^6。<br>解的组数，应模1e9+7。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个整数N</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出答案</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote><p>部分内容参考自<a href="http://blog.csdn.net/fop_zz/article/details/73551108">这篇文章</a></p></blockquote><p>$$ \frac{1}{x}+\frac{1}{y}=\frac{1}{n!} $$</p><p>先通分</p><p>$$ \frac{(x+y)}{xy}=\frac{1}{n!} $$</p><p>再化整数</p><p>$$ xy-(x+y)*n!=0 $$</p><p>然后配平</p><p>$$ (n!)^2-(x+y)*n!+xy=(n!)^2 $$</p><p>最后</p><p>$$ (x-n!)*(y-n!)=(n!)^2 $$</p><p>然后我们发现$x，y$都要是正整数；</p><p>所以原题可以变为</p><p>$$ A*B=(n!)^2 $$</p><p>当[latex]A*B[/latex]为正整数的时候[latex]x,y[/latex]显然也是正整数；<br>[latex]x,y[/latex]可以是任意正整数，即[latex]A,B[/latex]可以为任意正整数，我们就可以对[latex]x[/latex]单独进行讨论<br>我们考虑[latex]x[/latex]的取值，显然，若一个质数[latex]p[/latex]有[latex]k[/latex]个，那么[latex]x[/latex]可以取[latex]p^0,p^1….p^k[/latex] 共<a href="k+1">latex</a>[/latex]种情况<br>乘法原理乘起来就可以了,而且显然，x确定后，y必然也会被确定<br>那么我们先可以筛出质数（这里是埃氏筛法）；<br>求出每个数的最小质因数然后暴力就好了；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;const int MAXN=1000005;const int mod=1e9+7;int n;long long v[MAXN],phi[MAXN],p[MAXN],cnt;int c[MAXN];int main()&#123;    cin&amp;gt;&amp;gt;n;    for(int i=2;i&amp;lt;=n;i++)&#123;        if(v[i])continue;        p[++cnt]=i;        for(int j=1;j*i&amp;lt;=n;j++)v[i*j]=1;    &#125;    long long k=0,ans=1;    for(int i=1;i&amp;lt;=cnt;i++)&#123;        int pri=p[i],c1=0;        for(int j=n;j;j/=pri)&#123;            c1+=j/pri;        &#125;        c[++k]=c1;    &#125;    for(int i=1;i&amp;lt;=cnt;i++)ans=ans*(c[i]*2+1)%mod;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[poj2559]Largest Rectangle in a Histogram</title>
    <link href="/2018/10/01/%5Bpoj2559%5DLargest%20Rectangle%20in%20a%20Histogram/"/>
    <url>/2018/10/01/%5Bpoj2559%5DLargest%20Rectangle%20in%20a%20Histogram/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:<br><img src="https://cdn.luogu.org/upload/vjudge_pic/SP1805/b9567e3483620f1fe679470ac44083eae9842e79.png"><br>Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1 &lt;= n &lt;= 100000. Then follow n integers h1, …, hn, where 0 &lt;= hi &lt;= 1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>7 2 1 4 5 1 3 34 1000 1000 1000 10000</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>84000</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote><p>部分内容来自李煜东所著《算法竞赛进阶指南》</p></blockquote><p>如果说这道题矩形的高度是递增的，估计就是一道普及难度的题了吧。<br>我们可以尝试以每个矩形的高度作为最终矩形的高度，并将宽度扩展到右边界，答案取最大值。  </p><p>简单归简单，不过这也给了我们一个启发，如果是递增的我们就放着不管，以后来处理。如果说下一个高度更小，那么用它所构成的矩形的高度不可能超过它自己，而后面的矩形想要和前面的矩形拼接的话，高度也不能超过它。<br>这样子的话，我们就可以用上面的方法更新比当前矩形高的矩形的答案再将它们合并。</p><p>这就是<strong>单调栈</strong>算法，时间复杂度 $ O(N) $<br>借助单调性处理问题的思想在于<strong>及时排除不可能的选项，保持策略集合的高度有效性和秩序性</strong>  </p><p>就这拿道题举例，我们建立一个栈，用来保存若干个矩形，这些矩形的高度是<strong>单调递增</strong>的，或者说，我们期望他是<strong>单调递增</strong>的。<br>我们从左到右读入矩形：<br>如果当前矩形比栈顶矩形高，即满足<strong>单调递增</strong>，进栈。<br>否则不断去除栈顶，直至栈空或栈顶高度低于当前矩形。在此过程中，我们累计被弹出的矩形的宽度和（用于计算答案与合并），用高度×累计宽度更新答案。而后，将一个宽度为累计宽度，高度为当前矩形的矩形入栈。<br>结束，将剩余矩形弹出，和上面一样更新答案；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt; #include&amp;lt;algorithm&amp;gt;using namespace std;int n,p;int a[100010];int s[100010],w[100010];long long ans;int main()&#123;    while(cin&amp;gt;&amp;gt;n&amp;amp;&amp;amp;n)    &#123;        ans=0; p=0;        for(int i=1;i&amp;lt;=n;i++) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);        a[n+1]=0;        for(int i=1;i&amp;lt;=n+1;i++)        &#123;            if(a[i]&amp;gt;s[p]) s[++p]=a[i],w[p]=1;            else&#123;                int width=0;                while(s[p]&amp;gt;a[i])                &#123;                    width+=w[p];                    ans=max(ans,(long long)width*s[p]);                    p--;                &#125;                s[++p]=a[i],w[p]=width+1;            &#125;        &#125;        cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[UVA540]Team Queue</title>
    <link href="/2018/10/01/%5BUVA540%5DTeam%20Queue/"/>
    <url>/2018/10/01/%5BUVA540%5DTeam%20Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Queues and Priority Queues are data structures which are known to most computer scientists. The<br>Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the<br>queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches<br>the queue from head to tail to check if some of its teammates (elements of the same team) are already<br>in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail<br>and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are<br>processed from head to tail in the order they appear in the team queue.<br>Your task is to write a program that simulates such a team queue.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The input file will contain one or more test cases. Each test case begins with the number of teams<br>t (1 ≤ t ≤ 1000). Then t team descriptions follow, each one consisting of the number of elements<br>belonging to the team and the elements themselves. Elements are integers in the range 0..999999. A<br>team may consist of up to 1000 elements.<br>Finally, a list of commands follows. There are three different kinds of commands:<br>• ENQUEUE x — enter element x into the team queue<br>• DEQUEUE — process the first element and remove it from the queue<br>• STOP — end of test case<br>The input will be terminated by a value of 0 for t.<br>Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the implementation<br>of the team queue should be efficient: both enqueing and dequeuing of an element should<br>only take constant time.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, first print a line saying ‘Scenario #k’, where k is the number of the test case. Then,<br>for each ‘DEQUEUE’ command, print the element which is dequeued on a single line. Print a blank line<br>after each test case, even after the last one.</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>23 101 102 1033 201 202 203ENQUEUE 101ENQUEUE 201ENQUEUE 102ENQUEUE 202ENQUEUE 103ENQUEUE 203DEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP25 259001 259002 259003 259004 2590056 260001 260002 260003 260004 260005 260006ENQUEUE 259001ENQUEUE 260001ENQUEUE 259002ENQUEUE 259003ENQUEUE 259004ENQUEUE 259005DEQUEUEDEQUEUEENQUEUE 260002ENQUEUE 260003DEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP0</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>Scenario #1101102103201202203Scenario #2259001259002259003259004259005260001</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;int team[1000002],cnt;string s;int t;int main()&#123;    while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;t)!=EOF)&#123;        cnt++;        queue&amp;lt;int&amp;gt;tque[1001];        queue&amp;lt;int&amp;gt;mque;        int flag=0;        for(int i=1;i&amp;lt;=t;i++)&#123;            int num;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;num);            for(int j=1;j&amp;lt;=num;j++)&#123;                int tmp;                scanf(&amp;quot;%d&amp;quot;,&amp;amp;tmp);                team[tmp]=i;            &#125;        &#125;        while(cin&amp;gt;&amp;gt;s)&#123;            if(s==&amp;quot;STOP&amp;quot;)&#123;                printf(&amp;quot;\n&amp;quot;);                break;            &#125;            if(s==&amp;quot;ENQUEUE&amp;quot;)&#123;                int num;                scanf(&amp;quot;%d&amp;quot;,&amp;amp;num);                if(tque[team[num]].empty())&#123;                    mque.push(team[num]);                    tque[team[num]].push(num);                &#125;                else tque[team[num]].push(num);            &#125;            if(s==&amp;quot;DEQUEUE&amp;quot;)&#123;                if(flag==0)&#123;                    printf(&amp;quot;Scenario #%d\n&amp;quot;,cnt);                    flag=1;                &#125;                while(tque[mque.front()].empty())&#123;                    mque.pop();                &#125;                printf(&amp;quot;%d\n&amp;quot;,tque[mque.front()].front());                tque[mque.front()].pop();            &#125;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[UVA1330]City Game</title>
    <link href="/2018/10/01/%5BUVA1330%5DCity%20Game/"/>
    <url>/2018/10/01/%5BUVA1330%5DCity%20Game/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bob爱上了一个策略游戏（Simcity？）游戏中一个城市由k个地区组成，每个地区都是一块长N×宽M大小的网格矩形,其中可能有些网格已被占用，用R表示;有些则是空地，用F表示。</p><p>游戏中可以在空着的空间上建一个矩形的建筑，同时每个建筑按它所占的空地网格数来收租，每占用一个网格可收租金3美元。Bob想知道每个地区中最大面积建筑物能收多少租金。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是地区个数k。然后接下给出k个地区的相关信息。 相关信息用以下方式输入：</p><p>第一行有两个整数n,m (n,m&lt;= 1000),表示这个地区长n宽m</p><p>然后接下来有n行，每行m个字符表示网格的信息，相邻的两个用空格隔开。R表示该网格被占用；F表示该网格是空地，可使用。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一个地区，输出一行一个整数表示该地区中最大面积建筑物能收到的租金。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>POJ dicuss中有人反映数据输出可能不严格按照要求（例如：两个字符间有多个空格），建议使用cin等读入。</p><p>感谢@Rye_Catcher 提供的翻译</p><h2 id="英文题面"><a href="#英文题面" class="headerlink" title="英文题面"></a><a href="https://uva.onlinejudge.org/external/13/p1330.pdf">英文题面</a></h2><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>33 3R R FF F FF R F5 6R F F F F FF R F F F FF F R F F FF F F R F FF F F F R R4 5R R R R RR R F R RR R R R RR R F R R</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>9273</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int n,m,ans;int city[1001][1001];int solve(int r)&#123;    int s[1002],len[1002],p=0,ans=0;    city[n+1][r]=0;    for(int i=1;i&amp;lt;=n+1;i++)&#123;        if(city[i][r]&amp;gt;s[p])s[++p]=city[i][r],len[p]=1;        else &#123;            int lenth=0;            while(s[p]&amp;gt;city[i][r])&#123;                lenth+=len[p];                ans=max(ans,lenth*s[p]);                p--;            &#125;            if(city[i][r])s[++p]=city[i][r],len[p]=lenth+1;        &#125;    &#125;    return ans;&#125;int main()&#123;    int t;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);    while(t--)&#123;        ans=0;        memset(city,0,sizeof(city));        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);        for(int i=1;i&amp;lt;=n;i++)&#123;            int last=0;            for(int j=1;j&amp;lt;=m;j++)&#123;                char op;                cin&amp;gt;&amp;gt;op;                if(op==&amp;#039;R&amp;#039;)&#123;                    for(int k=last+1;k&amp;lt;j;k++)city[i][k]=j-k;                    last=j;                &#125;                else if(j==m)&#123;                    for(int k=last+1;k&amp;lt;=j;k++)city[i][k]=j-k+1;                &#125;            &#125;        &#125;        for(int i=1;i&amp;lt;=m;i++)&#123;            ans=max(ans,solve(i));        &#125;        cout&amp;lt;&amp;lt;ans*3&amp;lt;&amp;lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1312]Mayan游戏</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1312%5DMayan%E6%B8%B8%E6%88%8F/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1312%5DMayan%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个 7 行 ×5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：</p><p>1 、每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图 6  到图 7 ）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；<br><img src="https://cdn.luogu.org/upload/pic/103.png"><br>2 、任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。<br><img src="https://cdn.luogu.org/upload/pic/102.png"><br>注意：</p><p>a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图 4 ，三个颜色为 1 的方块和三个颜色为 2 的方块会同时被消除，最后剩下一个颜色为 2 的方块）。</p><p>b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。</p><p>3 、方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。</p><p>上面图1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0 ），将位于（3, 3 ）的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图 3 所示的局面。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 6 行。</p><p>第一行为一个正整数 n，表示要求游戏通关的步数。</p><p>接下来的 5行，描述7×5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个 0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于 10 种，从 1 开始顺序编号，相同数字表示相同颜色）。</p><p>输入数据保证初始棋盘中没有可以消除的方块。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果有解决方案，输出 n 行，每行包含 3 个整数 x,y,g，表示一次移动，每两个整数之间用一个空格隔开，其中 (x ,y)表示要移动的方块的坐标， g 表示移动的方向， 1 表示向右移动， −1 表示向左移动。注意：多组解时，按照 x 为第一关健字， y 为第二关健字， 1 优先于 −1 ，给出一组字典序最小的解。游戏界面左下角的坐标为 (0 ,0) 。</p><p>如果没有解决方案，输出一行，包含一个整数 -1 。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>31 02 1 02 3 4 03 1 02 4 3 4 0</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>2 1 13 1 13 0 1</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>【输入输出样例说明】</p><p>按箭头方向的顺序分别为图 6 到图 11<br><img src="https://cdn.luogu.org/upload/pic/104.png"><br>样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：(2,1) 处的方格向右移动，(3,1) 处的方格向右移动,(3,0)处的方格向右移动，最后可以将棋盘上所有方块消除。</p><p>【数据范围】</p><p>对于 30% 的数据，初始棋盘上的方块都在棋盘的最下面一行；</p><p>对于 100% 的数据，0&lt;n≤5。</p><p>noip2011提高组day1第3题</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;stack&amp;gt;#define scanf scanf_susing namespace std;int a[5][7],tag[5][7],cnt[10];int n;struct Node&#123;    int x,y,z;&#125;;stack&amp;lt;Node&amp;gt;ans;bool emp(void)&#123;    for(int i=0;i&amp;lt;5;++i)        for(int j=0;j&amp;lt;7;++j)             if(a[i][j])return 0;    return 1;&#125;void drop(int x,int y)&#123;    int p=y-1;    while(p&amp;gt;=0&amp;amp;&amp;amp;!a[x][p])--p;    swap(a[x][y],a[x][p+1]);&#125;bool check()&#123;//消去    memset(tag,0,sizeof(tag));//先把要消的标记起来，不能直接删除    bool flag=0;//有没有消去    for(int i=0;i&amp;lt;5;i++)&#123;        for(int j=0;j&amp;lt;7;j++)&#123;            if(!a[i][j])continue;            if(i+2&amp;lt;5&amp;amp;&amp;amp;a[i][j]==a[i+1][j]&amp;amp;&amp;amp;a[i+1][j]==a[i+2][j])//横着消                tag[i][j]=tag[i+1][j]=tag[i+2][j]=1;            if(j+2&amp;lt;7&amp;amp;&amp;amp;a[i][j]==a[i][j+1]&amp;amp;&amp;amp;a[i][j+1]==a[i][j+2])//竖着消                tag[i][j]=tag[i][j+1]=tag[i][j+2]=1;        &#125;    &#125;    for(int i=0;i&amp;lt;5;++i)//消除        for(int j=0;j&amp;lt;7;++j)             if(tag[i][j])&#123;                flag=1;                a[i][j]=0;            &#125;    for(int i=0;i&amp;lt;5;++i)//下落        for(int j=1;j&amp;lt;7;++j)             if(a[i][j]&amp;amp;&amp;amp;(!a[i][j-1])) drop(i,j);    return flag;&#125;void move(int x,int y,int z)&#123;//移动    int nx=x+z,ny=y;    swap(a[x][y],a[nx][ny]);    drop(nx,ny);    while(++y&amp;lt;7&amp;amp;&amp;amp;a[x][y])drop(x,y);    while(check());&#125;bool dfs(int p)&#123;    int tmp[5][7];    bool ok=emp();    if(ok&amp;amp;&amp;amp;p==n+1)return 1;    else if(ok||p==n+1)return 0;    memcpy(tmp,a,sizeof(a));    for(int i=0;i&amp;lt;5;i++)&#123;        for(int j=0;j&amp;lt;7;j++)&#123;            if(a[i][j])&#123;                if(i!=4&amp;amp;&amp;amp;a[i][j]!=a[i+1][j])&#123;//不在最右边并且和右边的颜色不同                    move(i,j,1);                    if(dfs(p+1))&#123;                        Node o=&#123;i,j,1&#125;;                        ans.push(o);                        return 1;                    &#125;                    memcpy(a,tmp,sizeof(a));//回溯                &#125;                if(i!=0&amp;amp;&amp;amp;a[i][j]!=a[i-1][j]&amp;amp;&amp;amp;a[i-1][j]==0)&#123;                    move(i,j,-1);                    if(dfs(p+1))&#123;                        Node o=&#123;i,j,-1&#125;;                        ans.push(o);                        return 1;                    &#125;                    memcpy(a,tmp,sizeof(a));                &#125;            &#125;        &#125;    &#125;    return 0;&#125;int main()&#123;    cin&amp;gt;&amp;gt;n;    for(int i=0;i&amp;lt;5;i++)&#123;        int b=1;        int cnt=0;        while(b!=0)&#123;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;b);            a[i][cnt++]=b;        &#125;    &#125;    check();    dfs(1);    Node t;    int cnt=0;    if(ans.empty())cout&amp;lt;&amp;lt;&amp;quot;-1&amp;quot;;    while(!ans.empty())&#123;        t=ans.top();        ans.pop();        printf(&amp;quot;%d %d %d\n&amp;quot;,t.x,t.y,t.z);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[BZOJ4195][Noi2015]程序自动分析</title>
    <link href="/2018/10/01/%5BBZOJ4195%5D%5BNoi2015%5D%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90/"/>
    <url>/2018/10/01/%5BBZOJ4195%5D%5BNoi2015%5D%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设x1,x2,x3,…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。<br>现在给出一些约束满足问题，请分别对它们进行判定。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：<br>第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。<br>接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件包括t行。</p><p>输出文件的第k行输出一个字符串“YES”或者“NO”（不包含引号，字母全部大写），“YES”表示输入中的第k个问题判定为可以被满足，“NO”表示不可被满足。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>221 2 11 2 021 2 12 1 1</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>NOYES</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。<br>在第二个问题中，约束条件为：x1=x2,x2=x1。这两个约束条件是等价的，可以被同时满足。<br>1≤n≤1000000<br>1≤i,j≤1000000000  </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int t,n;const int MAXN =10000005;struct node&#123;    int x,y,e;&#125;a[MAXN];int b[MAXN],c[MAXN*2],f[MAXN];int cnt=0;int tot=0;int fla;int ask(int x)&#123;    return lower_bound(b+1,b+tot,x)-b;&#125;void lisan()&#123;    sort(c+1,c+cnt);    for(int i=1;i&amp;lt;=cnt;i++)&#123;        if(i==1||c[i]!=c[i-1])b[++tot]=c[i];    &#125;&#125;int find(int x)&#123;    if(f[x]==x)    return x;    return f[x]=find(f[x]);&#125;bool cmp(node a,node b)&#123;    return a.e&amp;gt;b.e;&#125;int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);    while(t--)&#123;        fla=0;        tot=0,cnt=0;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);        for(int i=1;i&amp;lt;=n;i++)&#123;            scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a[i].x,&amp;amp;a[i].y,&amp;amp;a[i].e);            c[++cnt]=a[i].x,c[++cnt]=a[i].y;        &#125;        lisan();        sort(a+1,a+n+1,cmp);        for(int i=1;i&amp;lt;=tot;i++)f[i]=i;        for(int i=1;i&amp;lt;=n;i++)&#123;            a[i].x=ask(a[i].x);            a[i].y=ask(a[i].y);            if(a[i].e)&#123;                f[find(a[i].x)]=find(a[i].y);            &#125;            else&#123;                if(find(a[i].x)==find(a[i].y))&#123;                    fla=1;break;                &#125;            &#125;        &#125;        if(fla)    printf(&amp;quot;NO\n&amp;quot;);        else printf(&amp;quot;YES\n&amp;quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[原创题]断罪者</title>
    <link href="/2018/10/01/%5B%E5%8E%9F%E5%88%9B%E9%A2%98%5D%E6%96%AD%E7%BD%AA%E8%80%85/"/>
    <url>/2018/10/01/%5B%E5%8E%9F%E5%88%9B%E9%A2%98%5D%E6%96%AD%E7%BD%AA%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/T46939">题目</a></p><h1 id="比赛描述不是我写的！！！！"><a href="#比赛描述不是我写的！！！！" class="headerlink" title="比赛描述不是我写的！！！！"></a>比赛描述不是我写的！！！！</h1><p>回过神来发现就公开赛已经已经过审了orz  </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题目有一个思维陷阱，那就是题目过分强调了<strong>集合</strong>的概念，导致大家一拿到这个题目就会往并查集上面去向，不过稍微玩过数据之后就会发现，这其实就是一道简单的维护最大值的题目。</p><p>因为本次比赛的题目原本是OI赛制，在我们学校内部考的，所以这道题给了几个梯度，顺着梯度来是很好想到正解的，但是想要实现还是要有不错的代码功底。（为了防止网络赛的复制模板的行为，特意复杂化了题目）</p><h2 id="优先队列——期望得分30"><a href="#优先队列——期望得分30" class="headerlink" title="优先队列——期望得分30"></a>优先队列——期望得分30</h2><p>观察约定我们发现，有6个点是既满足没有单点修改（清零），又满足单点插入（合并）的性质，很容易想到用优先队列维护。<br>优先队列里存的是一个二元组，分别是该点的值以及编号。<br>但是优先队列有个问题就是没办法单点修改，这时候就要我们手写堆。</p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;const int MAXN=2000001;long long m,n,w,k,t;priority_queue&amp;lt;pair&amp;lt;long long,int&amp;gt; &amp;gt;s[MAXN];int set[MAXN];//i点在哪个优先队列里，并查集实现bool v[MAXN];//确保每个集合只贡献一次答案inline long long read() &#123;    char ch = getchar(); long long x = 0, f = 1;     while(ch &amp;lt; &amp;#039;0&amp;#039; || ch &amp;gt; &amp;#039;9&amp;#039;) &#123;        if(ch == &amp;#039;-&amp;#039;) f = -1;        ch = getchar();    &#125; while(&amp;#039;0&amp;#039; &amp;lt;= ch &amp;amp;&amp;amp; ch &amp;lt;= &amp;#039;9&amp;#039;) &#123;        x = x * 10 + ch - &amp;#039;0&amp;#039;;        ch = getchar();    &#125; return x * f;&#125;void clear()&#123;//每组输入要重置    memset(set,0,sizeof(set));    memset(v,0,sizeof(v));&#125;int main()&#123;    cin&amp;gt;&amp;gt;t&amp;gt;&amp;gt;w&amp;gt;&amp;gt;k;    while(t--)&#123;        clear();        n=read(),m=read();        for(int i=1;i&amp;lt;=n;i++)&#123;            while(s[i].size())s[i].pop();//这里会比较慢             long long a;            a=read();            set[i]=i;            s[i].push(make_pair(a,i));        &#125;        while(m--)&#123;            long long way,a,b;            way=read();            if(way==2)a=read();//不管2操作            else if(way==3)&#123;//由于优先队列是只读的，所以要先取出来再弄进去                a=read(),b=read();                a=set[a];                pair&amp;lt;long long,int&amp;gt; tmp=s[a].top();                s[a].pop();                tmp.first-=b;                if(tmp.first&amp;lt;0)tmp.first=0;                s[a].push(tmp);            &#125;            else&#123;//将小的集合并入大的集合                a=read(),b=read();                if(a==b)continue;                int sa=set[a],sb=set[b];                if(s[sb].size()==1)swap(sa,sb);                s[sb].push(s[sa].top());                set[s[sa].top().second]=sb;                s[sa].pop();            &#125;        &#125;        long long sum=0,mx=0;        for(int i=1;i&amp;lt;=n;i++)&#123;            if(v[set[i]])continue;            v[set[i]]=1;            sum+=s[set[i]].top().first;            mx=max(mx,s[set[i]].top().first);        &#125;        if(w==2)sum-=mx;        if(w==3)sum+=mx;        if(sum==0)printf(&amp;quot;Gensokyo 0\n&amp;quot;);        else if(sum&amp;lt;=k)printf(&amp;quot;Heaven %lld\n&amp;quot;,sum);        else printf(&amp;quot;Hell %lld\n&amp;quot;,sum);    &#125;     return 0;&#125;</code></pre><h2 id="大根堆——期望得分60"><a href="#大根堆——期望得分60" class="headerlink" title="大根堆——期望得分60"></a>大根堆——期望得分60</h2><p>按照刚刚优先队列的思路，要想单点修改，还得自己写堆。<br>但是因为不确定每个堆的大小，所以不能直接开2000000个堆，所以得用链表实现，或者用数组模拟，这样子就能过掉所有有特殊约定的点。<br>对于不满足约定①的数据，当然也可以将两个堆合并，说不定还能多过一两个点。</p><h2 id="左偏树（或者其他可并堆）——期望得分100"><a href="#左偏树（或者其他可并堆）——期望得分100" class="headerlink" title="左偏树（或者其他可并堆）——期望得分100"></a>左偏树（或者其他可并堆）——期望得分100</h2><p>普通的堆的合并时间复杂度都是[latex]O(n^2)[/latex]的，而对于不满足约定①的数据，我们显然需要一种数据结构，来实现快速合并，通过上面两种方法的引导，我们可以采用可并堆（这里用的是左偏树，最简单的可并堆），合并两个堆的时间复杂度为[latex]O(nlogn)[/latex]</p><p>如果你不清楚左偏树做这道题，在思维的过程中，也应该体会到了左偏树的用法。</p><p>左偏树在维护了堆的性质的同时，还用[latex]dis[/latex]来维护一个距离值，具体是说，节点i的**距离(dis(i))**是节点i到它的子树中，最近的叶子节点所经过的边数。</p><p>两个基本性质：</p><p><strong>[性质1 堆] 节点的键值小于或等于它的左右子节点的键值。</strong></p><p><strong>[性质2 左偏] 节点的左子节点的距离不小于右子节点的距离。</strong>（在合并操作时起作用）</p><p><a href="https://blog.csdn.net/ZY_discovery/article/details/52145143">这里有篇文章</a>专门讲左偏树，比较详细</p><p>然后你会发现这是道模板题（<del>不好意思我太弱了orz</del>），就用<kbd>pb_ds</kbd>库给A掉了。</p><p>先贴我的代码，比较丑，没有常数优化（个人不是很喜欢卡常）</p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN=2000000;long long m,n,w,k,t;int set[MAXN];//并查集bool v[MAXN]; struct node&#123;    long long l,r,dis,key;&#125;tree[MAXN];namespace LF&#123;    int find(int a)&#123;//并查集        int root=a;        while(root!=set[root])root=set[root];        int pa=set[a];        while(pa!=root)&#123;            set[a]=root;            a=pa;            pa=set[a];        &#125;        return root;    &#125;    int merge(int a,int b)&#123;//合并        if(!a)return b;        if(!b)return a;        if(tree[a].key&amp;lt;tree[b].key)swap(a,b);        tree[a].r=merge(tree[a].r,b);        set[tree[a].r]=a;        if(tree[tree[a].l].dis&amp;lt;tree[tree[a].r].dis)swap(tree[a].l,tree[a].r);        if(tree[a].r)tree[a].dis=tree[tree[a].r].dis+1;        else tree[a].dis=0;        return a;    &#125;    int pop(int a)&#123;        int l=tree[a].l;        int r=tree[a].r;        set[l]=l;        set[r]=r;        tree[a].l=tree[a].r=tree[a].dis=0;        return merge(l,r);    &#125;&#125;void clear()&#123;//初始化    memset(set,0,sizeof(set));    memset(v,0,sizeof(v));&#125;int main()&#123;    cin&amp;gt;&amp;gt;t&amp;gt;&amp;gt;w&amp;gt;&amp;gt;k;    while(t--)&#123;        clear();         scanf(&amp;quot;%lld%lld&amp;quot;,&amp;amp;n,&amp;amp;m);        for(int i=1;i&amp;lt;=n;i++)&#123;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;tree[i].key);            set[i]=i;//并查集初始化            tree[i].r=tree[i].l=tree[i].dis=0;        &#125;        while(m--)&#123;            int way;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;way);            if(way==2)&#123;                int x;                scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);                tree[x].key=0;                int tmp=LF::pop(x);                LF::merge(x,tmp);            &#125;            else if(way==3)&#123;                int a,b,ra;                scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);                ra=LF::find(a);                tree[ra].key-=b;                if(tree[ra].key&amp;lt;0)tree[ra].key=0;                int tmp=LF::pop(ra);                LF::merge(tmp,ra);            &#125;            else &#123;                int a,b,ra,rb;                scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);                if(a==b)continue;                ra=LF::find(a),rb=LF::find(b);                LF::merge(ra,rb);            &#125;        &#125;           long long sum=0,mx=0;        for(int j=1;j&amp;lt;=n;j++)&#123;            int i=LF::find(j);            if(v[set[i]])continue;            v[set[i]]=1;            int root=LF::find(i);            mx=max(mx,(long long)tree[root].key);            sum+=tree[root].key;        &#125;        if(w==2)sum-=mx;        if(w==3)sum+=mx;        if(sum==0)printf(&amp;quot;Gensokyo 0\n&amp;quot;);        else if(sum&amp;lt;=k)printf(&amp;quot;Heaven %lld\n&amp;quot;,sum);        else printf(&amp;quot;Hell %lld\n&amp;quot;,sum);    &#125;    return 0;&#125; </code></pre><p>这个是@<a href="https://www.luogu.org/space/show?uid=106642">Ajsoabk</a>大佬写的，短小精悍，加了快读都比我短。</p><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;const int N=2000000+5;struct Node&#123;    int val,disx,lson,rson;&#125;nod[N];int fa[N],t,w,n,m,typ,A,B,tem;bool vis[N];long long k;inline void read(int &amp;amp;num)&#123;    char ch;    while(!isdigit(ch=getchar()));    num=ch-&amp;#039;0&amp;#039;;    while(isdigit(ch=getchar()))num=num*10+ch-&amp;#039;0&amp;#039;;&#125;int merge(int a,int b)&#123;//合并    if(a==0)return b;    if(b==0)return a;    if(nod[a].val&amp;lt;nod[b].val)swap(a,b);    fa[nod[a].rson=merge(nod[a].rson,b)]=a;    nod[a].disx=(nod[a].rson==0)?0:nod[nod[a].rson].disx+1;    if(nod[nod[a].lson].disx&amp;lt;nod[nod[a].rson].disx)swap(nod[a].lson,nod[a].rson);    return a;&#125;int find(const int &amp;amp;a)&#123;//并查集    return (a==fa[a])?a:find(fa[a]);&#125;inline void decline(const int &amp;amp;A,const int &amp;amp;val,bool fla)&#123;    nod[A].val-=val;    if(nod[A].val&amp;lt;0)nod[A].val=0;    fa[nod[A].lson]=nod[A].lson;    fa[nod[A].rson]=nod[A].rson;    int l=nod[A].lson,r=nod[A].rson;    nod[A].lson=nod[A].rson=nod[A].disx=0;    tem=merge(l,r);    if(fla)merge(find(A),tem);    else merge(tem,A);&#125;int main()&#123;    read(t),read(w);    cin&amp;gt;&amp;gt;k;    while(t--)&#123;        read(n),read(m);        for(int i=1;i&amp;lt;=n;++i)fa[i]=i,read(nod[i].val),vis[i]=0,nod[i].lson=nod[i].rson=nod[i].disx=0;        for(int i=1;i&amp;lt;=m;++i)&#123;            read(typ),read(A);            switch(typ)&#123;                case 2:                    decline(A,nod[A].val,1);                    break;                case 3:                    read(B);                    decline(find(A),B,0);                    break;                case 4:                    read(B);                    merge(find(A),find(B));                    break;            &#125;        &#125;        B=0;        typ=0;        for(int i=1;i&amp;lt;=n;++i)&#123;            A=find(i);            if(!vis[A])&#123;                vis[A]=true;                B=max(B,nod[A].val);                typ+=nod[A].val;            &#125;        &#125;        if(w==2)typ-=B;        else if(w==3)typ+=B;        if(typ==0)printf(&amp;quot;Gensokyo &amp;quot;);        else if((long long)typ&amp;lt;=k)printf(&amp;quot;Heaven &amp;quot;);        else printf(&amp;quot;Hell &amp;quot;);        printf(&amp;quot;%d\n&amp;quot;,typ);    &#125;    return 0;&#125;</code></pre><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>其实这道题目一开始还更难，后面就变成了一道模板题</p><p>数据是随机生成的，可能这一点比较坑吧，只要有点微小的差错就会WA（我反省）</p><p>其实数据挺弱的，set+并查集，暴力合并，都只超时1个点</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>宜春中学团委招新啦！！</title>
    <link href="/2018/10/01/%E5%AE%9C%E6%98%A5%E4%B8%AD%E5%AD%A6%E5%9B%A2%E5%A7%94%E6%8B%9B%E6%96%B0%E5%95%A6%EF%BC%81%EF%BC%81/"/>
    <url>/2018/10/01/%E5%AE%9C%E6%98%A5%E4%B8%AD%E5%AD%A6%E5%9B%A2%E5%A7%94%E6%8B%9B%E6%96%B0%E5%95%A6%EF%BC%81%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>在宜中学子中，有这样一群人<br>他们是众多校园活动的策划者，<br>他们协助宜春中学各个社团管理社团事务，<br>他们能带着小牌子穿梭于各项活动，<br>他们常年以学生身份出现于行政楼、科技楼之中<br>他们是谁！<br><font color="FF0000"><strong>——宜春中学团委学生干部</strong></font><br>可爱的新高一学弟学妹们：<br>加入朝气蓬勃的<em>宜春中学团委</em>吧！<br>在这里，你能培养、锻炼管理能力、组织能力、应变能力；<br>在这里，你能得到展现自我，提升自我的机会；<br>在这里，你能感受到组织浓浓的凝聚力；<br>在这里，你能参与组织诗歌朗诵大赛，大型校园义卖，主持人大赛等等精彩的活动；<br>在这里，你能第一时间了解各大活动的第一消息，观看各种精彩活动；<br>在这里，有不定时聚餐，下乡活动等诸多福利<br>在这里，还有高颜值高智商高情商的学长学姐做你们的师父手把手带你成长带你飞！  </p><p>你还在等什么？<br>加入我们，就是最好的选择！  </p><p>让我们一起飞上天，与太阳肩并肩！<br>让我们策马扬鞭，青春年华一起成长！  </p><p>报名安排：<br>8月21、22日下午教学楼旁边摆摊<br>8月23日晚自习初试（具体时间地点另行通知）<br>8月24日晚自习复试（具体时间地点另行通知）  </p><p>另附：<br><img src="https://s1.ax1x.com/2018/07/27/PUkOW6.png" alt="宜春中学团委招新简章">   </p><p><img src="https://s1.ax1x.com/2018/07/27/PU1G1H.md.png"></p><blockquote><p>关注我们<br><img src="https://s1.ax1x.com/2018/07/27/PUkDsg.md.jpg"><br><img src="https://s1.ax1x.com/2018/07/27/PUkrLQ.md.jpg"><br><img src="https://s1.ax1x.com/2018/07/27/PUkBQS.jpg"></p></blockquote><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><pre><code>你可以通过QQ，微信，微博，评论等方式向我们提出问题，这里将集中公示大家的疑问，方便查询。</code></pre><p>Q：团委是社团还是什么？<br>A：中国共产主义青年团委员会的简称是团委，是中国共青团的组织之一，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是中国共产党的助手和后备军。  总而言之不是社团是一个组织。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ISLAND一周目通关感想</title>
    <link href="/2018/10/01/ISLAND%E4%B8%80%E5%91%A8%E7%9B%AE%E9%80%9A%E5%85%B3%E6%84%9F%E6%83%B3/"/>
    <url>/2018/10/01/ISLAND%E4%B8%80%E5%91%A8%E7%9B%AE%E9%80%9A%E5%85%B3%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><center><font color="FF0000">***可能包含严重剧透***</font></center>本来有很多游戏内部短片可以通过B站外链嵌入这里的，但奈何全被封了  </blockquote><blockquote><p>10.1更新：现在已经解禁，而且游戏已上架stream<br><a href="https://store.steampowered.com/app/857450/ISLAND/">Stream上的ISLAND</a></p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=1&id=34700141&auto=1&height=430"></iframe><p><img src="https://s1.ax1x.com/2018/07/26/PNkBcD.png"></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这里要先感谢夜鸮的树洞汉化组带来的汉化，真的是很棒了，ISLAND最近也会上架steam，到时候会补票。<br>本来是在同学的推荐下看了一集ISLAND，一开始我是抵触的，后面发现凛音的人设不错，声优是田村大魔王，于是就打算试试游戏。<br>然后就被震撼到了，不亏是岛学，那种给人带来的沉浸感，是其他galgame难以做到了。  </p><p>接下来会从流程，人物等方面展开讨论ISLAND</p><p>虽说在暑假，但是时间比较少（网上大佬二周目用了80个小时），所以夏莲和纱罗线基本是跳着过的，所以流程的话就会少掉夏莲和纱罗线。</p><p>序言就写这么多，要不然就要变成后记了233</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>有这样一个传说，传说的主人公叫切那，他爱着一个女性，女性的名字叫凛音，凛音也不为人知的爱着切那，但是他们二人有着永远无法结合的命运，因为他们是兄妹，有一个叫夏莲的女孩子对这二人的关系感到不高兴，因为夏莲也爱上了切那，于是她请求魔女无论怎样也要分离二人，于是魔女向二人下了诅咒，魔女把凛音的脸变成谁也不会爱上的怪物的模样，承受如此痛苦的凛音，自己结束了生命，被留下孤身一人的切那，切那也被放逐了，切那与魔女进行了契约，魔女约定，凛音会在这个世界再次重生，然后，二人结合之时诅咒将会解除。但是需要几十年，甚至几百年，并没有和魔女约定好。切那为了停止自己的时间而在冰中沉眠，为了等待着那一天的到来。<br>浦岛上的人信奉这一个传说，并时不时的用传说中的人名给自己的孩子命名，浦岛上的御三家，御原家，珈蓝堂家，枢都家，就是贯彻这一传统的家庭，时至1999年8月，一名男子被冲上浦岛的沙滩，男子被警察发现后，因为枢都镇长的要求，准备将其遣返本土，这是男子在船上邂逅了镇长的女儿枢都夏莲，在逃跑时在海滩上遇见了御原凛音，而凛音收留了他，并给他取了三千界切那这个名字，这场旅行正式拉开了序幕。  </p><p>然而没那么简单orz</p><h2 id="夏篇"><a href="#夏篇" class="headerlink" title="夏篇"></a>夏篇</h2><blockquote><p>注：Flowchart中，白色描边<font color="878787"><strong>灰点</strong></font>代表一节（可能有分支也可能没有），<font color="000000"><strong>黑色</strong></font>点代表BE，<font color="66ccff">蓝色</font>点代表下一章，<font color="878787"><strong>灰色</strong></font>无描边点代表No retrun,<font color="FF7700"><strong>橙色</strong></font>点代表除了BE的其他结局</p></blockquote><p><img src="https://s1.ax1x.com/2018/07/26/PNksnH.md.png"><br>夏篇才是ISLAND里面最像一个galgame的地方，你有三条路（虽然凛音线是被锁住的），三个<em>女主</em>对你似乎都有好感。<br>它同时也是ISLAND埋伏笔的地方。<br>游戏一开始就将你引入到男主是从未来来的误区，也让玩家以为切那就是凛音5年前遇到的切那。（结果都不是）<br>在夏篇中就已经提到切那是为了拯救人而“回到过去”，做法是“杀死切那”。<br>而要拯救的那个人就是凛音（吗？）<br>但是这样是说不通的，有一个cg是切那脑中闪过的模糊的凛音穿婚纱的样子，对象肯定是切那（切那视角）</p><p><img src="https://s1.ax1x.com/2018/07/26/PNAZvD.md.png"></p><p>总之，打完夏篇，你要在意的是：<br>1.凛音没有患煤纹病。<br>2.凛音说她也是时空旅行者。<br>3.BE未来预想图只是切那的脑补。<br>4.夏莲和纱罗线和主线有着关系，要认真打（虽然我是跳着打的orz）。<br>5.凛音的房间很整洁。<br>6.浦岛太郎和玉手箱。</p><h2 id="夏莲篇"><a href="#夏莲篇" class="headerlink" title="夏莲篇"></a>夏莲篇</h2><p>不过多介绍，但是这里出现了一个之后对主线有着重要作用的人——桃香。</p><h2 id="纱罗篇"><a href="#纱罗篇" class="headerlink" title="纱罗篇"></a>纱罗篇</h2><p>需要在意地方：<br>1.玖音的房间很乱。<br>2.纱罗的母亲万里爱。<br>3.少儿不宜的全年龄向内容（下面是玖音说的）<br><img src="https://s1.ax1x.com/2018/07/26/PNE1eJ.md.jpg"></p><h2 id="凛音篇"><a href="#凛音篇" class="headerlink" title="凛音篇"></a>凛音篇</h2><p>这篇前面在发糖，后面就很难受，概括来讲就是：  </p><p>岛上盛行一种疾病——煤纹病。凛音表面是很害怕自己也得煤纹病，所以一直闭门不出，但真实原因是因为害怕自己和传说中的凛音一样，所以凛音也将setsuna当成了真正的切那，二人相爱了。<br><img src="https://s1.ax1x.com/2018/07/26/PNZcM8.md.png"><br>但是在纱罗的推理下，认为这个世界存在平行世界，他们认为setsuna为了拯救凛音重复了无数次，推理的结果是凛音认为眼前的setsuna杀掉了五年前的切那，于是自己到达了暴龙岛，想要杀掉5年前的凛音。<br><img src="https://s1.ax1x.com/2018/07/26/PNkKhV.png"><br>但是这是不可能的，其实并没有平行宇宙这种事情，setsuna也追随到了暴龙岛，最后二人和解，二人坐着一条船回来的时候，切那因为脱力沉入海中，而凛音为了救他丧命。而后，setsuna登上了冷冻睡眠装置，打算到了造出时间机器的年代，乘坐时间机器拯救凛音。<br><img src="https://s1.ax1x.com/2018/07/26/PNCMss.md.png" alt="冷冻睡眠装置"></p><p>是不是很晕呐233，</p><blockquote><p>重回标题，标题变为never island</p></blockquote><h2 id="冬篇"><a href="#冬篇" class="headerlink" title="冬篇"></a>冬篇</h2><p>冬篇才是这个游戏最最最最最最最最最最最最最最最最最最最最</p><pre><code class="c++">while(1)printf(&amp;quot;最&amp;quot;);</code></pre><p>厉害的地方，本在是为了凛音而来，却喜欢上了Rinne（这里指的是我）</p><blockquote><p>下面为了输入方便，会把片假名直接打成英文字母，如リンネ=Rinne</p></blockquote><p>概括来讲就是：<br>20000年后，切那再次醒来发现自己身处雪原，有一个年幼的女孩救了昏迷的自己，模糊的样子让人容易想起谁。<br><img src="https://s1.ax1x.com/2018/07/26/PNmChn.md.png"><br>女孩的名字叫Rinne（Rinne，这里用的是片假名，夏篇的那个凛音用的是平假名），他们生活在一个叫IslandEurasia的避难所，生活的很艰难，Rinne很不会整理东西，不但自己房间很乱，还把之前哥哥的房间当成杂货间，setsuna在这里找到了工作，拿到了Rinne哥哥的名环，作为setsunaOhara在这个避难所生活。</p><p>但是因为有很多孩子没有名环，所以有暗势力组织暴动，KarenKruz就是他们的老大。setsuna作为反叛军和教会的纽带，也想让教会理解没有名环的孩子的痛苦，但因为这样，想要让大家和平生活的SarahGarland被当做魔女烧死了，<br><img src="https://s1.ax1x.com/2018/07/26/PNir8O.md.png"></p><p>KarenKruz也因为被太阳照射而病发煤纹病，去医院的时候带上了Rinne的名环<br><img src="https://s1.ax1x.com/2018/07/26/PNiNr9.md.png"><br>最后只剩下setsuna和Rinne两个人在山洞中过活，可好景不长，食物越来越少，两人渐渐撑不下去了，有一天setsuna到island外的雪地里发现了冷冻睡眠装置，那是自己乘坐的那一个。</p><p>“重要的东西原来近在咫尺啊”setsuna意识到自己真正要拯救的人是眼前的Rinne，他很坚定的告诉Rinne自己一定要回到他们相遇的时候，杀死自己，来拯救Rinne，Rinne最后只能妥协，setsuna把自己的名环当做戒指交给了Rinne，但是Rinne却把时间设定在了1999年——切那的时代。</p><h2 id="真夏篇"><a href="#真夏篇" class="headerlink" title="真夏篇"></a>真夏篇</h2><p>真夏篇揭露了煤纹病其实是伴X显性遗传病，分急性和非急性。<br>setsuna再次在浦岛醒来，他明白了自己究竟该拯救谁，就像开挂一样的快速培养自己与身边的人的关系，完成了在夏篇中没能够做到的很多事。</p><h3 id="关于凛音END"><a href="#关于凛音END" class="headerlink" title="关于凛音END"></a>关于凛音END</h3><p>他对玖音表达了自己想让凛音幸福，玖音幸福地答应了,想要让setsuna给凛音幸福<br><img src="https://s1.ax1x.com/2018/07/26/PNCnzQ.md.png"><br>setsuna和凛音的关系发展得很顺利，大家都在为他们祝福，就在这样一个环境下，setsuna与凛音步入了婚姻的殿堂<br><img src="https://s1.ax1x.com/2018/07/26/PNAmKe.md.png"></p><h3 id="关于re：END"><a href="#关于re：END" class="headerlink" title="关于re：END"></a>关于re：END</h3><p>他对玖音表达了自己想让Rinne幸福，但是，自己却将玖音惹火了，玖音质问他，当自己生下凛音的时候他在哪里，自己和凛音这么多年来是怎么熬过来的，setsuna完全不知道，就这样，玖音跑走了。<br><img src="https://s1.ax1x.com/2018/07/26/PNCeJS.md.png"><br>setsuna在小镇上遇到了纱罗的母亲万里爱，她把setsuna来岛上的一切都告诉了他:  </p><p>在浦岛上有御三家，御原家，枢都家，伽蓝堂家。在御原家有一个没有名字，不知道出身的女孩子，大家都叫她「小空」，同时御原家也有一个小婴儿——凛音，凛音实际上是小空的亲生女儿，但是却寄养在御原家中，御原家的女主人御原玖音对凛音和小空太过亲近，而感到非常不高兴，不久就开始了对她们的虐待，随后在1988年的夏天，凛音在海边的断崖上坠落，三天后漂流到了附近的海滨，而在一个月后，御原玖音的遗体在本土的港口被发现了，后来小空被迫只得冒充御原玖音生活。而凛音被发现时，有一个男孩子在海滩上救了她，男孩是御原切那，御原家的长子，之后凛音就和切那成了好友，切那自己一个人住在海滨的小屋里，和凛音一起抓虫子，辅导数学题目，直到1993年，凛音想要给切那过生日的时候，脚滑坠海，切那去救了她，并带凛音到了海边的小屋中，二人发生了关系，但在天亮时被父亲御原典正发现了，切那遭受了典正的一顿暴打，被扔进了海里，而后凛音被阳光下身患煤纹病的御原典正吓到了，听到了切那的呼救，跑去救切那，二人失去平衡坠入海中，一起漂流到了暴龙岛，在岛上切那为她寻找到了逃生的船，其实就是冷冻睡眠装置，于是凛音在其中被冷冻了5年，直到1998年6月才漂回浦岛，而报纸对外界宣称遭受神隐的少女回归了，2个月之后，setsuna便到了这座岛上。</p><p>似乎明白了什么的他进入玖音的房间，打算好好谈谈。<br>门没锁，玖音就这样躺在地上睡着了，<br><img src="https://s1.ax1x.com/2018/07/26/PNuYYd.md.png"></p><p>“这是追逐梦想的人的房间”setsuna知道，玖音实际上就是Rinne，setsuna坐上去的不是时空机器，而是，冷冻睡眠装置，Rinne知道了这一点，也坐上了根据蓝图开发的冷冻装置。<br>他和Rinne所在的那个避难所，实际上是20000年前的时间，他做出了决定，打算和她一起完成他们二人的梦想，切那决定再次坐上冷冻装置，他要再次前往neverisland拯救真正应该拯救的少女。</p><h2 id="真冬篇（序章）"><a href="#真冬篇（序章）" class="headerlink" title="真冬篇（序章）"></a>真冬篇（序章）</h2><pre><code>FW欠我一个真冬篇！！</code></pre><p>“Rin、ne——”嘴里自然地发出了声音,<br>那刻在记忆深处的话语,<br>到现在还没能拯救的，<br><strong>最后</strong>的少女的名字<br><font size=10>“Rin、ne！！！！”</font><br>————就在那时。<br>沙沙地踏雪的声音。<br>“……谁？……”<br>抬起头。<br>映入眼帘的是，担心地看着我的那张脸。<br><img src="https://s1.ax1x.com/2018/07/26/PNFRlF.md.png"><br>那张脸令人十分怀念。<br>让人不禁落泪一般地惹人怜爱，<br>“为什么……”<br>啊，你是……<br>“为什么你知道我的名字？”<br>你,是——……</p><h1 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h1><p>上面的内容是不是看得云里雾里？那就对了！要想真正体验ISLAND还是要自己去玩一下啊。</p><h2 id="御原-凛音-（おはら-りんね）"><a href="#御原-凛音-（おはら-りんね）" class="headerlink" title="御原 凛音 （おはら りんね）"></a>御原 凛音 （おはら りんね）</h2><p>看上去是女主，然而确实女主的女儿2333<br>当初就是为了凛音的人设才开始游戏的，结果冬篇最后喜欢上了Rinne。<br>凛音一直喜欢说「因为――我也是个时间旅行者啊」,一开始以为只是为了附和setsuna，结果从某种意义上来说还真的是。<br>这个孩子也受够了苦，从小受虐待，喜欢的人死了，记忆也是缺失的。<br>setsuna出现后，与他玩上了过家家的游戏，setsuna不是那个御原切那，这一点凛音比谁都清楚。<br>一开始分不清Rinne和凛音，冬篇后才发现这完全是两个人，从房间和性格各个方面都可以感受得到。</p><h2 id="伽蓝堂-纱罗-（がらんどう-さら）"><a href="#伽蓝堂-纱罗-（がらんどう-さら）" class="headerlink" title="伽蓝堂 纱罗 （がらんどう さら）"></a>伽蓝堂 纱罗 （がらんどう さら）</h2><p>原以为是全作的智商担当，结果是胡乱瞎猜素质巫女。<br>动不动就要杀了setsuna<br>凛音篇的时候更是助攻送了凛音一程<br>难受QAQ  </p><p>不过冬篇里的Sarah还是很不错的。</p><h2 id="枢都-夏莲-（くるつけ-かれん）"><a href="#枢都-夏莲-（くるつけ-かれん）" class="headerlink" title="枢都 夏莲 （くるつけ かれん）"></a>枢都 夏莲 （くるつけ かれん）</h2><p>可以从夏莲身上看到自己的影子，努力地想要出岛，与父亲作对，因该是本作中最正常的女生了吧（虽然在冬篇里是靠那啥吃饭的）</p><h2 id="三千界-刹那-（さんぜんかい-せつな）"><a href="#三千界-刹那-（さんぜんかい-せつな）" class="headerlink" title="三千界 刹那 （さんぜんかい せつな）"></a>三千界 刹那 （さんぜんかい せつな）</h2><p>我至今都没弄懂setsuna到底是哪里来的……<br>13岁到37岁通吃，正好是冬篇Rinne的岁数和真夏篇玖音的岁数。<br>单曲大小（&lt;=8cm）  </p><h2 id="RinneOhara-（リンネオハラ）-御原-玖音"><a href="#RinneOhara-（リンネオハラ）-御原-玖音" class="headerlink" title="RinneOhara （リンネオハラ）/ 御原 玖音"></a>RinneOhara （リンネオハラ）/ 御原 玖音</h2><p>什么都不说，先唱岛歌</p><p>ランランララン～♪アイランジャ～♪戦え爱を守るため～♪今だ！合体だ！セツナ！リンネ！</p><p>本作的灵魂，充满活力的少女<br>特别喜欢Rinne说过的一句话：“一直呆在一起的话，就会慢慢喜欢上的吧” QAQ 我现在后悔死了</p><p>这里留白就好，要不然会写到明天。</p><h1 id="BGM"><a href="#BGM" class="headerlink" title="BGM"></a>BGM</h1><p>一开始觉得不是很好听，有一首还挺像《桑坦路奇亚》。<br>直到打完后，重新听OST，才发现这是天籁😭<br>最顶上的网易云音乐外链就是整个OST<br>推荐第2、20、35、38首</p><h1 id="乱七八糟想说的"><a href="#乱七八糟想说的" class="headerlink" title="乱七八糟想说的"></a>乱七八糟想说的</h1><p>要说我打通的galgame，ISLAND是第一部，打完的那一天，停在标题画面久久无法释怀。<br>完全被作者牵着鼻子走了，夏篇的时候只想着凛音却把很多伏笔漏了。<br>凛音篇的时候总以为自己就是那个切那，能让凛音幸福，结果还是假面。<br>冬篇的时候总想着回去救凛音，甚至对和Rinne在一起的日常感到厌烦，结果到了最后才发现自己想拯救的是Rinne而不是凛音😭<br>一直都是这样，整个游戏下来我一直都很难受。<br>这个游戏玩下来不但烧脑，虐心，伤眼睛，还疯狂打脸，但即便如此，我仍然觉得这是个好游戏，欠我真冬篇啦！烂人杰！<br>哦 对，这里有一篇超厉害的<a href="https://tieba.baidu.com/p/5272565737">伏笔回收</a><br>还有这个标签什么鬼啊，性和犯罪，难道只要擦到了边算吗？<br>还是说本来可以不加，官方为了销量故意加的？<br><img src="https://s1.ax1x.com/2018/07/26/PNyAvq.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[2018NOI导刊]B君的病症</title>
    <link href="/2018/10/01/%5B2018NOI%E5%AF%BC%E5%88%8A%5DB%E5%90%9B%E7%9A%84%E7%97%85%E7%97%87/"/>
    <url>/2018/10/01/%5B2018NOI%E5%AF%BC%E5%88%8A%5DB%E5%90%9B%E7%9A%84%E7%97%85%E7%97%87/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>享国之日浅，国家无事。<br>B 君看到了 Z 君的第二题，觉得很难。 于是自己出了一个简单题。 大 A 是一名强迫症患者，现在他要给一群带颜色的珠子排成一列，现在有 n 种颜色，其中第 i 种颜色的珠子有 ai 个。要求排列中第 i 种颜色珠子的所有珠子，一定要排在第 i + 1 种颜色的第一个和最后一个珠子之间。问有多少种排列珠子的方案，因为方案数会很大，所以请输出答案对1000000007 取模之后的结果。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 n。 以下 n 行，每行一个整数 ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数表示答案。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>3244</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>168</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于 100% 的数据，满足 1 ≤ n ≤ 10^4 , 2 ≤ ai ≤ 15。 对于 70% 的数据，满足 1 ≤ n ≤ 10^2。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;cstdio&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;#define MOD 1000000007#define MAXN 100001long long fact[MAXN],inv[MAXN];long long pow(long long a,long long b)&#123;    long long ans=1;    while(b)&#123;        if(b&amp;amp;1)ans=a*ans%MOD;        a=a*a%MOD;        b&amp;gt;&amp;gt;=1;    &#125;    return ans%MOD;&#125;long long c(long long m,long long n)&#123;    return fact[m]*inv[n]%MOD*inv[m-n]%MOD;&#125;void pre()&#123;    fact[0]=1;    inv[0]=1;    for(int i=1;i&amp;lt;MAXN;i++)&#123;        fact[i]=fact[i-1]*i%MOD;        inv[i]=pow(fact[i],MOD-2);    &#125;&#125;int main()&#123;    long long x,y;    pre();    cin&amp;gt;&amp;gt;x;    long long z=1;    int s=0;    for(int i=1;i&amp;lt;=x;i++)&#123;        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;y);        z=z*c(s+y-2,y-2)%MOD;        s+=y;    &#125;    cout&amp;lt;&amp;lt;z;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2018NOI导刊被虐记</title>
    <link href="/2018/10/01/2018NOI%E5%AF%BC%E5%88%8A%E8%A2%AB%E8%99%90%E8%AE%B0/"/>
    <url>/2018/10/01/2018NOI%E5%AF%BC%E5%88%8A%E8%A2%AB%E8%99%90%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>结束以来已经过了很久了，终于有时间填坑，写这篇博客的目的就是想要保存这份回忆，无论今后怎么也好，当下才是最重要的。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>好像我是比较晚和大家在火车站集合的，为了一个舒适的路程，特意买的是高铁票（为此还放弃了直达票）<br>路程大概是宜春-&gt;杭州-&gt;常州-&gt;嘉兴-&gt;宜春<br>正好宜春这边有暴雨，赶紧逃！<br>高铁上还是比较舒适的，有电有网有吃，十几个人把电脑打开，俨然一个高档网吧（误）  </p><center><img src="https://s1.ax1x.com/2018/07/26/PtjSnf.md.jpg" width="100%" height="100%" /></center>然而只有到杭州的那段路是这样的，后面就十分无聊了（杭州的火车站是真的大）  <p>在杭州站捐了50元给一个关爱听障组织，一个同学还笑我，受不了。不过也确实如他所说，万一是骗子怎么办？要是我没有看过《声之形》的话我还会不会给他捐钱呢？说实话我也不清楚。</p><p>杭州-&gt;常州的那段遇到了一位日本女士，带着一对小孩（兄妹），为什么这两个小孩会这么乖啊！上车的时候被堵在车厢走廊，别的小孩都在闹，但那对兄妹也没有吵（也许是身在国外？这对小孩只会日语，但母亲会中文）</p><p>到了之后已经很晚了，于是老师带我们去吃饭，好甜，我指的是菜。。。  </p><p>这7天住酒店，两个人一间房，但是因为我们这边男生个数是奇数，所以我就和另一个参加培训的常州本地学生一间房，嘛，感觉还是可以的，他也一直在玩手机，对话完了之后两个人都在做自己的事。<br>也幸亏我和他住一间房，才知道培训的地方临时换了，通知了我们学校的人。（常州高级中学-&gt;常州外国语学校，据说前者被举报暑假补课）<br>总之远了多，每天坐大巴一个小时好难受。  </p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>早上到了常州外国语学校（私立）就觉得这学校不一般，特别气派<br><img src="https://s1.ax1x.com/2018/07/26/PtXiS1.md.jpg"><br>就连机房里都装了Ubuntu（NOILinux）</p><p>正式开始上课！！<br>上午曹文老师讲课，年纪比较大，讲了些基本算法（枚举，模拟，递推和递归），第一次发现原来基本算法也不简单。<br>中午在学校食堂吃饭，不得不说15元一餐就是不一样，三荤一素有水果有汤，菜多的吃不完。<br>下午的老师是堵君懿，NOI金牌（之后给我们授课的老师基本都是这种“怪物”），完全跟不上节奏，大概也是讲了些基本算法，还有点数学内容。</p><p>在和旁边同学闲聊的时候了解到他们基本是从初中开始学的，还有很多从小学开始学的，如果就按学习oi的时间来讲，我们可能他们所有人的学弟学妹吧。</p><p>还有就是在提高组的学生里面有挺多学习态度不端正的（尤其是我旁边的），交了这么多钱，结果就是下课打游戏，上课讲话，摸鱼，睡觉的态度。</p><p>晚自习后回酒店，第一次用浴缸洗澡，有点不习惯，洗完衣服就睡了，第一天实在是太累了。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>第二天一整天都是蔡昊源老师讲课，讲着讲着看我们觉得太难了就开始讲语文，如果觉得这两个都很难的怎么办😂。</p><p>一整天讲的都是动态规划，主要是优化，什么前缀和，矩阵乘法，四边形不等式，斜率优化，单调队列，凸包（有些是day7才讲的）  </p><p>主要是晚上的考试，差点爆零，结果有两道是codeforces上的……其实我觉得这7天3次考试题目基本和讲的内容没关系。</p><p>最后一次用浴缸洗，之后就没有这么享受了。</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>第三天讲课老师的名字忘了，总之也很厉害，一天的搜索，特别精彩。</p><p>上午是深搜和广搜，然后拓展了一下迭代加深深搜和双向广搜，然后讲了下剪枝。</p><p>下午的随机化搜索令人影响深刻，由爬山推广到模拟退火，玄的不能再玄的算法，在某些时候还真的很管用。</p><p>晚上给我们重新讲了些前些天的内容，各种数学知识orz，在这些人面前自己真的就是⑨。</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>第四天和第五天由毕克——毕大爷（codeforces红名）给我们讲课，说实话还是挺喜欢的，就是身上很臭。这一天就是讲数据结构。</p><p>上午讲了堆，并查集，字符串hash（这东西贼神奇）。<br>讲字符串hash的时候讲了好久关于hack的内容，明明我们NOI和NOIP用不到，但是听着很有趣。</p><p>下午讲树状数组，差分，线段树。</p><p>晚上考试很难过，有一个要求组合数的题目，结果要用一个我听都没听过的方法——逆元，还要用到<em>费马小定理</em>，我太弱了orz</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>上午对昨天的考试做了讲评，讲了逆元，以及 $ 方差=平方的平均数-平均数的平方 $</p><p>然后就是乱七八糟的听不懂的东西，什么积性函数，欧拉函数，莫比乌斯函数。</p><p>下午讲了概率与期望，又是一些乱七八糟颠覆尝试的东西。<br>比如说：<em><strong>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。</strong></em></p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>后面两天都是李煜东讲课，（毕克说BZOJ网址lydsy是李煜东刷牙的意思233）</p><p>他是《算法竞赛进阶指南》的作者，可以看得出他写这本书特别用心，而且也确实很优秀，推荐！<br><a href="http://www.lydshy.com/">他的个人网站</a></p><p>这一天讲的是图论，树的直径，树的中心，图的直径，树网的核……总之还有一大堆神奇算法。  </p><p>晚上考试第二题太暴力了!拉出去续一秒！</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><p>这一天详细地讲了下动态规划的各种方法，讲了下昨天考试的题目。<br>下午发了点奖品，我这种蒟蒻当然是没有的，不过我有些同学还是拿到了的李煜东的亲笔签名书<img src="https://s1.ax1x.com/2018/07/26/PtzSnx.md.jpg"><br>晚上没有晚自习，老师带我们去川菜馆吃，然而也不是很辣。<br>因为那个本地人今晚回家，为了省钱我就和另外两个同学一起住，打了一下cs1.6（真的是打了“一下”）</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>感觉这次培训收获到最多的东西就是<strong>很多新名词</strong>（雾）<br>一开始还是挺兴奋的，但后面还是在三点一线的日常。从每个Day的长度就能看出来。<br>很感谢一路走来有同学们和老师的陪伴，如果没有他们，这场培训我估计会撑不住。<br>这次培训之后感觉自己还是有很多不懂，无论是没学过的，还是已经学过的，听这些大佬讲课，总有新的收获，但是这7天课程安排太紧，想要消化是不可能的，所以回来过后还是要多练。</p><p>NOIP2018加油！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[poj1845]Sumdiv</title>
    <link href="/2018/10/01/%5Bpoj1845%5DSumdiv/"/>
    <url>/2018/10/01/%5Bpoj1845%5DSumdiv/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Consider two natural numbers A and B. Let S be the sum of all natural divisors of A^B. Determine S modulo 9901 (the rest of the division of S by 9901).</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>The only line contains the two natural numbers A and B, **(0 &lt;= A,B &lt;= 50000000)**separated by blanks.</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>The only line of the output will contain S modulo 9901.</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>2 3</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>15</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>[latex] 2^3 = 8. [/latex]<br>The natural divisors of 8 are: 1,2,4,8. Their sum is 15.<br>15 modulo 9901 is 15 (that should be output). </p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>Romania OI 2002</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="http://poj.org/problem?id=1845">Sumdiv</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>刚一看到这个题，一股浓浓的数论感就扑面而来，求$ A^B $的约数和，暴力当然是不可取的，我们不妨换个角度<br>如果我们把$ A $分解质因数，表示为</p><p>$$ A=p_1^(c_1)*p_2^(c_2)<em>p_3^(c_3)</em>…*p_n^(c_n) $$</p><p>那么[latex] A^B [/latex]可表示为<br>$$ A=p_1^{(B<em>c_1)}<em>p_2^{(B</em>c_2)<em>p_3^(B</em>c_3)}</em>…<em>p_n^(B</em>c_n) $$<br>则[latex] A^B [/latex]所有约数和为<br>$$ (1+p_1+p_1^2+…+p_1^(B<em>c_1))</em> $$</p><h2 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;#define MAXN 50001const int MOD=9901;long long a,b;long long p[MAXN],c[MAXN];long long m;long long ans;  long long pow(long long p,long long n)&#123;    long long sq=1;    while(n)&#123;        if(n&amp;amp;1)sq=(sq*p)%MOD;        n&amp;gt;&amp;gt;=1;        p=(p*p)%MOD;    &#125;    return sq;&#125; bool prime(int n)&#123;    if(n&amp;lt;2)return 0;    for(int i=2;i&amp;lt;=sqrt(n);i++)&#123;        if(n%i==0)return 0;    &#125;    return 1;&#125; void divide(int n)&#123;    m=0;    for(int i=2;i&amp;lt;=sqrt(n);i++)&#123;        if(n%i==0&amp;amp;&amp;amp;prime(i))&#123;            p[++m]=i,c[m]=0;            while(n%i==0)n/=i,c[m]++;        &#125;    &#125;    if(n&amp;gt;1&amp;amp;&amp;amp;prime(n))p[++m]=n,c[m]=1;    return;&#125; long long sum(long long p,long long c)&#123;    if(c==0)return 1;    if(c%2==0)return (sum(p,c/2-1)*(1+pow(p,c/2+1))+pow(p,c/2))%MOD;    else return (sum(p,c/2)*(1+pow(p,c/2+1)))%MOD;&#125; void work()&#123;    ans=1;    for(int i=1;i&amp;lt;=m;i++)&#123;        ans=(ans*sum(p[i],c[i]*b)%MOD)%MOD;    &#125;&#125; int main()&#123;    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;    divide(a);    work();    printf(&amp;quot;%lld&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[poj3263]Tallest Cow</title>
    <link href="/2018/10/01/%5Bpoj3263%5DTallest%20Cow/"/>
    <url>/2018/10/01/%5Bpoj3263%5DTallest%20Cow/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>FJ’s N (1 ≤ N ≤ 10,000) cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height H (1 ≤ H ≤ 1,000,000) of the tallest cow along with the index I of that cow.</p><p>FJ has made a list of R (0 ≤ R ≤ 10,000) lines of the form “cow 17 sees cow 34”. This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17.</p><p>For each cow from 1..N, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints.</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>Line 1: Four space-separated integers: N, I, H and R<br>Lines 2..R+1: Two distinct space-separated integers A and B (1 ≤ A, B ≤ N), indicating that cow A can see cow B.</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>Lines 1..N: Line i contains the maximum possible height of cow i.</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>9 3 5 51 35 34 33 79 8</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>545344555</code></pre><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>USACO 2007 January Silver</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="http://poj.org/problem?id=3263">Tallest Cow</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;map&amp;gt;using namespace std;int d[100001];unsigned int s[100001];int n,i,h,r;int x,y;map&amp;lt;pair&amp;lt;int,int&amp;gt;,bool&amp;gt; judge; int main()&#123;    scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;i,&amp;amp;h,&amp;amp;r);    d[1]=h;    for(int i=1;i&amp;lt;=r;i++)&#123;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        if(x&amp;gt;y)swap(x,y);        if(judge[make_pair(x,y)])continue;        d[x+1]--,d[y]++;        judge[make_pair(x,y)]=1;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;            s[i]=s[i-1]+d[i];    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        printf(&amp;quot;%d\n&amp;quot;,s[i]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[HNOI2003]激光炸弹</title>
    <link href="/2018/10/01/%5BHNOI2003%5D%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/"/>
    <url>/2018/10/01/%5BHNOI2003%5D%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n(N&lt;=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。 </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过32767）。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>2 10 0 11 1 1</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>1</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;int n,R;int a[5002][5002];int ans; int main()&#123;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;R;    for(int i=1;i&amp;lt;=n;i++)&#123;        int x,y,num;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;num);        a[y+1][x+1]=num;    &#125;    for(int i=1;i&amp;lt;=5001;i++)&#123;        for(int j=1;j&amp;lt;=5001;j++)&#123;            a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];        &#125;    &#125;    for(int i=R;i&amp;lt;=5001;i++)&#123;        for(int j=R;j&amp;lt;=5001;j++)&#123;           int tmp=a[i][j]-a[i-R][j]-a[i][j-R]+a[i-R][j-R];           if(ans&amp;lt;tmp)ans=tmp;        &#125;    &#125;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1880][NOI1995]石子合并</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1880%5D%5BNOI1995%5D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1880%5D%5BNOI1995%5D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共2行,第1行为最小得分,第2行为最大得分.</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>44 5 9 4</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>4354</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#define MAXN 402using namespace std;int fmin[MAXN][MAXN];int sum[MAXN];int fmax[MAXN][MAXN];int n;int main()&#123;    memset(fmin,0x3f,sizeof(fmin));    memset(fmax,0,sizeof(fmax));    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        int a;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);        fmin[i][i]=0;        fmin[i+n][i+n]=0;        sum[i]=sum[i-1]+a;    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        sum[i+n]=sum[n]+sum[i];    &#125;    for(int len=2;len&amp;lt;=n;len++)&#123;        for(int i=1;i&amp;lt;=n+n-len+1;i++)&#123;            int j=i+len-1;            for(int k=i;k&amp;lt;j;k++)&#123;                fmax[i][j]=max(fmax[i][j],fmax[i][k]+fmax[k+1][j]+sum[j]-sum[i-1]);                fmin[i][j]=min(fmin[i][j],fmin[i][k]+fmin[k+1][j]+sum[j]-sum[i-1]);            &#125;            &#125;    &#125;    int minn=1&amp;lt;&amp;lt;30;    int maxx=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        minn=min(minn,fmin[i][i+n-1]);        maxx=max(maxx,fmax[i][i+n-1]);    &#125;    printf(&amp;quot;%d\n%d&amp;quot;,minn,maxx);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1049]装箱问题</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1049%5D%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1049%5D%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个箱子容量为 V （正整数，$ 0 &lt;= V &lt;=20000 $），同时有 n 个物品（ $ 0&lt;n&lt;=30 $ ，每个物品有一个体积（正整数）。</p><p>要求 nn 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。<br>注：此问题区分大小写</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>1 个整数，表示箱子容量</p><p>1 个整数，表示有 n 个物品</p><p>接下来 n 行，分别表示这 n 个物品的各自体积</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>1个整数，表示箱子剩余空间。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>2468312797</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>0</code></pre><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>NOIp2001普及组 第4题</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;int n,v;int w[31];int f[20001];int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;v,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;w[i]);    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int j=v;j&amp;gt;=w[i];j--)&#123;            f[j]=max(f[j],f[j-w[i]]+w[i]);        &#125;    &#125;    printf(&amp;quot;%d&amp;quot;,v-f[v]);    return 0;&#125; </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1435]回文字串</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1435%5D%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1435%5D%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。</p><p>比如 “Ab3bd”插入2个字符后可以变成回文词“dAb3bAd”或“Adb3bdA”，但是插入少于2个的字符无法变成回文词。</p><p>注：此问题区分大小写</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个字符串(0&lt;strlen&lt;=1000)</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>有且只有一个整数，即最少插入字符数</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>Ab3bd</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>2</code></pre><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>IOI2000第一题</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里有个易错点，关于strlen函数的。</p><p>strlen()函数其实就是个计数器，它会从字符串开头，到终止符结束，最后返回结果。</p><p>但是，有些时候我们为了方便，会在读入字符串的时候使用scanf(“%s”,a+1)这时候，strlen(a)的返回值一定是0，因为a字符串的开头就是终止符，正确做法strlen(a+1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;char str[5001];int n;int f[5001][5001];int main()&#123;    cin&amp;gt;&amp;gt;str+1;    n=strlen(str+1);    for(int len=1;len&amp;lt;=n;len++)&#123;        for(int i=1;i&amp;lt;=n-len+1;i++)&#123;            int j=i+len-1;            if(str[i]==str[j])f[i][j]=f[i+1][j-1];            else f[i][j]=min(f[i+1][j],f[i][j-1])+1;        &#125;    &#125;    printf(&amp;quot;%d&amp;quot;,f[1][n]);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[hdu1114]猪猪储蓄罐</title>
    <link href="/2018/10/01/%5Bhdu1114%5D%E7%8C%AA%E7%8C%AA%E5%82%A8%E8%93%84%E7%BD%90/"/>
    <url>/2018/10/01/%5Bhdu1114%5D%E7%8C%AA%E7%8C%AA%E5%82%A8%E8%93%84%E7%BD%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我写的是单输入版本，改一下应该不会超时</p></blockquote><hr><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. </p><p>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! </p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. </p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>310 11021 130 5010 11021 150 301 6210 320 4</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible.</code></pre><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>Central Europe 1999</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;int e,F,s;int n;int p[10001],w[10001];int f[10001];const int inf=0x3f3f3f3f;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;e,&amp;amp;F);    s=F-e;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;p[i],&amp;amp;w[i]);        f[i]=inf;    &#125;    f[0]=0;    for(int i=1;i&amp;lt;=s;i++)f[i]=inf;    for(int i=1;i&amp;lt;=n;i++)&#123;        for(int v=w[i];v&amp;lt;=s;v++)&#123;            f[v]=min(f[v],f[v-w[i]]+p[i]);        &#125;    &#125;    if(f[s]==inf)printf(&amp;quot;This is impossible.&amp;quot;);    else printf(&amp;quot;The minimum amount of money in the piggy-bank is %d.&amp;quot;,f[s]);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[HAOI2006]受欢迎的牛</title>
    <link href="/2018/10/01/%5BHAOI2006%5D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/"/>
    <url>/2018/10/01/%5BHAOI2006%5D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。 这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行两个数N,M。 接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B）</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>一个数，即有多少头牛被所有的牛认为是受欢迎的。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>3 31 22 12 3</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>1</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>100%的数据N&lt;=10000,M&lt;=50000</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>虽然网上有不少题解，但我觉得还是自己写下，毕竟题解这东西首先是写给自己的。</p><h2 id="缩点-分析"><a href="#缩点-分析" class="headerlink" title="缩点 分析"></a>缩点 分析</h2><p>假如你已经完全搞懂了tarjan的话可以直接看这里。<br>当我们把所有的强连通分量分别合并到一个点里（每次标记出栈的点，这些点就在同一个强连通分量里），不难发现，统计每一个点的出度，如果有1个点出度为0，那么这个点里的所有牛就是最受欢迎的了，其他情况则没有最受欢迎的牛，如图：</p><h2 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h2><p>tarjan算法用来寻找有向图的强连通分量的算法，它可以在$ O(|V|+|E|) $ 的时间内得出结果。下面内容大部分来源于<a href="http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components">这篇文章</a>。</p><p>为了更好地理解tarjan算法是如何通过dfs来求强连通分量的，我们这里不妨先了解下搜索树。<br>比如这是一个有向图：</p><div align=center>      ![](https://s1.ax1x.com/2018/06/22/PpedBD.png)  </div>而他的搜索树长这样：  <div align=center>      ![](https://s1.ax1x.com/2018/06/22/PpeBAH.png)  </div>从图中我们可以看到3种边（实际上有4种，但是其实第四种只要和第一种一样处理就可以了）<p>1.实线画出来的是<strong>树边</strong>，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。<br>2.用长虚线画出来的是<strong>反祖边</strong>，也被叫做<strong>回边</strong>,它主要是在搜索的时候遇到了一个已经访问过的结点，而且这个结点是当前节点的祖先时形成的。<br>3.用短虚线画出来的是<strong>横叉边</strong>，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点不是当前节点的祖先时形成的。 </p><hr><p>现在我们来看看在 DFS 的过程中强连通分量有什么性质。</p><p>很重要的一点是如果结点 u 是某个强连通分量在搜索树中遇到的第一个结点（这通常被称为这个强连通分量的<strong>根</strong>），那么这个强连通分量的其余结点肯定是在搜索树中以 u 为根的子树中。如果有个结点 v 在该强连通分量中但是不在以 u 为根的子树中，那么 u 到 v 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 u 是第一个访问的结点矛盾了。</p><p>Tarjan 算法主要是在 DFS 的过程中维护了一些信息：dfn、low 和一个栈。</p><p>栈里的元素表示的是当前已经访问过但是没有被归类到任一强连通分量的结点。  </p><p>dfn[u] 表示结点 u 在 DFS 中第一次搜索到的次序，通常被叫做时间戳。</p><p>low[u] 稍微有些复杂，它表示从 u 或者以 u 为根的子树中的结点，再通过一条<strong>反祖边</strong>或者<strong>横叉边</strong>可以到达的<strong>时间戳最小</strong>的结点 v 的时间戳，并且要求 v 有一些<strong>额外的性质</strong>：<font color="FF0000" face="等线"><strong>v 还要能够到达 u。</strong></font>显然通过反祖边到达的结点 v 满足 low 的性质，但是通过横叉边到达的却不一定。<br>可以证明，结点 u 是某个强连通分量的根等价于 dfn[u] 和 low[u] 相等。简单可以理解成当它们相等的时候就不可能从 u 通过子树再经过其它时间戳比它小的结点回到 u。</p><p>当通过 u 搜索到一个新节点 v 的时候可以有多种情况：  </p><p>$ 1° $ 结点 u 通过树边到达结点 v<br>$$ low[u]=min(low[u],low[v]) $$</p><p>$ 2° $ 结点 u 通过反祖边到达结点 v，或者通过横叉边到达结点 v 并且满足 low 定义中 v 的性质<br>$$ low[u]=min(low[u],dfn[v]) $$</p><p>如果 dfn 和 low 相等，那么就不断退栈直到当前结点为止，这些结点就属于一个强连通分量。</p><p>至于如何更新 low，关键就在于第二种情况，当通过反祖边或者横叉边走到一个结点的时候，只需要判断这个结点是否在栈中，如果在就用它的 low 值更新当前节点的 low 值，否则就不更新。因为如果不在栈中这个结点就已经确定在某个强连通分量中了，不可能回到 u。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;#define MAXN 50001int E[MAXN],low[MAXN],Next[MAXN],Head[MAXN],dfn[MAXN],num=0,count,out[MAXN],o,how_many[MAXN],chudu[MAXN],zhan[MAXN],top=0;bool v[MAXN],chuzhan[MAXN];void add(int x,int y,int i)&#123;    E[i]=y;    Next[i]=Head[x];    Head[x]=i;&#125;int find()&#123;    int ans=0;    for(int i=1;i&amp;lt;=o;i++)&#123;        for(int p=Head[out[i]];p;p=Next[p])&#123;            if(!chuzhan[E[p]])&#123;                ans++;            &#125;        &#125;    &#125;    return ans;&#125;void tarjan(int u)&#123;    dfn[u]=low[u]=++num;    zhan[++top]=u;    v[u]=1;    for(int p=Head[u];p;p=Next[p])&#123;        int y=E[p];        if(!dfn[y])&#123;            tarjan(y);            low[u]=min(low[y],low[u]);        &#125;else&#123;            if(v[y])low[u]=min(low[u],dfn[y]);        &#125;    &#125;    if(dfn[u]==low[u])&#123;        int y;        count++;        do&#123;            y=zhan[top--];            v[y]=0;            out[++o]=y;            chuzhan[y]=1;            how_many[count]++;        &#125;while(y!=u);        chudu[count]=find();        o=0;        memset(chuzhan,0,sizeof(chuzhan));    &#125;&#125;int main()&#123;    int n,m;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=1;i&amp;lt;=m;i++)&#123;        int x,y;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        add(x,y,i);    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;        if(!dfn[i])tarjan(i);    &#125;    int c=0,ans;    for(int i=1;i&amp;lt;=count;i++)&#123;        if(!chudu[i])c++,ans=i;    &#125;    if(c==1)cout&amp;lt;&amp;lt;how_many[ans];    else cout&amp;lt;&amp;lt;&amp;quot;0&amp;quot;;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P1908]逆序对</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1908%5D%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P1908%5D%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个数n，表示序列中有n个数。<br>第二行n个数，表示给定的序列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>给定序列中逆序对的数目。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>65 4 2 6 3 1</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>11</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于50%的数据，n≤2500<br>对于100%的数据，n≤40000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>既然名字都叫树状数组，那么肯定是和数有关的咯，我们来先看一个二叉树</p><p><img src="https://s1.ax1x.com/2018/06/17/CxKatA.png" alt="二叉树"></p><p>我们来稍微变下形</p><p><img src="https://s1.ax1x.com/2018/06/17/CxKUkd.png" alt="变形"></p><p>现在我们把树状数组c[]摆放到每一列的顶端</p><p><img src="https://s1.ax1x.com/2018/06/17/CxKtTH.jpg" alt="顶端"></p><p>C[i]代表子树的叶子结点的权值之和<br>我们通过这张图可以知道<br>$$ C[1]=A[1]; $$<br>$$ C[2]=A[1]+A[2]; $$<br>$$ C[3]=A[3]; $$<br>$$ C[4]=A[1]+A[2]+A[3]+A[4]; $$<br>$$ C[5]=A[5]; $$<br>$$ C[6]=A[5]+A[6]; $$<br>$$ C[7]=A[7]; $$<br>$$ C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$<br>通过分情况讨论好像是有什么规律，那有没有更一般的规律呢？<br>我们不妨将树状数组的编号转换成二进制看看<br><img src="https://s1.ax1x.com/2018/06/17/CxKY0e.md.png" alt="二进制"><br>$$ 1=(001)—C[1]=A[1]; $$<br>$$ 2=(010)—C[2]=A[1]+A[2]; $$<br>$$ 3=(011)—C[3]=A[3]; $$<br>$$ 4=(100)—C[4]=A[1]+A[2]+A[3]+A[4]; $$<br>$$ 5=(101)—C[5]=A[5]; $$<br>$$ 6=(110)—C[6]=A[5]+A[6]; $$<br>$$ 7=(111)—C[7]=A[7]; $$<br>$$ 8=(1000)—C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$</p><p>对照式子可以发现  C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i]; （k为i的二进制中从最低位到高位连续零的长度）例如i=8时，k=3。</p><p>而lowbit(x)函数的作用就是取出x的最低位。</p><p>树状数组的优点在于单点更新以及区间查询，对于求逆序对来说，知道一个数的位置x，那么1~x范围内就是比它小的数，而用已经插入的数的个数减去这个数，累加起来就是我们要算的逆序对数。</p><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>上面提到我们要知道一个数的位置，可以用树状数组下标来表示$ c[x] $，但整型范围很大,不可能开这么大的数组，所以我们只需要保留它们的相对大小，用离散化处理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;algorithm&amp;gt;#define MAXN 100001using namespace std;int n;struct node&#123;    int num,index;&#125;a[MAXN];int c[MAXN];//树状数组int A[MAXN];//离散化后的数组int low_bit(int i)&#123;    return i&amp;amp;(-i);&#125;void update(int i,int v)//插入&#123;    while(i&amp;lt;=n)&#123;        c[i]+=v;        i+=low_bit(i);    &#125;&#125;int get_sum(int i)//区间查找&#123;    int res=0;    while(i)&#123;        res+=c[i];        i-=low_bit(i);    &#125;    return res;&#125;bool cmp(node a,node b)  &#123;      return a.num&amp;lt;b.num;  &#125;  int main()&#123;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i].num);        a[i].index=i;    &#125;    sort(a+1,a+1+n,cmp);     int p=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        /*if(a[i].num!=a[i-1].num)p++;        A[a[i].index]=p;*///如果数据中存在重复数据才需要        A[a[i].index]=i;//离散化    &#125;    long long ans=0;    for(int i=1;i&amp;lt;=n;i++)&#123;        update(A[i],1);//插入        ans+=i-get_sum(A[i]);    &#125;    printf(&amp;quot;%lld&amp;quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[POJ3264] Balanced Lineup</title>
    <link href="/2018/10/01/%5BPOJ3264%5D%20Balanced%20Lineup/"/>
    <url>/2018/10/01/%5BPOJ3264%5D%20Balanced%20Lineup/</url>
    
    <content type="html"><![CDATA[<hr><p>注：数据改编自原题，输入输出略有不同</p><hr><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.</p><p>Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>Line 1: Two space-separated integers, N and Q.<br>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i<br>Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>6 31734251 54 62 2</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>630</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;#define MAXN 50001int n,q;int stmin[MAXN][20];int stmax[MAXN][20];void pre_work()&#123;    for(int j = 1; j &amp;lt; 20; ++j)          for(int i = 1; i &amp;lt;= n; ++i)              if(i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n)&#123;                  stmax[i][j] = max(stmax[i][j-1], stmax[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);                  stmin[i][j] = min(stmin[i][j-1], stmin[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);              &#125;&#125;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;q);    for(int i=1;i&amp;lt;=n;i++)&#123;        scanf(&amp;quot;%d&amp;quot;, &amp;amp;stmin[i][0]);         stmax[i][0]=stmin[i][0];    &#125;    pre_work();    for(int i=1;i&amp;lt;=q;i++)&#123;        int x,y;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        int k=(int)(log(y - x + 1.0) / log(2.0));          int maxsum = max(stmax[x][k], stmax[y - (1 &amp;lt;&amp;lt; k) + 1][k]);          int minsum = min(stmin[x][k], stmin[y - (1 &amp;lt;&amp;lt; k) + 1][k]);         printf(&amp;quot;%d\n&amp;quot;,maxsum-minsum);    &#125;    return 0;&#125;</code></pre><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;#define MAXN 50001int n,q;struct Ttree&#123;    int maxdata,mindata;&#125;t[MAXN*4],tmp0;void push_up(int l,int r,int k)&#123;    t[k].maxdata=max(t[k*2].maxdata,t[k*2+1].maxdata);    t[k].mindata=min(t[k*2].mindata,t[k*2+1].mindata);&#125;void make(int l,int r,int k)&#123;    if(l==r)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;t[k].maxdata);        t[k].mindata=t[k].maxdata;        return;    &#125;    int mid=(l+r)/2;    make(l,mid,k*2);    make(mid+1,r,k*2+1);    push_up(l,r,k);    return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123;    if(L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R)return t[k];    int mid=(l+r)/2;    Ttree res1;    if(L&amp;lt;=mid)res1=ask(L,R,l,mid,k*2);    else res1=tmp0;    Ttree res2;    if(R&amp;gt;mid)res2=ask(L,R,mid+1,r,k*2+1);    else res2=tmp0;    Ttree res=&#123;0&#125;;    res.maxdata=max(res1.maxdata,res2.maxdata);    res.mindata=min(res1.mindata,res2.mindata);    return res;&#125;int main()&#123;    tmp0.maxdata=-1e9,tmp0.mindata=1e9;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;q);    make(1,n,1);    for(int i=1;i&amp;lt;=q;i++)&#123;        int x,y;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        Ttree ans;        ans=ask(x,y,1,n,1);        printf(&amp;quot;%d\n&amp;quot;,ans.maxdata-ans.mindata);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[洛谷P2820]局域网</title>
    <link href="/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P2820%5D%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <url>/2018/10/01/%5B%E6%B4%9B%E8%B0%B7P2820%5D%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>某个局域网内有n(n&lt;=100)台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用f(i,j)表示i,j之间连接的畅通程度，f(i,j)值越小表示i,j之间连接越通畅，f(i,j)为0表示i,j之间无网线连接。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大，请求出这个最大值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数n k<br>接下来的k行每行三个正整数i j m表示i,j两台计算机之间有网线联通，通畅程度为m。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，Σf(i,j)的最大值。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>5 51 2 81 3 11 5 32 4 53 4 2</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>8</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>f(i,j)&lt;=1000</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里可以采用存边的方法存储图，再用克鲁斯卡尔按边求出最小生成树，把这些边标记起来，再把没有标记过的相加，这样做的好处是避免数据溢出（当然你也可以开长整型）<br><img src="https://s1.ax1x.com/2018/06/17/CxufsO.png" alt="图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;struct Tedge&#123;    int from;    int to;    int num;&#125;edge[10001];int father[101];//并查集bool Ebook[10001];int n,k,ans;int find(int x)&#123;    if(x==father[x])return x;    return find(father[x]);//这里一定要有return&#125;void solve()&#123;    for(int i=1;i&amp;lt;=k;i++)&#123;        int f1,f2;        f1=find(edge[i].from);        f2=find(edge[i].to);        if(f1!=f2)&#123;            father[f1]=f2;            Ebook[i]=1;        &#125;    &#125;&#125;bool cmp(Tedge a,Tedge b)&#123;    return a.num&amp;lt;b.num;&#125;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k);    for(int i=1;i&amp;lt;=n;i++)father[i]=i;    for(int i=1;i&amp;lt;=k;i++)&#123;        scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;edge[i].from,&amp;amp;edge[i].to,&amp;amp;edge[i].num);    &#125;    sort(edge+1,edge+k+1,cmp);//求最小生成树，边由小到大    solve();    for(int i=1;i&amp;lt;=k;i++)if(Ebook[i]==0)ans+=edge[i].num;    cout&amp;lt;&amp;lt;ans;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[Spoj GSS3]Can you answer these queries III</title>
    <link href="/2018/09/30/%5BSpoj%20GSS3%5DCan%20you%20answer%20these%20queries%20III/"/>
    <url>/2018/09/30/%5BSpoj%20GSS3%5DCan%20you%20answer%20these%20queries%20III/</url>
    
    <content type="html"><![CDATA[<p>阅读量：[views]</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定长度为N的数列A，以及M条指令 (N≤500000, M≤100000)，每条指令可能是以下两种之一：<br>“2 x y”，把 [latex]A[x][/latex] 改成 [latex]y[/latex]。<br>“1 x y”，查询区间 [latex][x,y][/latex] 中的最大连续子段和，即 [latex]max(x≤l≤r≤y)⁡ { \sum_{l\le i \le r} A[i] }[/latex]。<br>对于每个询问，输出一个整数表示答案。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行两个整数N,M</p><p>第二行N个整数Ai</p><p>接下来M行每行3个整数k,x,y，k=1表示查询（此时如果x&gt;y，请交换x,y），k=2表示修改</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每个询问输出一个整数表示答案。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>5 31 2 -3 4 51 2 32 2 -11 3 2</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>2-1</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据范围与约定</p><p>对于100%的数据: N≤500000, M≤100000, |Ai|&lt;=1000</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="树存储空间大小"><a href="#树存储空间大小" class="headerlink" title="树存储空间大小"></a>树存储空间大小</h2><p>这道题与原题略微有点区别，数据输入顺序不一样，以及范围更大了，但是稍微改一下就可以过了。<br>第一个问题，为什么树要开到4*N？<br>首先，我们构造的线段树有可能是完全二叉树（最好情况），叶子节点存储的就是我们每一个点的数据，而我们可以分析下完全二叉树的图。<br><img src="https://s1.ax1x.com/2018/06/15/Cj5EIU.png"><br>不难发现，我们设节点有n个，那么二叉树的层数为[latex] log_2(n+1) [/latex]<br>而设叶子节点有k个，那么就得到一个k与n的关系：[latex] k(1-(1/2)^n)=2n [/latex]<br>n随k的变化关系曲线为<br><img src="https://s1.ax1x.com/2018/06/15/CjHwUx.png"><br>当k趋于无穷大，[latex]n=2k[/latex]</p><p>而对于最坏情况，请参见<a href="https://blog.csdn.net/gl486546/article/details/78243098?locationNum=9&fps=1">这篇文章</a><br>对于最坏的情况我们要开4n的空间来存储。</p><h2 id="树存储方式"><a href="#树存储方式" class="headerlink" title="树存储方式"></a>树存储方式</h2><p>第二个问题，我们要存树，这里可以开一个结构体，里面有四个变量  </p><p>| 变量名称 | 变量作用 |<br>|-|:-:|-|<br>| data | 储存该区间内的最大连续子段和 |<br>| ldata | 储存该区间从左端开始的最大和 |<br>| rdata | 储存该区间从右端开始的最大和 |<br>| sum | 储存该区间内的所有数的和 |</p><p>这些就够了，不必纪录左子树和右子树。</p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>对于每个叶子节点（r==l），我们给他们赋值，而其他节点我们就需要来分析情况了。</p><h3 id="sum的值"><a href="#sum的值" class="headerlink" title="sum的值"></a>sum的值</h3><p>sum的值还用说吗，就是左子树的sum+右子树的sum</p><h3 id="data的值"><a href="#data的值" class="headerlink" title="data的值"></a>data的值</h3><p>data是该区间内的最大连续子段和，所以对于data就有几种可能，而我们要做的就是取最大的：<br>1.data=左子树data<br>2.data=右子树data<br>3.data=左子树rdata+右子树ldata  </p><h3 id="ldata和rdata的值"><a href="#ldata和rdata的值" class="headerlink" title="ldata和rdata的值"></a>ldata和rdata的值</h3><p>ldata储存该区间从左端开始的最大和，所以：<br>1.ldata=左子树ldata<br>2.ldata=左子树sum+右子树rdata<br>rdata同理</p><h2 id="改变值"><a href="#改变值" class="headerlink" title="改变值"></a>改变值</h2><p>改变值其实就是建树，只不过因为只改变一个值，所以分治时要么是左子树，要么是右子树，改变完后要注意重新维护其他点的值。</p><h2 id="查询值"><a href="#查询值" class="headerlink" title="查询值"></a>查询值</h2><p>查询值较为复杂，但我们也可以把它看成一个建树的过程。<br>首先，对于我们要查询的范围，如果这个范围大于等于我们分治下去的范围，那么就返回这个范围的值。（实际上就是我们建树时存在这个范围的点）<br>如果这个范围没有点满足，那么我们可以用叶子节点建树来建成我们想要的范围的点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;#define MAXN 500000struct Ttree&#123;    int data;    int ldata,rdata;    int sum; &#125;t[MAXN*4],tmp0;int n,m;void push_up(int l,int r,int k)&#123;    t[k].sum=t[k*2].sum+t[k*2+1].sum;    t[k].data=max(t[k*2].data,t[k*2+1].data);    t[k].data=max(t[k*2].rdata+t[k*2+1].ldata,t[k].data);    t[k].ldata=max(t[k*2].ldata,t[k*2].sum+t[k*2+1].ldata);    t[k].rdata=max(t[k*2+1].rdata,t[k*2+1].sum+t[k*2].rdata);    return;&#125;void make(int l,int r,int k)&#123;    if(l==r)&#123;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;t[k].data);        t[k].ldata=t[k].rdata=t[k].sum=t[k].data;        return;    &#125;    int mid=(l+r)/2;    make(l,mid,k*2);    make(mid+1,r,k*2+1);    push_up(l,r,k);    return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123;    if(L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R)return t[k];    int mid=(l+r)/2;    Ttree res1;    if(L&amp;lt;=mid)res1=ask(L,R,l,mid,k*2);    else res1=tmp0;/*目前分治的点的左子树不包含要查询的左端范围，不参与建树，tmp0初始化很小，在取最大值的时候含有它的情况会被忽略掉，但是tmp0.sum初始化还是0*/    Ttree res2;    if(R&amp;gt;mid)res2=ask(L,R,mid+1,r,k*2+1);    else res2=tmp0;//同理    Ttree res=&#123;0&#125;;    res.sum=res1.sum+res2.sum;    res.data=max(res1.data,res2.data);    res.data=max(res1.rdata+res2.ldata,res.data);    res.ldata=max(res1.ldata,res1.sum+res2.ldata);    res.rdata=max(res2.rdata,res2.sum+res1.rdata);    return res;&#125;void change(int x,int y,int l,int r,int k)&#123;    if(l==r)&#123;        t[k].data=y;        t[k].ldata=t[k].rdata=t[k].sum=t[k].data;        return;    &#125;    int mid=(r+l)/2;    if(x&amp;lt;=mid)change(x,y,l,mid,k*2);    else change(x,y,mid+1,r,k*2+1);    push_up(l,r,k);    return;&#125;int main()&#123;    tmp0.data=tmp0.ldata=tmp0.rdata=-1e9;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    make(1,n,1);    for(int i=1;i&amp;lt;=m;i++)&#123;        int k,x,y;        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;k,&amp;amp;x,&amp;amp;y);        if(k==1)&#123;            if(x&amp;gt;y)swap(x,y);            printf(&amp;quot;%d\n&amp;quot;,ask(x,y,1,n,1).data);        &#125;else&#123;            change(x,y,1,n,1);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[YZOJ1370]无聊的锤锤</title>
    <link href="/2018/09/30/%5BYZOJ1370%5D%E6%97%A0%E8%81%8A%E7%9A%84%E9%94%A4%E9%94%A4/"/>
    <url>/2018/09/30/%5BYZOJ1370%5D%E6%97%A0%E8%81%8A%E7%9A%84%E9%94%A4%E9%94%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>罗宏明（白客），1988年7月9日出生于中国山东省泰安市，中国内地新生代男演员，毕业于中国传媒大学南广学院。原先是配音员，《搞笑漫画日和》配音团队cucn201的主要成员之一。2013年因出演导演叫兽易小星的搞笑网剧《万万没想到》中的男一号“王大锤”，从而备受关注。<br>    这么火的搞笑剧中，大家是否注意到这样一个剧情(没看过也没关系的)：王大锤要回家过年，上司不让，无奈之下，王大锤就发挥了自己的聪明才智，决定和上司玩个游戏，想着锤锤是个数学白痴，上司欣然答应，胜了就让他回家。游戏是这样的,开始时，白板上有两个不等的整数，他们轮流行动，每次行动必须在白板上写出任意两个已在白板上出现的整数的差且非负，而且这个数字必须是新的，谁再也写不出来就输了。<br>    为了彰显上司魅力，上司让锤锤先开始。上司足够聪明，当然王大锤也不笨，不然会这么火吗？如果你事先知道白板上的数字，聪明的你能推理出王大锤能否回家呢？</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>测试数据有多组，每组有两个整数，即白板上最初的数字，数据保证在int范围内。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每组测试数据输出一行，锤锤能回家就输出“1”，不能输出“0”。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre><code>5 34 8</code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code class="sh">10</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一开始还打算用暴力，写到一般就打消了这个念头。其实显而易见的是，对于正整数n,m来说,这两个数相减可以得出的所有数x,则<br><img src="https://s1.ax1x.com/2018/06/09/CqpwdA.png" alt="公式"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;int gcd(int a,int b)&#123;    return b==0?a:gcd(b,a%b);&#125;int main()&#123;    int n,m;    while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)!=EOF)&#123;        int num=gcd(n,m);        int c1=n/num;//看它最多能写几个数        int c2=m/num;        if(c1&amp;gt;c2)printf(&amp;quot;%d\n&amp;quot;,c1%2);        else printf(&amp;quot;%d\n&amp;quot;,c2%2);    &#125;    return 0;&#125; </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>六度空间</title>
    <link href="/2018/09/30/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
    <url>/2018/09/30/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如下图所示。<br><img src="https://s1.ax1x.com/2018/06/11/CLrnfS.jpg"><br>六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10000，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>10 91 22 33 44 55 66 77 88 99 10</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>简单的一道图的遍历题，这里我用的是bfs（感觉这道题用bfs更简单），超过6次就跳出，这里有一个重点就是如何在队列里判断一轮结束，具体看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;#define MAXN 10001bool a[MAXN][MAXN];//这里可以扣一点开个boolbool visited[MAXN];//用来标记访问过的点，注意重置int n,m;int bfs(int v)&#123;    int que[MAXN];    int head=1,tail=1;    int step=1,last=v;//last存放上一个点访问的最后一个点    int tmp;    int count;    visited[v]=1;    count=1;    que[tail++]=v;    while(head&amp;lt;tail)&#123;        int out=que[head++];//出队元素        for(int i=1;i&amp;lt;=n;i++)&#123;            if(visited[i])continue;            if(a[out][i])&#123;                visited[i]=1;                que[tail++]=i;                count++;                tmp=i;//不断更新，最后访问的点被tmp存到            &#125;        &#125;        if(out==last)&#123;//如果出队元素等于上个点最后访问的点            step++;//说明这一轮结束，step++，last更新为tmp            last=tmp;        &#125;        if(step==7)break;    &#125;    return count;&#125;int main()&#123;    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);    for(int i=1;i&amp;lt;=m;i++)&#123;        int x,y;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);        a[x][y]=a[y][x]=1;//无向图    &#125;    for(int i=1;i&amp;lt;=n;i++)&#123;//从每个点开始        memset(visited,0,sizeof(visited));//每次要重置visited        double ratio;        ratio=bfs(i)*1.0/n*100;        printf(&amp;quot;%d: %.2f%%\n&amp;quot;,i,ratio);//用%%转义字符输出%    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>世界，您好！</title>
    <link href="/2018/09/30/%E4%B8%96%E7%95%8C%EF%BC%8C%E6%82%A8%E5%A5%BD%EF%BC%81/"/>
    <url>/2018/09/30/%E4%B8%96%E7%95%8C%EF%BC%8C%E6%82%A8%E5%A5%BD%EF%BC%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
